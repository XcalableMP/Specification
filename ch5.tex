\chapter{Intrinsic and Library Procedures}
\label{chap:Intrinsic and library procedures}

This specification defines various procedures for system inquiry,
synchronization, computations, etc. The procedures are provided as
intrinsic procedures in Fortran and library procedures in C.

\section{Miscellaneous Intrinsic Procedures}

\begin{itemize}
 \item {\tt xmp\_desc\_of}
 \item {\tt xmp\_all\_node\_num}
 \item {\tt xmp\_all\_num\_nodes}
 \item {\tt xmp\_node\_num}
 \item {\tt xmp\_num\_nodes}
 \item {\tt xmp\_mpi\_comm}
 \item {\tt xmp\_wtime}
 \item {\tt xmp\_test\_async}
 \item {\tt xmp\_gtol}
 \item \verb![C]! {\tt xmp\_malloc}
\end{itemize}

\vspace{0.3cm}

\subsection{\tt xmp\_desc\_t *d = xmp\_desc\_of(XMP object)}

\subsubsection*{Format}

\begin{tabular}{lll}

\verb![F]!&  {\tt xmp\_desc\_t}& {\tt xmp\_desc\_of({\it array-name} $\vert$ {\it template-name} 
$\vert$ {\it nodes-name})}\\

\verb![C]!&  {\tt xmp\_desc\_t}& {\tt xmp\_desc\_of({\it array-name} $\vert$ {\it template-name} 
$\vert$ {\it nodes-name});}

\end{tabular}

             Note that, in Fortran, {\tt xmp\_desc\_of} is a built-in function,
             in C, {\tt xmp\_desc\_of} is an operator.

\subsubsection*{Synopsis}

    A {\tt xmp\_desc\_of} is an input argument of query functions.
    When Query functions get descriptor information of array
    from XMP compiler, they must set a {\tt xmp\_desc\_of} as an
    input argument.

\subsubsection*{Type}

    Formally, a name of type of {\tt xmp\_desc\_of} is {\tt xmp\_desc\_t}.
    Specification of {\tt xmp\_desc\_t} depends on the XMP compiler implementation.

\subsubsection*{Arguments}

   The argument of {\tt xmp\_desc\_of} is an {\it array-name}, a {\it template-name}, or a {\it nodes-name}.
   In the case of {\it array-name}, return value d is a pointer to
   be able to access array descriptor information.
   In the case of {\it template-name}, return value d is a pointer to
   be able to access template descriptor information.
   In the case of {\it nodes-name}, return value d is a pointer to
   be able to access node descriptor information.
   If the argument of {\tt xmp\_desc\_of} is a local data, it is unchanged.

\vspace{0.3cm}

\subsection{\tt xmp\_all\_node\_num}

\subsubsection*{Format}

\begin{tabular}{lll}

\verb![F]!&  {\tt integer function}& {\tt xmp\_all\_num\_nodes()}\\

\verb![C]!&  {\tt int}& {\tt xmp\_all\_num\_nodes(void);}

\end{tabular}

\subsubsection*{Synopsis}
     The {\tt xmp\_all\_node\_num} routine returns the current node number in all available nodes.


\subsubsection*{Arguments}
    none.

\vspace{0.3cm}

\subsection{\tt xmp\_all\_num\_nodes}

\subsubsection*{Format}

\begin{tabular}{lll}

\verb![F]!&  {\tt integer function}& {\tt xmp\_all\_num\_nodes()}\\

\verb![C]!&  {\tt int}& {\tt xmp\_all\_num\_nodes(void);}

\end{tabular}

\subsubsection*{Synopsis}
     The {\tt xmp\_all\_num\_nodes} routine returns the number of all available nodes.

\subsubsection*{Arguments}
    none.


\vspace{0.3cm}

\subsection{\tt xmp\_node\_num}

\subsubsection*{Format}

\begin{tabular}{lll}

\verb![F]!&  {\tt integer function}& {\tt xmp\_all\_num\_nodes({\it nodes-name})}\\

\verb![C]!&  {\tt int}& {\tt xmp\_node\_num({\it nodes-name});}

\end{tabular}

\subsubsection*{Synopsis}
     The {\tt xmp\_node\_num} routine returns the current node number 
     in the executing node set indicated by {\it nodes-name}.

\subsubsection*{Arguments}
     The argument of {\tt xmp\_node\_num} is a {\it nodes-name} of the executing node set.


\vspace{0.3cm}

\subsection{\tt xmp\_num\_nodes}

\subsubsection*{Format}

\begin{tabular}{lll}

\verb![F]!&  {\tt integer function}& {\tt xmp\_num\_nodes({\it nodes-name})}\\

\verb![C]!&  {\tt int}& {\tt xmp\_num\_nodes({\it nodes-name});}

\end{tabular}

\subsubsection*{Synopsis}
     The {\tt xmp\_num\_nodes} routine returns the number of nodes 
     in the executing node set indicated by {\it nodes-name}.

\subsubsection*{Arguments}
    The argument of {\tt xmp\_num\_nodes} is a {\it nodes-name} of the executing node set.


\vspace{0.3cm}

\subsection{\tt xmp\_mpi\_comm}

\subsubsection*{Format}

\begin{tabular}{lll}

\verb![F]!&  {\tt integer function}& {\tt xmp\_mpi\_comm({\it nodes-name})}\\

\verb![C]!&  {\tt int}& {\tt xmp\_mpi\_comm({\it nodes-name});}

\end{tabular}

\subsubsection*{Synopsis}
     The {\tt xmp\_mpi\_comm} routine returns the integer value with associated communicator
     to which {\it nodes-name} belongs. If non {\it nodes-name}, {\tt xmp\_mpi\_comm} returns 
     the value of MPI\_Comm\_World.

\subsubsection*{Arguments}
    The argument of {\tt xmp\_mpi\_comm} is a {\it nodes-name} of the executing node set.


\vspace{0.3cm}

\subsection{\tt xmp\_wtime}

\subsubsection*{Format}

\begin{tabular}{lll}

\verb![F]!&  {\tt double precision function}& {\tt xmp\_wtime()}\\

\verb![C]!&  {\tt double}& {\tt xmp\_wtime(void);}

\end{tabular}

\subsubsection*{Synopsis}
    The {\tt xmp\_wtime} routine returns elapsed wall clock time in seconds 
    since some time in the past. The "time in the past" is guaranteed not to change
    during the life of the process.
    There is no requirement that different nodes return "the same time".

\subsubsection*{Arguments}
    none.


\vspace{0.3cm}

\subsection{\tt xmp\_wtick}

\subsubsection*{Format}

\begin{tabular}{lll}

\verb![F]!&  {\tt double precision function}& {\tt xmp\_wtick()}\\

\verb![C]!&  {\tt double}& {\tt xmp\_wtick(void);}

\end{tabular}

\subsubsection*{Synopsis}
    The {\tt xmp\_wtick} routine returns the resolution of the timer used by {\tt xmp\_wtime}.
    It returns a double precision value equal to the number of seconds 
    between successive clock ticks.

\subsubsection*{Arguments}
    none.


\vspace{0.3cm}

\subsection{\tt xmp\_barrier}

\subsubsection*{Format}

\begin{tabular}{lll}

\verb![F]!&  & {\tt xmp\_barrier({\it nodes-name})}\\

\verb![C]!&  {\tt void}& {\tt  xmp\_barrier({\it nodes-name})}

\end{tabular}

\subsubsection*{Synopsis}
    The {\tt xmp\_barrier} routine blocks the caller until all nodes in the executing node set 
    indicated by {\it nodes-name} have called it.
    The call returns at any process only after all {\it nodes-name} member's nodes
    have entered the call.

\subsubsection*{Arguments}
    The argument of {\tt xmp\_barrier} is a {\it nodes-name} of the executing node set.

\vspace{0.3cm}

\subsection{\tt xmp\_test\_async}

\begin{tabular}{lll}

\verb![F]!& {\tt logical function} & {\tt xmp\_test\_async(async\_id)}\\
\verb![F]!& {\tt integer} & {\tt async\_id}\\
          & & \\
\verb![C]!&  {\tt int} & {\tt  xmp\_test\_async(int async\_id)}

\end{tabular}

\subsubsection*{Synopsis}

The {\tt xmp\_test\_async} routine returns {\tt .true.}, in {\Fort}, or
{\tt 1}, in {\C}, if an asynchronous communication specified by the
argument {\tt async\_id} is complete; otherwise, it returns {\tt .false.}
or {\tt 0}.

\subsubsection*{Arguments}

The argument {\tt async\_id} is an integer expression that specifies an
asynchronous communication initiated by a global communication construct
with the {\tt async} clause or a coarray reference preceded by the {\tt
async} directive.

\vspace{0.3cm}

\subsection{\tt xmp\_gtol}

\begin{tabular}{lll}

\verb![F]!& {\tt subroutine} & {\tt xmp\_gtol(d, g\_idx, l\_idx)} \\
\verb![F]!& {\tt xmp\_desc\_t} & {\tt d}\\
\verb![F]!& {\tt integer} & {\tt g\_idx(NDIMS)}\\
\verb![F]!& {\tt integer} & {\tt l\_idx(NDIMS)}\\
          & & \\
\verb![C]!&  {\tt void} & {\tt xmp\_gtol(xmp\_desc\_t d, int g\_idx[], int l\_idx[])}

\end{tabular}

\subsubsection*{Synopsis}

The {\tt xmp\_test\_async} routine translates an index (specified by
{\tt g\_idx}) of a global array (specified by {\tt d}) into the
corresponding index of its local section and sets to an array specified
by {\tt l\_idx}. If the element of the specified index does not reside
in the caller of the routine, the resulting array is set to an
unspecified value.

\subsubsection*{Arguments}

\begin{itemize}
 \item {\tt d} is a descriptor, that is, an object of type {\tt
       xmp\_desc\_t} that is associated with the target global array.
 \item \verb![F]! {\tt g\_idx} is a rank-one integer array of the size
       equal to the rank of the target global array specified by {\tt
       d}.
 \item \verb![F]! {\tt l\_idx} is a rank-one integer array of the size
       equal to the rank of the target global array specified by {\tt
       d}.
 \item \verb![C]! {\tt g\_idx} is a one-dimensional integer array.
 \item \verb![C]! {\tt l\_idx} is a one-dimensional integer array.
\end{itemize}


\subsection{\tt [C] xmp\_malloc}

\begin{tabular}{ll}

{\tt void*} & {\tt xmp\_malloc(xmp\_desc\_t d, size\_t size)}

\end{tabular}

\subsubsection*{Synopsis}

The {\tt xmp\_malloc} routine allocates a storage for the local section
of a one-dimensional global array of size {\tt size} that is associated
with a descriptor specified by {\tt d}, and returns the pointer to it on
each node.

\subsubsection*{Arguments}

\begin{itemize}
 \item {\tt d} is a descriptor, that is, an object of type {\tt
       xmp\_desc\_t} that is associated with a pointer to the
       one-dimensional global array to be allocated.
 \item {\tt size} is the size of the global array to be allocated.
\end{itemize}


%\section{Computational Intrinsic Procedures}
%
%\subsection{Fortran}
%
%\begin{itemize}
% \item {\tt x = xmp\_scatter(a, idx1, idx2, ...)}
% \item {\tt x = xmp\_gather(a, idx1, idx2, ...)}
% \item {\tt v = xmp\_pack(a, mask)}
% \item {\tt a = xmp\_unpack(v, mask)}
% \item {\tt x = xmp\_sort\_up(a)}
% \item {\tt x = xmp\_sort\_down(a)}
% \item {\tt x = xmp\_cshift(a, shift, dim)}
% \item {\tt x = xmp\_eoshift(a, shift, b, dim)}
% \item {\tt m = xmp\_transpose(m)}
%\end{itemize}
%
%
%\subsection{C}
%
%
%\begin{itemize}
% \item {\tt x = xmp\_scatter(desc\_a, idx1, idx2, ...)}
% \item {\tt x = xmp\_gather(desc\_a, idx1, idx2, ...)}
% \item {\tt v = xmp\_pack(desc\_a, mask)}
% \item {\tt a = xmp\_unpack(desc\_v, mask)}
% \item {\tt x = xmp\_sort\_up(desc\_a)}
% \item {\tt x = xmp\_sort\_down(desc\_a)}
% \item {\tt x = xmp\_cshift(desc\_a, shift, dim)}
% \item {\tt x = xmp\_eoshift(desc\_a, shift, b, dim)}
% \item {\tt m = xmp\_transpose(desc\_m)}
%\end{itemize}
