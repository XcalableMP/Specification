\chapter{Intrinsic and Library Procedures}
\label{chap:Intrinsic and library procedures}

This specification defines various procedures for system inquiry,
synchronization, computations, etc. The procedures are provided as
intrinsic procedures in {\XMPF} and library procedures in {\XMPC}.

\section{System Inquiry Procedures}

\begin{itemize}
 \item {\tt xmp\_desc\_of}
 \item {\tt xmp\_all\_node\_num}
 \item {\tt xmp\_all\_num\_nodes}
 \item {\tt xmp\_node\_num}
 \item {\tt xmp\_num\_nodes}
% \item {\tt xmp\_mpi\_comm}
 \item {\tt xmp\_wtime}
 \item {\tt xmp\_wtick}
\end{itemize}

\subsection{\tt xmp\_desc\_of}
\label{subsec: xmp_desc_of}
\Intrinsic{xmp\_desc\_of}
\index{descriptor-of operator}
\index{xmp\_desc\_of@{\tt xmp\_desc\_of}}

\subsubsection*{Format}

\begin{tabular}{lll}

\verb![F]!&  {\tt integer(kind=xmp\_desc\_kind)}& {\tt xmp\_desc\_of(xmp\_entity)}\\

\verb![C]!&  {\tt xmp\_desc\_t}& {\tt xmp\_desc\_of(xmp\_entity)}

\end{tabular}

\vspace{0.3cm}

Note that {\tt xmp\_desc\_of} is an intrinsic function in {\XMPF} or
a built-in operator in {\XMPC}.

\subsubsection*{Synopsis}

%    A {\tt xmp\_desc\_of} is an input argument of query functions.
%    When Query functions get descriptor information of array
%    from XMP compiler, they must set a {\tt xmp\_desc\_of} as an
%    input argument.

{\tt xmp\_desc\_of} returns, in {\XMPF}, or is evaluated to, in {\XMPC},
a descriptor to retrieve informations of the specified global array,
template, or node array. The resulting descriptor can be used as an
input argument of the inquiry procedures which is described in appendix
\ref{chap:Interface to Numerical Libraries}.

The kind type parameter of the type of the descriptor, {\tt
xmp\_desc\_kind}, in {\XMPF} is implementation-dependent, and defined in
a Fortran module named {\tt xmp\_lib} or a Fortran {\tt include} file
named {\tt xmp\_lib.h}.

The type of the descriptor, {\tt xmp\_desc\_t}, in {\XMPC} is
implementation-dependent, and defined in a header file named {\tt xmp.h}
in {\XMPC}.

%The type of the descriptor, {\tt xmp\_desc\_t}, is
%implementation-dependent, and defined in a Fortran module named {\tt
%xmp\_lib} or a Fortran {\tt include} file named {\tt xmp\_lib.h} in
%{\XMPF}, or a header file named {\tt xmp.h} in {\XMPC}.

\subsubsection*{Arguments}

The argument or operand {\tt xmp\_entity} is the name of either a global
array, a template or a node array.

%   The argument of {\tt xmp\_desc\_of} is an {\it array-name}, a {\it template-name}, or a {\it nodes-name}.
%   In the case of {\it array-name}, return value d is a pointer to
%   be able to access array descriptor information.
%   In the case of {\it template-name}, return value d is a pointer to
%   be able to access template descriptor information.
%   In the case of {\it nodes-name}, return value d is a pointer to
%   be able to access node descriptor information.
%   If the argument of {\tt xmp\_desc\_of} is a local data, it is unchanged.


\subsection{\tt xmp\_all\_node\_num}
\Intrinsic{xmp\_all\_node\_num}

\subsubsection*{Format}

\begin{tabular}{lll}

\verb![F]!&  {\tt integer function}& {\tt xmp\_all\_node\_num()}\\

\verb![C]!&  {\tt int}& {\tt xmp\_all\_node\_num(void)}

\end{tabular}

\subsubsection*{Synopsis}

     The {\tt xmp\_node\_num} routine returns the node number,
     within the entire node set, of the node that calls {\tt
     xmp\_all\_node\_num}.

\subsubsection*{Arguments}

    none.


\subsection{\tt xmp\_all\_num\_nodes}
\Intrinsic{xmp\_all\_num\_nodes}

\subsubsection*{Format}

\begin{tabular}{lll}

\verb![F]!&  {\tt integer function}& {\tt xmp\_all\_num\_nodes()}\\

\verb![C]!&  {\tt int}& {\tt xmp\_all\_num\_nodes(void)}

\end{tabular}

\subsubsection*{Synopsis}

     The {\tt xmp\_all\_num\_nodes} routine returns the number of nodes
     in the entire node set.

\subsubsection*{Arguments}

    none.


\subsection{\tt xmp\_node\_num}
\Intrinsic{xmp\_node\_num}

\subsubsection*{Format}

\begin{tabular}{lll}

\verb![F]!&  {\tt integer function}& {\tt xmp\_node\_num()}\\

\verb![C]!&  {\tt int}& {\tt xmp\_node\_num(void)}

\end{tabular}

\subsubsection*{Synopsis}

     The {\tt xmp\_node\_num} routine returns the node number,
     within the current executing node set, of the node that calls {\tt
     xmp\_node\_num}.

\subsubsection*{Arguments}

none.


\subsection{\tt xmp\_num\_nodes}
\Intrinsic{xmp\_num\_nodes}

\subsubsection*{Format}

\begin{tabular}{lll}

\verb![F]!&  {\tt integer function}& {\tt xmp\_num\_nodes()}\\

\verb![C]!&  {\tt int}& {\tt xmp\_num\_nodes(void)}

\end{tabular}

\subsubsection*{Synopsis}

     The {\tt xmp\_num\_nodes} routine returns the number of the
     executing nodes.

\subsubsection*{Arguments}

none.

%\subsection{\tt xmp\_mpi\_comm}
%
%\subsubsection*{Format}
%
%\begin{tabular}{lll}
%
%\verb![F]!&  {\tt integer function}& {\tt xmp\_mpi\_comm({\it nodes-name})}\\
%
%\verb![C]!&  {\tt int}& {\tt xmp\_mpi\_comm({\it nodes-name})}
%
%\end{tabular}
%
%\subsubsection*{Synopsis}
%     The {\tt xmp\_mpi\_comm} routine returns the integer value with associated communicator
%     to which {\it nodes-name} belongs. If non {\it nodes-name}, {\tt xmp\_mpi\_comm} returns 
%     the value of MPI\_Comm\_World.
%
%\subsubsection*{Arguments}
%    The argument of {\tt xmp\_mpi\_comm} is a {\it nodes-name} of the executing node set.
%
%

\subsection{\tt xmp\_wtime}
\Intrinsic{xmp\_wtime}

\subsubsection*{Format}

\begin{tabular}{lll}

\verb![F]!&  {\tt double precision function}& {\tt xmp\_wtime()}\\

\verb![C]!&  {\tt double}& {\tt xmp\_wtime(void)}

\end{tabular}

\subsubsection*{Synopsis}
    The {\tt xmp\_wtime} routine returns elapsed wall clock time in seconds 
    since some time in the past. The ``time in the past'' is guaranteed
    not to change during the life of the process.
    There is no requirement that different nodes return ``the same time.''

\subsubsection*{Arguments}
    none.


\subsection{\tt xmp\_wtick}
\Intrinsic{xmp\_wtick}

\subsubsection*{Format}

\begin{tabular}{lll}

\verb![F]!&  {\tt double precision function}& {\tt xmp\_wtick()}\\

\verb![C]!&  {\tt double}& {\tt xmp\_wtick(void)}

\end{tabular}

\subsubsection*{Synopsis}
    The {\tt xmp\_wtick} routine returns the resolution of the timer
    used by {\tt xmp\_wtime}. 
    It returns a double precision value equal to the number of seconds 
    between successive clock ticks.

\subsubsection*{Arguments}
    none.


%\subsection{\tt xmp\_barrier}
%
%\subsubsection*{Format}
%
%\begin{tabular}{lll}
%
%\verb![F]!&  & {\tt xmp\_barrier({\it nodes-name})}\\
%
%\verb![C]!&  {\tt void}& {\tt  xmp\_barrier({\it nodes-name})}
%
%\end{tabular}
%
%\subsubsection*{Synopsis}
%    The {\tt xmp\_barrier} routine blocks the caller until all nodes in the executing node set 
%    indicated by {\it nodes-name} have called it.
%    The call returns at any process only after all {\it nodes-name} member's nodes
%    have entered the call.
%
%\subsubsection*{Arguments}
%    The argument of {\tt xmp\_barrier} is a {\it nodes-name} of the executing node set.
%

%\section{Computational Intrinsic Procedures}
%
%\subsection{Fortran}
%
%\begin{itemize}
% \item {\tt x = xmp\_scatter(a, idx1, idx2, ...)}
% \item {\tt x = xmp\_gather(a, idx1, idx2, ...)}
% \item {\tt v = xmp\_pack(a, mask)}
% \item {\tt a = xmp\_unpack(v, mask)}
% \item {\tt x = xmp\_sort\_up(a)}
% \item {\tt x = xmp\_sort\_down(a)}
% \item {\tt x = xmp\_cshift(a, shift, dim)}
% \item {\tt x = xmp\_eoshift(a, shift, b, dim)}
% \item {\tt m = xmp\_transpose(m)}
%\end{itemize}
%
%
%\subsection{C}
%
%
%\begin{itemize}
% \item {\tt x = xmp\_scatter(desc\_a, idx1, idx2, ...)}
% \item {\tt x = xmp\_gather(desc\_a, idx1, idx2, ...)}
% \item {\tt v = xmp\_pack(desc\_a, mask)}
% \item {\tt a = xmp\_unpack(desc\_v, mask)}
% \item {\tt x = xmp\_sort\_up(desc\_a)}
% \item {\tt x = xmp\_sort\_down(desc\_a)}
% \item {\tt x = xmp\_cshift(desc\_a, shift, dim)}
% \item {\tt x = xmp\_eoshift(desc\_a, shift, b, dim)}
% \item {\tt m = xmp\_transpose(desc\_m)}
%\end{itemize}


\section{Synchronization Procedures}

\begin{itemize}
 \item {\tt xmp\_test\_async}
\end{itemize}

\subsection{\tt xmp\_test\_async}
\Intrinsic{xmp\_test\_async}

\begin{tabular}{lll}

\verb![F]!& {\tt logical function} & {\tt xmp\_test\_async(async\_id)}\\
          & {\tt integer} & {\tt async\_id}\\
          & & \\
\verb![C]!&  {\tt int} & {\tt  xmp\_test\_async(int async\_id)}

\end{tabular}

\subsubsection*{Synopsis}

The {\tt xmp\_test\_async} routine returns {\tt .true.}, in {\XMPF}, or
{\tt 1}, in {\XMPC}, if an asynchronous communication specified by the
argument {\tt async\_id} is complete; otherwise, it returns {\tt .false.}
or {\tt 0}.

\subsubsection*{Arguments}

The argument {\tt async\_id} is an integer expression that specifies an
asynchronous communication initiated by a global communication construct
with the {\tt async} clause.


\section{Miscellaneous Procedures}

\begin{itemize}
 \item {\tt xmp\_gtol}
 \item \verb![C]! {\tt xmp\_malloc}
\end{itemize}

\subsection{\tt xmp\_gtol}
\Intrinsic{xmp\_gtol}

\begin{tabular}{lll}

\verb![F]!& {\tt subroutine} & {\tt xmp\_gtol(d, g\_idx, l\_idx)} \\
          & {\tt integer(kind=xmp\_desc\_kind)} & {\tt d}\\
          & {\tt integer} & {\tt g\_idx(NDIMS)}\\
          & {\tt integer} & {\tt l\_idx(NDIMS)}\\
          & & \\
\verb![C]!&  {\tt void} & {\tt xmp\_gtol(xmp\_desc\_t d, int g\_idx[], int l\_idx[])}

\end{tabular}

\subsubsection*{Synopsis}

The {\tt xmp\_gtol} routine translates an index (specified by
{\tt g\_idx}) of a global array (specified by {\tt d}) into the
corresponding index of its local section and sets to an array specified
by {\tt l\_idx}. If the element of the specified index does not reside
in the caller of the routine, the resulting array is set to an
unspecified value.

\subsubsection*{Arguments}

\begin{itemize}
 \item {\tt d} is a descriptor, that is, an object of type {\tt
       integer(kind=xmp\_desc\_kind)}, in {\XMP}, or {\tt xmp\_desc\_t},
       in {\XMPC}, that is associated with the target global array.
 \item \verb![F]! {\tt g\_idx} is a rank-one integer array of the size
       equal to the rank of the target global array specified by {\tt
       d}.
 \item \verb![F]! {\tt l\_idx} is a rank-one integer array of the size
       equal to the rank of the target global array specified by {\tt
       d}.
 \item \verb![C]! {\tt g\_idx} is a one-dimensional integer array.
 \item \verb![C]! {\tt l\_idx} is a one-dimensional integer array.
\end{itemize}


\subsection{\tt [C] xmp\_malloc}
\label{subsec: xmp_malloc}
\Intrinsic{xmp\_malloc}

\begin{tabular}{ll}

{\tt void*} & {\tt xmp\_malloc(xmp\_desc\_t d, size\_t size)}

\end{tabular}

\subsubsection*{Synopsis}

The {\tt xmp\_malloc} routine allocates a storage for the local section
of a one-dimensional global array of size {\tt size} that is associated
with a descriptor specified by {\tt d}, and returns the pointer to it on
each node.

\subsubsection*{Arguments}

\begin{itemize}
 \item {\tt d} is a descriptor, that is, an object of type {\tt
       xmp\_desc\_t} that is associated with a pointer to the
       one-dimensional global array to be allocated.
 \item {\tt size} is the size of the global array to be allocated.
\end{itemize}
