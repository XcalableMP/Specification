\chapter{Memory Consistency Model}

\newcommand{\Coloneqq}{\mathrel{\colon\!=}}
\newcommand{\xsync}{\texttt{xmp\_syn}}
\newcommand{\xasync}[1]{\texttt{xmp\_asyn}(#1)}
\newcommand{\waitasync}[1]{\texttt{wait\_async}(#1)}
\newcommand{\fstmt}{\texttt{f\_stmt}}
\newcommand{\F}[2]{\texttt{Fetch}^{#1} \: {#2}}
\newcommand{\E}[2]{\texttt{Execute}^{#1} \: {#2}}
\newcommand{\R}[2]{\texttt{Reflect}^{#1} \: {#2}}

%loop construct is synchronous.  But practically OK?

%array construct is synchronous.  But semantically OK?

This chapter explains a memory consistency model that XcalableMP adopts.

Memory consistency models specify rules about multiple data accesses
to memories.  Since XcalableMP is an extension of the base languages,
its memory consistency model is also defined to be their extension,
that is, XcalableMP follows all the rules that base languages adopt.

In addition, XcalableMP introduces some rules about \emph{global
  view}.  In global view, \emph{global communication constructs} are
used to access distributed data.  Furthermore, distributed data can be
accessed through designating data in local view.  Conversely,
non-distributed data can be accessed through designating distributed
data by using global communication constructs in global view.  These
are not considered under the memory consistency models of the base
language since global view is a new notion which is introduced by
XcalableMP.

Please recall that global communication constructs are collective as
described in Section~\ref{sec:glossary}.

\section{Execution Traces}

This section explains execution traces that Xcalable memory
consistency model admits.

First, instructions are defined as
\[
i \Coloneqq \xsync \mid \xasync{\textit{async-id}} \mid \waitasync{\textit{async-id}} \mid \fstmt
\]
where $\xsync$ denotes a global communication construct with no
\texttt{async} clause, $\xasync{\textit{async-id}}$ denotes a global
communication construct with the clause
$\texttt{async}(\textit{async-id})$,
%$\waitasync{\textit{async-id}}$ denotes a
%\texttt{wait\_async}(\textit{async-id}),
and $\fstmt$ is a statement.

Next, operations are defined as
\[
o \Coloneqq \F{j}{i} \mid \E{j}{i} \mid \R{j}{i}
\]
where $j$ is a positive integer.

Operation $\F{j}{i}$ denotes that instruction $i$ is fetched at $j$
times.  The integer $j$ is incremented whenever you break or exit
loops.  The instructions that are called at multiple times in loops
are indentified by $j$s.  Operation $\E{j}{i}$ denotes that
instruction $i$ is executed.  Operation $\R{j}{i}$ denotes that effect
of instruction $i$ is reflected to physical memories.

Finally, the memory consistency model defines constraints written by a
partial order $\leq$ on operations as described below.  Execution
traces are defined as sequences of operations that follow the order.
In the following, $o_1 < o_2$ denotes $o_1 \leq o_2$ and $o_1
\not\equiv o_2$, and $o_1 < o_2 < o_3$ denotes $o_1 < o_2$ and $o_2 <
o_3$.

{
\renewcommand{\theequation}{\roman{equation}}
\begin{figure}[htbp]
\begin{align}
& \F{j_1}{i_1} < \F{j_2}{i_2} \mbox{ implies } \E{j_1}{i_1} < \E{j_2}{i_2} \label{constraints:fetchorder}\\
& \E{j_1}{\xsync} < \E{j_2}{i_2} \mbox{ implies } \R{j_1}{\xsync} < \E{j_2}{i_2} \label{constraints:synchronous}\\
& \E{j_1}{\xasync{\textit{async-id}}} < \E{j_3}{\waitasync{\textit{async-id}}} < \E{j_2}{i_2} \mbox{ implies} \nonumber\\
& \R{j_1}{\xasync{\textit{async-id}}} < \E{j_2}{i_2} \label{constraints:asynchronous}
\end{align}
\caption{Constraints that XcalableMP memory consistency model obligates.}\label{fig:constraints}
\end{figure}
}

\subsection{Common Constraints}

This subsection explains some constraints that are common between
synchronous and asynchronous communications.

In XcalableMP memory consistency model, instructions are executed in
the order in which they are fetched.  Formally, this is represented by
\ref{constraints:fetchorder} in Figure~\ref{fig:constraints}.

\subsection{Constraints for Synchronous Communications}

The constructs \texttt{reflect}, \texttt{gmove} (and its following
assignment statement), \texttt{reduction}, and \texttt{bcast} are
synchronous if \texttt{async} is not specified.  It means that
executions of these constructs guarantee completions of data
synchronizations, that is, global communication constructs read data
that are written by statements that are previously executed, and their
following statements and global communication constructs read data
written by global communication constructs.  Formally, this is
represented by \ref{constraints:synchronous} in
Figure~\ref{fig:constraints}

For example, in the following code, the assignment statement
\texttt{g(:)=h(:)} is guaranteed to be completed before the second
\texttt{gmove} construct is executed.  Therefore, the value of
\texttt{g(i)} must be \texttt{i} when the assignment statement
\texttt{x(:)=g(6:10)} is executed.

Finally, the value of \texttt{x(i)} on \texttt{p(1)} must be
\texttt{i+5}.

\begin{center}
\begin{XFexample}
!$xmp nodes p(2)
!$xmp template t(10)
!$xmp distribute (block) onto p :: t
      integer :: g(10), h(10)
!$xmp align (i) with t(i) :: g, h
      integer x(5)

!$xmp loop on t(i)
      do i=1,10
      h(i)=i
      end do

!$xmp gmove
      g(:)=h(:)
!$xmp gmove
      x(:)=g(6:10)
\end{XFexample}
\end{center}

\subsection{Constraints for Asynchronous Communications}

The constructs \texttt{reflect}, \texttt{gmove} (and its following
assignment statement), \texttt{reduction}, and \texttt{bcast} are
asynchronous if \texttt{async}s are specified.  Completions of data
read and written by these global communication constructs are not
guaranteed until \texttt{wait\_async}s are executed.
Formally, this is represented by
\ref{constraints:asynchronous} in Figure~\ref{fig:constraints}.

For example, in the following code, the assignment statement
\texttt{g(:)=h(:)} may not be completed before the second
\texttt{gmove} construct is executed since the first \texttt{gmove}
construct has \texttt{async} clause.  Therefore, the value of
\texttt{g(i)} is not guaranteed to be \texttt{i+5}.  Of course, the
value of \texttt{x(i)} on \texttt{p(1)} is not guaranteed to be
\texttt{i+5}.
\begin{center}
\begin{XFexample}
!$xmp nodes p(2)
!$xmp template t(10)
!$xmp distribute (block) onto p :: t
      integer :: g(10), h(10)
!$xmp align (i) with t(i) :: g, h
      integer x(5)

!$xmp loop on t(i)
      do i=1,10
      h(i)=i
      end do

!$xmp gmove async(1)
      g(:)=h(:)
!$xmp gmove
      x(:)=g(6:10)
!$xmp wait_async(1)
\end{XFexample}
\end{center}

The \texttt{wait\_async(\textit{async-id})} guarantees a completion of
a global communication construct that has \textit{async-id}.
Therefore, the value of \texttt{x(i)} is not guaranteed to be
\texttt{i+5} in the following program:
\begin{center}
\begin{XFexample}
!$xmp nodes p(2)
!$xmp template t(10)
!$xmp distribute (block) onto p :: t
      integer :: g(10), h(10)
!$xmp align (i) with t(i) :: g, h
      integer x(5)

!$xmp loop on t(i)
      do i=1,10
      h(i)=i
      end do

!$xmp gmove async(1)
      g(:)=h(:)
!$xmp wait_async(1)
!$xmp gmove
      x(:)=g(6:10)
\end{XFexample}
\end{center}

Assignment statements in local view and \texttt{gmove} constructs in
global view may race.  The value of \texttt{x(5)} is not guaranteed to
be \texttt{6}, and may be \texttt{10} in the following program:
\begin{center}
\begin{XFexample}
!$xmp nodes p(2)
!$xmp template t(10)
!$xmp distribute (block) onto p :: t
      integer :: g(10), h(10)
!$xmp align (i) with t(i) :: g, h
      integer x(5)

      integer l(5), m(5)
!$xmp local_alias l => g
!$xmp local_alias m => h

!$xmp loop on t(i)
      do i=1,10
      h(i)=i
      end do

!$xmp gmove async(1)
      g(:)=h(:)
      l(5)=6
!$xmp wait_async(1)
      x(5)=l(5)
\end{XFexample}
\end{center}

By avoiding the race, the value of \texttt{x(5)} is guaranteed to
be \texttt{6} as follows:
\begin{center}
\begin{XFexample}
!$xmp nodes p(2)
!$xmp template t(10)
!$xmp distribute (block) onto p :: t
      integer :: g(10), h(10)
!$xmp align (i) with t(i) :: g, h
      integer x(5)
      integer l(5), m(5)
!$xmp local_alias l => g
!$xmp local_alias m => h

!$xmp loop on t(i)
      do i=1,10
      h(i)=i
      end do

!$xmp gmove async(1)
      g(:)=h(:)
!$xmp wait_async(1)
      l(5)=6
      x(5)=l(5)
\end{XFexample}
\end{center}

Please note that function calls have no synchronization at its
entrance/exit.  In the following program, the value of \texttt{x(5)}
is not guaranteed to be \texttt{6}:
\begin{center}
\begin{XFexample}
!$xmp nodes p(2)
!$xmp template t(10)
!$xmp distribute (block) onto p :: t
      integer :: g(10), h(10)
!$xmp align (i) with t(i) :: g, h
      integer x(5)
      integer l(5), m(5)
!$xmp local_alias l => g
!$xmp local_alias m => h

!$xmp loop on t(i)
      do i=1,10
      h(i)=i
      end do

!$xmp gmove async(1)
      call sub(g,h)
      l(5)=6
!$xmp wait_async(1)
      x(5)=l(5)
\end{XFexample}
\end{center}

