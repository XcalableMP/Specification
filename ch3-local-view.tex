\section{Directives for Local-view Programming}

\subsection{{\tt local\_alias} Directive}

\subsubsection*{Synopsis}

The {\tt \Directive{local\_alias}} directive declares a local data
object as an alias to the local section of a distributed array.

\subsubsection*{Syntax}
\Syntax{local\_alias}

\begin{tabular}{ll}
\verb![F]! & \verb|!$xmp| {\tt local\_alias} {\it local-array-name}
\verb|=>| {\it global-array-name} \\
\verb![C]! & \verb|#pragma xmp| {\tt local\_alias} {\it local-array-name}
\verb|=>| {\it global-array-name} \\
\end{tabular}

\subsubsection*{Description}

This directive declares that the local array specified by
{\it local-array-name} is a ``local alias'' to the global array specified by
{\it global-array-name}.

The shape of a local alias is the same as that of the local section of
the corresponding global array that is owned by each node. Note that the
local part includes the shadow area.

A local alias is defined when the corresponding global array
is defined. If the corresponding global array is statically
allocated, then the local alias is always defined in its scoping unit;
if not, the local alias is not defined until the corresponding global
array is allocated.

\subsubsection*{Restriction}

\begin{itemize}
 \item The array specified by {\it local-array-name} must not be aligned
       by an {\tt align} directive.
 \item The array specified by {\it global-array-name} must be aligned
       by an {\tt align} directive.
 \item The data type and rank of the array specified by {\it
       local-array-name} must be the same as those of the array
       specified by {\it global-array-name}.
 \item \verb![F]! The array specified by {\it local-array-name} must be
       a deferred-shape array, which means that it must be declared with
       a {\it deferred-shape-spec-list} in a type declaration statement
       or a {\tt DIMENSION} statement.
 \item \verb![C]! The array specified by {\it local-array-name} must be
       a pointer.
\end{itemize}

\subsubsection*{Examples}

\begin{description}

\item[Example 1]
\hspace{\hsize}
\begin{Fexample}
!$xmp nodes n(4)
!$xmp template :: t(100)
!$xmp distribute (block) onto n :: t

      real :: a(100)
!$xmp align (i) with t(i) :: a
!$xmp shadow (1) :: a

      real :: b
!$xmp local_alias b => a
\end{Fexample}

The array {\tt a} is distributed by block onto four nodes.
The node {\tt n(2)} has its local section of twenty-five elements ({\tt
a(25:50)}) with shadow areas of size one on the upper and lower 
bounds. The local alias {\tt b} is an array of 27 elements
({\tt b(1:27)}) on {\tt n(2)}. The table below shows the correspondence
of each element of {\tt a} to that of {\tt b}.

\begin{center}
\begin{tabular}{|c|c|}\hline
{\tt a}      & {\tt b} \\ \hline\hline
lower shadow & 1       \\ \hline
26           & 2       \\ \hline
27           & 3       \\ \hline
28           & 4       \\ \hline
\dots        & \dots   \\ \hline
50           & 26      \\ \hline
upper shadow & 27      \\ \hline
\end{tabular}
\end{center}

\item[Example 2]
\hspace{\hsize}
\begin{Fexample}
!$xmp nodes n(4)
!$xmp template :: t(100)
!$xmp distribute (cyclic) onto n :: t

      real :: a(100)
!$xmp align (i) with t(i) :: a

      real :: b(0:)
!$xmp local_alias b => a
\end{Fexample}

An array {\tt a} is distributed cyclically onto four nodes.
Node {\tt n(2)} has its local section of twenty-five elements ({\tt
a(2:100:4)}).
%with shadow areas of size one on the upper and lower 
%bounds.
The lower bound of local alias {\tt b} is declared to
be zero. As a result, {\tt b} is an array of size 25 whose lower
bound is zero ({\tt b(0:24)}) on {\tt n(2)}. The table below shows the
correspondence of each element of a to that of {\tt b}.

\begin{center}
\begin{tabular}{|c|c|}\hline
{\tt a}      & {\tt b} \\ \hline\hline
2            & 0       \\ \hline
6            & 1       \\ \hline
10           & 2       \\ \hline
\dots        & \dots   \\ \hline
98           & 24      \\ \hline
\end{tabular}
\end{center}

\item[Example 3]
\hspace{\hsize}
\begin{Fexample}
!$xmp nodes n(4)
!$xmp template :: t(:)
!$xmp distribute (block) onto n :: t

      real, allocatable :: a(:)
!$xmp align (i) with t(i) :: a

      real :: b(:)[*]
!$xmp local_alias b => a

      Åc

!$xmp template_fix :: t(128)

      allocate (a(128))

      if (me < 4) b(4) = b(4)[me +1]
\end{Fexample}

Since the global array {\tt a} is an allocatable array, its local alias
{\tt b} is not defined when the subroutine starts execution. {\tt b} is
defined when {\tt a} is allocated at the {\tt allocate}
statement. Note that {\tt b} is declared as a coarray and therefore can be
accessed in the same manner as a normal coarray in the last line.

\end{description}


\subsection{{\tt async} Construct}

\subsubsection*{Synopsis}

The {\tt \Directive{async}} construct allows coarrays to be referenced
asynchronously.

\subsubsection*{Syntax}
\Syntax{async}

\begin{tabular}{ll}
\verb![F]! & \verb|!$xmp| {\tt async ( {\it async-id} )} \\
\verb![C]! & \verb|#pragma xmp| {\tt async ( {\it async-id} )} \\
\end{tabular}

\subsubsection*{Description}

An {\tt async} directive and the following statement
including coarray references constitute an {\tt async} construct.

Coarrays appeared in an {\tt async} construct are referenced
asynchronously and therefore statements following it may be executed
before the operation is complete.

\subsubsection*{Restriction}

\begin{itemize}
 \item {\it async-id} must be an integer expression.
\end{itemize}


\subsection{{\tt post} Construct}

\subsubsection*{Synopsis}

The {\tt \Directive{post}} construct, in combination with the {\tt
\Directive{wait}} construct, specifies a point-to-point
synchronization.

\subsubsection*{Syntax}
\Syntax{post}

\begin{tabular}{ll}
\verb![F]! & \verb|!$xmp| {\tt post ( {\it nodes-ref}, {\it tag} )}\\
\verb![C]! & \verb|#pragma xmp| {\tt post ( {\it nodes-ref}, {\it tag} )}\\
\end{tabular}

\subsubsection*{Description}

%This construct prohibits statements that follow the construct from being
%executed until the execution of all statements preceding a matching
%\Directive{post} construct is completed on the node specified by {\it
%node-ref}.

This construct ensures that the execution of statements that precede
it is completed befre statements that follow the matching
\Directive{post} construct statrt to be executed.

A {\tt \Directive{post}} construct issued with the arguments of {\it
nodes-ref} and {\it tag} on a node (called a {\it
posting node}) dynamically matches at most one {\tt \Directive{wait}}
construct issued with the arguments of the posting node (unless omitted)
and the same value as {\it tag} (unless omitted) on the node specified
by {\it nodes-ref}.

\subsubsection*{Restriction}

\begin{itemize}
 \item {\it nodes-ref} must represent one node.
 \item {\it tag} must be an integer expression.
\end{itemize}

\subsubsection*{Example}
\Example{post-wait}

\begin{description}

\item[Example 1]
\hspace{\hsize}

\begin{minipage}{0.45\hsize}
\begin{center}
\begin{Fexample}
      S1
!$xmp post (p(2), 1)
\end{Fexample}
\end{center}
\end{minipage}
%
\begin{minipage}{0.45\hsize}
\begin{center}
\begin{Fexample}
!$xmp wait (p(1), 1)
      S2
\end{Fexample}
\end{center}
\end{minipage}

It is assumed that the code of the left is executed by the node {\tt
p(1)} while that on  the right is executed by node {\tt p(2)}.

The {\tt post} construct on the left matches
the {\tt wait} construct on the right because each {\it nodes-ref}
represents each other  and both {\it tags} have the same value of 1.
%
These constructs ensure that no statement in {\tt S2} is executed by
{\tt p(2)} until the execution of all statements in {\tt S1} is
completed by {\tt p(1)}.

\item[Example 2]
\hspace{\hsize}

\begin{Fexample}
!$xmp wait
      S3
\end{Fexample}

It is assumed that this code is executed by node {\tt p(3)}.

The {\tt post} construct in the code on the left in Example 1 may matches
this {\tt wait} construct because both {\it nodes-ref} and
{\it tag} are omitted in this {\tt wait} construct.

\end{description}


\subsection{{\tt wait} Construct}

\subsubsection*{Synopsis}

The {\tt \Directive{wait}} construct, in combination with the {\tt
\Directive{post}} construct, specifies a point-to-point
synchronization.

\subsubsection*{Syntax}
\Syntax{wait}

\begin{tabular}{ll}
\verb![F]! & \verb|!$xmp| {\tt wait} {\openb}{\tt (} {\it nodes-ref}
 {\openb}, {\it tag}{\closeb} {\tt )}{\closeb}\\
\verb![C]! & \verb|#pragma xmp| {\tt wait} {\openb}{\tt (} {\it nodes-ref} 
 {\openb}, {\it tag}{\closeb} {\tt )}{\closeb}\\
\end{tabular}

\subsubsection*{Description}

This construct prohibits statements that follow this construct from being executed
until the execution of all statements preceding a matching
\Directive{post} construct is completed on the node specified by {\it node-ref}.

A {\tt \Directive{wait}} construct issued with the arguments of {\it
nodes-ref} and {\it tag} on a node (called a {\it waiting node})
dynamically matches a {\tt \Directive{post}} construct issued with the
arguments of the waiting node and the same value as {\it tag} on the
node specified by {\it nodes-ref}.

If {\it tag} is omitted, then the {\tt \Directive{wait}} construct can
match a {\tt \Directive{post}} construct issued with the arguments of
the waiting node and any tag on the node specified by {\it nodes-ref}.
%
If both {\it tag} and {\it nodes-ref} are omitted, then the {\tt
\Directive{wait}} construct can match a {\tt \Directive{post}}
construct issued with the arguments of the waiting node and any tag on
any node.

\subsubsection*{Restriction}

\begin{itemize}
 \item {\it nodes-ref} must represent one node.
 \item {\it tag} must be an integer expression.
\end{itemize}


%\subsection{{\tt critical} Construct}
%
%\subsubsection*{Synopsis}
%
%The {\tt \Directive{critical}} construct restricts execution of the
%associated structured block to a single node at any given time.
%
%\subsubsection*{Syntax}
%\Syntax{critical}
%
%\begin{tabular}{ll}
%\verb![F]! & \verb|!$xmp| {\tt critical} \\
%& {\it block} \\
%& \verb|!$xmp| {\tt end critical} \\
%& \\
%\verb![C]! & \verb|#pragma xmp| {\tt critical} \\
%& {\it block} \\
%\end{tabular}
%
%%\subsubsection*{Restriction}
%
%\subsubsection*{Description}
%
%This construct specifies a {\it critical region}, at the beginning of
%which a node waits until no other node is executing it. 
%
%%\subsubsection*{Examples}
%%\Example{critical}
%%
%%\begin{Fexample}
%%!$xmp critical
%%      ...
%%!$xmp end critical
%%\end{Fexample}



\chapter{Base Language Extensions}

\section{Array section notation in C}

\subsubsection*{Synopsis}

The array section notation is a notation to describe a part of an array, 
which is adapted in Fortran.

\subsubsection*{Syntax}

\begin{tabular}{llll}
\verb![C]! & {\it array-section} & {\bf is} & {\it array-name}{\tt [} {\it triplet} $\vert$ {\it
 int-expr} {\tt ]}...
\end{tabular}

\vspace{0.5cm}

where {\it triplet} is:

\vspace{0.3cm}

\hspace{0.5cm} {\openb}{\it base}{\closeb} {\tt :} {\openb}{\it
length}{\closeb} {\openb}{\tt :} {\it step}{\closeb}

\subsubsection*{Description}

In {\XMP}, the base language C is extended so that a part of an array,
that is, an array section can be put in an {\it array assignment
statement}, which is described in \ref{sec:Array assignment statements
in C}, and some {\XMP} constructs. An array section is built from a
subset of the elements of an array, which is specified by this notation
including at least one {\it triplet}.

When {\it step} is positive, the {\it triplet} specifies a set of
subscripts that is a regularly spaced integer sequence of length {\it
length} beginning with {\it base} and proceeding in increments of {\it
step} up to the largest.
%
When {\it step} is negative, the {\it triplet} specifies a set of
subscripts that is a regularly spaced integer sequence of length {\it
length} beginning with {\it base} and proceeding in increments of {\it
step} down to the smallest.

%{\it lower-bound} and {\it upper-bound} specify an index range of array
%elements. {\it lower-bound} and/or {\it upper-bound} can be omitted, in
%which case they default to the lower and/or the upper bound of the
%array. Therefore, {\tt A[:]} is a section containing the whole of {\tt
%A}.
%%
%If {\it step} is specified, then the elements of an array section are
%every ``step''-th element in the range specified by {\it lower-bound}
%and/or {\it upper-bound}. For example, {\tt B[1:10:3]} is an array 
%section of size 4 containing every third element of {\tt B} with indices
%between 1 and 10 (i.e., indices 1, 4, 7, 10).

When {\it base} is omitted, it is assumed that '0' is specified.
%
When {\it length} is omitted, it is assumed that an integer obtained by
subtracting the value of {\it base} from the size of the dimension of
the array is specified.
%
When {\it step} is omitted, it is assumed that '1' is specified.

An array section forms a virtual array containing the set of elements
from the original array determined by all possible subscript lists
specified by the sequence of {\it triplet}'s or {\it int-expr}'s in square
brackets.

\subsubsection*{Restrictions}

\begin{itemize}
 \item \verb![C]! Each of {\it base}, {\it length} and {\it step} must
       be an {\it integer-expr}.
% \item \verb![C]! When {\it step} is positive, {\it lower-bound} must be
%       greater than or equal to the lower bound and {\it upper-bound}
%       must be smaller than or equal to the upper bound of the dimension
%       of the array specified by {\it array-name}.
% \item \verb![C]! When {\it step} is negative, {\it lower-bound} must be
%       smaller than or equal to the upper bound and {\it upper-bound}
%       must be greater than or equal to the lower bound of the dimension
%       of the array specified by {\it array-name}.
 \item \verb![C]! {\it length} must be greater than zero.
 \item \verb![C]! {\it step} must not be zero.
\end{itemize}

\subsubsection*{Example}

Assuming that an array {\tt A} is declared by the following statement,

\vspace{0.3cm}

\begin{tabular}{ll}
\hspace{0.5cm} & {\tt int A[100];} \\
\end{tabular}

\vspace{0.3cm}

\hspace{-0.55cm}some array sections can be specified as follows:

\vspace{0.3cm}

\begin{tabular}{lll}
\hspace{0.5cm} & {\tt A[10:10]} & array section of 10 elements from {\tt
 A[10]} to {\tt A[19]} \\
 & {\tt A[10:]} & array section of 90 elements from {\tt A[10]} to {\tt
	 A[99]} \\
 & {\tt A[:10]} & array section of 10 elements from {\tt A[0]} to {\tt
	 A[9]} \\
 & {\tt A[10:5:2]} & array section of 5 elements from {\tt A[10]} to
	 {\tt A[18]} by step 2 \\
 & {\tt A[:]} & the whole of {\tt A} \\
\end{tabular}

\section{Array assignment statements in C}
\label{sec:Array assignment statements in C}

\subsubsection*{Synopsis}

An array assignment statement copies a value into each element of
an array section.

%Array-valued expressions can be used by array section in assignments.

\subsubsection*{Syntax}

\begin{tabular}{ll}
\verb![C]! & {\it array-section} {\openb}{\tt :}{\tt [}{\it int-expr}{\tt
 ]}...{\closeb} {\tt =} {\it \{ array-section} $\vert$
 {\it int-expr \}}{\openb}{\tt :}{\tt [}{\it int-expr}{\tt
 ]}...{\closeb}{\tt ;} \\
\end{tabular}

\subsubsection*{Description}

When the rhs is an array section, the value of each element of the rhs
array section is assigned to the corresponding element of the lhs array
section. When the rhs is an integer expression, its value is assigned to
each element of the lhs array section.

The rhs and/or the lhs data can have cosubscripts.

Note that an array assignment is a statement and therefore cannot
referenced as an expression in any other statements.

\subsubsection*{Restrictions}

\begin{itemize}
 \item \verb![C]! When the rhs is an array section, the lhs and the rhs
       must have the same shape, i.e., the same number of dimensions and
       size of each dimension.
\end{itemize}

\subsubsection*{Examples}

The array assignment statement in the fourth line copies the elements
from {\tt B[0]} to {\tt B[4]} into the elements from {\tt A[5]} to {\tt
A[9]}, respectively.

\hspace{\hsize}
\begin{Cexample}
int A[10];
int B[5];
    ...
A[5:9] = B[0:4]; 
\end{Cexample}
