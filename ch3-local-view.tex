\section{Directives for Local-view Programming}

\subsection{{\tt local\_alias} Directive}

\subsubsection*{Synopsis}

The {\tt \Directive{local\_alias}} directive declares a local data
object as an alias to the local section of a distributed array.

\subsubsection*{Syntax}
\Syntax{local\_alias}

\begin{tabular}{ll}
\verb![F]! & \verb|!$xmp| {\tt local\_alias ::} {\it local-array-name}
\verb|=>| {\it global-array-name} \\
\verb![C]! & \verb|#pragma xmp| {\tt local\_alias ::} {\it local-array-name}
\verb|=>| {\it global-array-name} \\
\end{tabular}

\subsubsection*{Description}

This directive declares that the local array specified by
{\it local-array-name} is a ``local alias'' to the global array specified by
{\it global-array-name}.

The shape of a local alias is the same as that of the local section of
the corresponding global array that is owned by each node. Note that the
local part includes the shadow area.

A local alias is defined when the corresponding global array
is defined. If the corresponding global array is statically
allocated, then the local alias is always defined in its scoping unit;
if not, the local alias is not defined until the corresponding global
array is allocated.

\subsubsection*{Restriction}

\begin{itemize}
 \item The array specified by {\it local-array-name} must not be aligned
       by an {\tt align} directive.
 \item The array specified by {\it global-array-name} must be aligned
       by an {\tt align} directive.
 \item The data type and rank of the array specified by {\it
       local-array-name} must be the same as those of the array
       specified by {\it global-array-name}.
 \item \verb![F]! The array specified by {\it local-array-name} must be
       a deferred-shape array, which means that it must be declared with
       a {\it deferred-shape-spec-list} in a type declaration statement
       or a {\tt DIMENSION} statement.
 \item \verb![C]! The array specified by {\it local-array-name} must be
       a pointer.
\end{itemize}

\subsubsection*{Examples}

\begin{description}

\item[Example 1]
\hspace{\hsize}
\begin{Fexample}
!$xmp nodes n(4)
!$xmp template :: t(100)
!$xmp distribute (block) onto n :: t

      real :: a(100)
!$xmp align (i) with t(i) :: a
!$xmp shadow (1) :: a

      real :: b
!$xmp local_alias :: b => a
\end{Fexample}

The array {\tt a} is distributed by block onto four nodes.
The node {\tt n(2)} has its local section of twenty-five elements ({\tt
a(25:50)}) with shadow areas of size one on the upper and lower 
bounds. The local alias {\tt b} is an array of 27 elements
({\tt b(1:27)}) on {\tt n(2)}. The table below shows the correspondence
of each element of {\tt a} to that of {\tt b}.

\begin{center}
\begin{tabular}{|c|c|}\hline
{\tt a}      & {\tt b} \\ \hline\hline
lower shadow & 1       \\ \hline
26           & 2       \\ \hline
27           & 3       \\ \hline
28           & 4       \\ \hline
\dots        & \dots   \\ \hline
50           & 26      \\ \hline
upper shadow & 27      \\ \hline
\end{tabular}
\end{center}

\item[Example 2]
\hspace{\hsize}
\begin{Fexample}
!$xmp nodes n(4)
!$xmp template :: t(100)
!$xmp distribute (cyclic) onto n :: t

      real :: a(100)
!$xmp align (i) with t(i) :: a

      real :: b(0:)
!$xmp local_alias :: b => a
\end{Fexample}

An array {\tt a} is distributed cyclically onto four nodes.
Node {\tt n(2)} has its local section of twenty-five elements ({\tt
a(2:100:4)}).
%with shadow areas of size one on the upper and lower 
%bounds.
The lower bound of local alias {\tt b} is declared to
be zero. As a result, {\tt b} is an array of size 25 whose lower
bound is zero ({\tt b(0:24)}) on {\tt n(2)}. The table below shows the
correspondence of each element of a to that of {\tt b}.

\begin{center}
\begin{tabular}{|c|c|}\hline
{\tt a}      & {\tt b} \\ \hline\hline
2            & 0       \\ \hline
6            & 1       \\ \hline
10           & 2       \\ \hline
\dots        & \dots   \\ \hline
98           & 24      \\ \hline
\end{tabular}
\end{center}

\item[Example 3]
\hspace{\hsize}
\begin{Fexample}
!$xmp nodes n(4)
!$xmp template :: t(:)
!$xmp distribute (block) onto n :: t

      real, allocatable :: a(:)
!$xmp align (i) with t(i) :: a

      real :: b(:)[*]
!$xmp local_alias :: b => a

      Åc

!$xmp template_fix :: t(128)

      allocate (a(128))

      if (me < 4) b(4) = b(4)[me +1]
\end{Fexample}

Since the global array {\tt a} is an allocatable array, its local alias
{\tt b} is not defined when the subroutine starts execution. {\tt b} is
defined when {\tt a} is allocated at the {\tt allocate}
statement. Note that {\tt b} is declared as a coarray and therefore can be
accessed in the same manner as a normal coarray in the last line.

\end{description}


\subsection{{\tt async} Construct}

\subsubsection*{Synopsis}

The {\tt \Directive{async}} construct allows coarrays to be referenced
asynchronously.

\subsubsection*{Syntax}
\Syntax{async}

\begin{tabular}{ll}
\verb![F]! & \verb|!$xmp| {\tt async ( {\it async-id} )} \\
\verb![C]! & \verb|#pragma xmp| {\tt async ( {\it async-id} )} \\
\end{tabular}

\subsubsection*{Description}

An {\tt async} directive and the following statement
including coarray references constitute an {\tt async} construct.

Coarrays appeared in an {\tt async} construct are referenced
asynchronously and therefore statements following it may be executed
before the operation is complete.

\subsubsection*{Restriction}

\begin{itemize}
 \item {\it async-id} must be an integer expression.
\end{itemize}


\subsection{{\tt post} Construct}

\subsubsection*{Synopsis}

The {\tt \Directive{post}} construct, in combination with the {\tt
\Directive{wait}} construct, specifies a point-to-point
synchronization.

\subsubsection*{Syntax}
\Syntax{post}

\begin{tabular}{ll}
\verb![F]! & \verb|!$xmp| {\tt post ( {\it nodes-ref}, {\it tag} )}\\
\verb![C]! & \verb|#pragma xmp| {\tt post ( {\it nodes-ref}, {\it tag} )}\\
\end{tabular}

\subsubsection*{Description}

%This construct prohibits statements that follow the construct from being
%executed until the execution of all statements preceding a matching
%\Directive{post} construct is completed on the node specified by {\it
%node-ref}.

This construct ensures that the execution of statements that precede
it is completed befre statements that follow the matching
\Directive{post} construct statrt to be executed.

A {\tt \Directive{post}} construct issued with the arguments of {\it
nodes-ref} and {\it tag} on a node (called a {\it
posting node}) dynamically matches at most one {\tt \Directive{wait}}
construct issued with the arguments of the posting node (unless omitted)
and the same value as {\it tag} (unless omitted) on the node specified
by {\it nodes-ref}.

\subsubsection*{Restriction}

\begin{itemize}
 \item {\it nodes-ref} must represent one node.
 \item {\it tag} must be an integer expression.
\end{itemize}

\subsubsection*{Example}
\Example{post-wait}

\begin{description}

\item[Example 1]
\hspace{\hsize}

\begin{minipage}{0.45\hsize}
\begin{center}
\begin{Fexample}
      S1
!$xmp post (p(2), 1)
\end{Fexample}
\end{center}
\end{minipage}
%
\begin{minipage}{0.45\hsize}
\begin{center}
\begin{Fexample}
!$xmp wait (p(1), 1)
      S2
\end{Fexample}
\end{center}
\end{minipage}

It is assumed that the code of the left is executed by the node {\tt
p(1)} while that on  the right is executed by node {\tt p(2)}.

The {\tt post} construct on the left matches
the {\tt wait} construct on the right because each {\it nodes-ref}
represents each other  and both {\it tags} have the same value of 1.
%
These constructs ensure that no statement in {\tt S2} is executed by
{\tt p(2)} until the execution of all statements in {\tt S1} is
completed by {\tt p(1)}.

\item[Example 2]
\hspace{\hsize}

\begin{Fexample}
!$xmp wait
      S3
\end{Fexample}

It is assumed that this code is executed by node {\tt p(3)}.

The {\tt post} construct in the code on the left in Example 1 may matches
this {\tt wait} construct because both {\it nodes-ref} and
{\it tag} are omitted in this {\tt wait} construct.

\end{description}


\subsection{{\tt wait} Construct}

\subsubsection*{Synopsis}

The {\tt \Directive{wait}} construct, in combination with the {\tt
\Directive{post}} construct, specifies a point-to-point
synchronization.

\subsubsection*{Syntax}
\Syntax{wait}

\begin{tabular}{ll}
\verb![F]! & \verb|!$xmp| {\tt wait} {\openb}{\tt (} {\it nodes-ref}
 {\openb}, {\it tag}{\closeb} {\tt )}{\closeb}\\
\verb![C]! & \verb|#pragma xmp| {\tt wait} {\openb}{\tt (} {\it nodes-ref} 
 {\openb}, {\it tag}{\closeb} {\tt )}{\closeb}\\
\end{tabular}

\subsubsection*{Description}

This construct prohibits statements that follow this construct from being executed
until the execution of all statements preceding a matching
\Directive{post} construct is completed on the node specified by {\it node-ref}.

A {\tt \Directive{wait}} construct issued with the arguments of {\it
nodes-ref} and {\it tag} on a node (called a {\it waiting node})
dynamically matches a {\tt \Directive{post}} construct issued with the
arguments of the waiting node and the same value as {\it tag} on the
node specified by {\it nodes-ref}.

If {\it tag} is omitted, then the {\tt \Directive{wait}} construct can
match a {\tt \Directive{post}} construct issued with the arguments of
the waiting node and any tag on the node specified by {\it nodes-ref}.
%
If both {\it tag} and {\it nodes-ref} are omitted, then the {\tt
\Directive{wait}} construct can match a {\tt \Directive{post}}
construct issued with the arguments of the waiting node and any tag on
any node.

\subsubsection*{Restriction}

\begin{itemize}
 \item {\it nodes-ref} must represent one node.
 \item {\it tag} must be an integer expression.
\end{itemize}


\subsection{{\tt critical} Construct}

\subsubsection*{Synopsis}

The {\tt \Directive{critical}} construct restricts execution of the
associated structured block to a single node at any given time.

\subsubsection*{Syntax}
\Syntax{critical}

\begin{tabular}{ll}
\verb![F]! & \verb|!$xmp| {\tt critical} \\
& {\it block} \\
& \verb|!$xmp| {\tt end critical} \\
& \\
\verb![C]! & \verb|#pragma xmp| {\tt critical} \\
& {\it block} \\
\end{tabular}

%\subsubsection*{Restriction}

\subsubsection*{Description}

This construct specifies a {\it critical region}, at the beginning of
which a node waits until no other node is executing it. 

%\subsubsection*{Examples}
%\Example{critical}
%
%\begin{Fexample}
%!$xmp critical
%      ...
%!$xmp end critical
%\end{Fexample}
