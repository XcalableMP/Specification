
\section{Directive for local-view programming}

\subsection{{\tt local\_alias} directive}

\subsubsection*{Synopsis}

The {\tt \Directive{local\_alias}} directive declares the local data
object as an alias to the data of a distributed array allocated in each node.

\subsubsection*{Syntax}
\Syntax{local\_alias}

\begin{tabular}{ll}
\verb![F]! & \verb|!$xmp| {\tt local\_alias ::} {\it local-array-name}
\verb|=>| {\it global-array-name} \\
\verb![C]! & \verb|#pragma xmp| {\tt local\_alias ::} {\it local-array-name}
\verb|=>| {\it global-array-name} \\
\end{tabular}

\subsubsection*{Description}

This directive declares that the local array specified by
{\it local-array-name} is a ``local alias'' to the global array specified by
{\it global-array-name}.

The shape of a local alias is the same as that of the local part of the
corresponding global array that is owned by each node. Note that the
local part includes the shadow area.

A local alias is defined when the corresponding global array
is defined. If the corresponding global array is statically
allocated, then the local alias is always defined in its scoping unit;
if not, the local alias is not defined until the corresponding global
array is allocated.

\subsubsection*{Restriction}

\begin{itemize}
 \item The array specified by {\it local-array-name} must not be aligned
       by an {\tt align} directive.
 \item The array specified by {\it global-array-name} must be aligned
       by an {\tt align} directive.
 \item The data type and rank of the array specified by {\it
       local-array-name} must be the same as those of the array
       specified by {\it global-array-name}.
 \item \verb![F]! The array specified by {\it local-array-name} must be
       a deferred-shape array.
 \item \verb![C]! The array specified by {\it local-array-name} must be
       a pointer.
\end{itemize}

\subsubsection*{Examples}

\begin{description}

\item[Example 1]
\hspace{\hsize}
\begin{Fexample}
!$xmp nodes n(4)
!$xmp template :: t (100)
!$xmp distribute (block) onto n :: t

      real :: a (100)
!$xmp align (i) with t(i) :: a
!$xmp shadow (1) :: a

      real :: b
!$xmp local_alias :: b => a
\end{Fexample}

Array {\tt a} is distributed by block onto four nodes.
Node {\tt n(2)} has a local array of twenty-five elements ({\tt
a(25:50)}) with shadow areas of size one on the upper and lower 
bounds. Local alias {\tt b} is an array of 27 elements
({\tt b(1:27)}) on {\tt n(2)}. The table below shows the correspondence
of each element of {\tt a} to that of {\tt b}.

\begin{center}
\begin{tabular}{|c|c|}\hline
{\tt a}      & {\tt b} \\ \hline\hline
lower shadow & 1       \\ \hline
26           & 2       \\ \hline
27           & 3       \\ \hline
28           & 4       \\ \hline
\dots        & \dots   \\ \hline
50           & 26      \\ \hline
upper shadow & 27      \\ \hline
\end{tabular}
\end{center}

\item[Example 2]
\hspace{\hsize}
\begin{Fexample}
!$xmp nodes n(4)
!$xmp template :: t (100)
!$xmp distribute (cyclic) onto n :: t

      real :: a (100)
!$xmp align (i) with t(i) :: a
!$xmp shadow (1) :: a

      real :: b(0:)
!$xmp local_alias :: b => a
\end{Fexample}

An array {\tt a} is distributed cyclically onto four nodes.
Node {\tt n(2)} has a local array of twenty-five elements ({\tt
a(2:100:4)}) with shadow areas of size one on the upper and lower 
bounds. The lower bound of local alias {\tt b} is declared to
be zero. As a result, {\tt b} is an array of 27 elements
({\tt b(0:26)}) on {\tt n(2)}. The table below shows the correspondence
of each element of a to that of {\tt b}.

\begin{center}
\begin{tabular}{|c|c|}\hline
{\tt a}      & {\tt b} \\ \hline\hline
lower shadow & 0       \\ \hline
2            & 1       \\ \hline
6            & 2       \\ \hline
10           & 3       \\ \hline
\dots        & \dots   \\ \hline
98           & 25      \\ \hline
upper shadow & 26      \\ \hline
\end{tabular}
\end{center}

\item[Example 3]
\hspace{\hsize}
\begin{Fexample}
!$xmp nodes n(4)
!$xmp template :: t(:)
!$xmp distribute (block) onto n :: t

      real , allocatable :: a(:)
!$xmp align (i) with t(i) :: a

      real :: b(:)[*]
!$xmp local_alias :: b => a

      Åc

!$xmp template_fix :: t(128)

      allocate (a(128))

      if (me < 4) b(4) = b(4)[me +1]
\end{Fexample}

Since the global array {\tt a} is an allocatable array, its local alias
{\tt b} is not defined when the subroutine starts execution. {\tt b} is
defined when {\tt a} is allocated at the {\tt allocate}
statement. Note that {\tt b} is declared as a coarray and therefore can be
accessed in the same manner as a normal coarray.

\end{description}


\subsection{Post construct}

\subsubsection*{Synopsis}

The {\tt \Directive{post}} construct, in combination with the {\tt
\Directive{wait}} construct, specifies a point-to-point
synchronization.

\subsubsection*{Syntax}
\Syntax{post}

\begin{tabular}{ll}
\verb![F]! & \verb|!$xmp| {\tt post ( {\it nodes-ref}, {\it tag} )}\\
\verb![C]! & \verb|#pragma xmp| {\tt post ( {\it nodes-ref}, {\it tag} )}\\
\end{tabular}

\subsubsection*{Restriction}

\begin{itemize}
 \item {\it nodes-ref} must represent one node.
 \item {\it tag} must be an integer expression.
\end{itemize}

\subsubsection*{Description}

This construct prohibits statements that follow the construct from being executed
until the execution of all statements preceding a matching
\Directive{post} construct is completed on the node specified by {\it node-ref}.

A {\tt \Directive{post}} construct issued with the arguments of {\it
tag} and {\it nodes-ref} on a node (called a {\it
posting node}) dynamically matches at most one {\tt \Directive{wait}}
construct issued with the arguments of the posting node (unless omitted)
and the same value as {\it tag} (unless omitted) on the node specified by {\it nodes-ref}.

\subsubsection*{Example}
\Example{post-wait}

\begin{description}

\item[Example 1]
\hspace{\hsize}

\begin{minipage}{0.45\hsize}
\begin{center}
\begin{Fexample}
      S1
!$xmp post (p(2), 1)
\end{Fexample}
\end{center}
\end{minipage}
%
\begin{minipage}{0.45\hsize}
\begin{center}
\begin{Fexample}
!$xmp wait (p(1), 1)
      S2
\end{Fexample}
\end{center}
\end{minipage}

It is assumed that the code of the left is executed by node {\tt p(1)} while that on 
the right is executed by node {\tt p(2)}.

The {\tt post} construct on the left match 
the {\tt wait} construct on the right because each {\it nodes-ref}
represents each other  and both {\it tags} have the same value of 1.
%
These constructs ensure that no statement in {\tt S2} is executed by
{\tt p(2)} until the execution of all statements in {\tt S1} is
completed by {\tt p(1)}.

\item[Example 2]
\hspace{\hsize}

\begin{Fexample}
!$xmp wait
      S3
\end{Fexample}

It is assumed that this code is executed by node {\tt p(3)}.

The {\tt post} construct in the code on the left in Example 1 may match
this {\tt wait} construct because both {\it nodes-ref} and
	   {\it tag} are omitted.

\end{description}


\subsection{Wait construct}

\subsubsection*{Synopsis}

The {\tt \Directive{wait}} construct, in combination with the {\tt
\Directive{post}} construct, specifies a point-to-point
synchronization.

\subsubsection*{Syntax}
\Syntax{wait}

\begin{tabular}{ll}
\verb![F]! & \verb|!$xmp| {\tt wait} [ {\tt (} {\it nodes-ref} [ , {\it
 tag} ] {\tt )} ]\\
\verb![C]! & \verb|#pragma xmp| {\tt wait} [ {\tt (} {\it nodes-ref} 
 [ , {\it tag} ] {\tt )} ]\\
\end{tabular}

\subsubsection*{Restriction}

\begin{itemize}
 \item {\it nodes-ref} must represent one node.
 \item {\it tag} must be an integer expression.
\end{itemize}

\subsubsection*{Description}

This construct prohibits statements that follow this construct from being executed
until the execution of all statements preceding a matching
\Directive{post} construct is completed on the node specified by {\it node-ref}.

A {\tt \Directive{wait}} construct issued with the arguments of {\it
tag} and {\it nodes-ref} on a node (referred to as a {\it
waiting node}) dynamically matches at most one {\tt \Directive{post}}
construct issued with the arguments of the waiting node and the same
value as {\it tag} on the node specified by {\it nodes-ref}.

If {\it tag} is omitted, then the {\tt \Directive{wait}} construct can match at
most one {\tt \Directive{post}} construct issued with the arguments of
the waiting node and any tag on the node specified by {\it nodes-ref}.
%
If both {\it tag} and {\it nodes-ref} are omitted, then the {\tt
\Directive{wait}} construct can match at most one {\tt \Directive{post}}
construct issued with the arguments of the waiting node and any tag on any node.


\subsection{Critical construct}

\subsubsection*{Synopsis}

The {\tt \Directive{critical}} construct restricts execution of the
associated structured block to a single node at any given time.

\subsubsection*{Syntax}
\Syntax{critical}

\begin{tabular}{ll}
\verb![F]! & \verb|!$xmp| {\tt critical} \\
& {\it block} \\
& \verb|!$xmp| {\tt end critical} \\
& \\
\verb![C]! & \verb|#pragma xmp| {\tt critical} \\
& {\it block} \\
\end{tabular}

%\subsubsection*{Restriction}

\subsubsection*{Description}

This construct specifies a {\it critical region}, at the beginning of
which a node waits until no other node is executing it. 

%\subsubsection*{Examples}
%\Example{critical}
%
%\begin{Fexample}
%!$xmp critical
%      ...
%!$xmp end critical
%\end{Fexample}
