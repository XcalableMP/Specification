\section{Directives for the Local-view Programming}

\subsection{{\tt [F] local\_alias} Directive}

\subsubsection*{Synopsis}

In {\XMPF}, the {\tt \Directive{local\_alias}} directive declares a
local data object as an alias to the local section of a mapped
array.

\subsubsection*{Syntax}
\Syntax{local\_alias}

\begin{tabular}{ll}
\verb![F]! & \verb|!$xmp| {\tt local\_alias} {\it local-array-name}
\verb|=>| {\it global-array-name} \\
%\verb![C]! & \verb|#pragma xmp| {\tt local\_alias} {\it local-array-name}
%\verb|=>| {\it global-array-name} \\
\end{tabular}

\subsubsection*{Description}

%This directive declares that a local array specified by
%{\it local-array-name} is a ``\Term{local alias}'' to the global array
%specified by {\it global-array-name}.
The LOCAL\_ALIAS directive associates a non-mapped array with
an explicitly mapped array.
The non-mapped array is an associating local array and
the explicitly mapped array is an associated global array.
The shape of the associating local array is the same as
that of the node-local portion of the associated global array
including shadow area.
Each element of the associating local array shares the 
same storage unit in array element order with that of the node-local portion 
of the associated global array.
An associating local array and the corresponding global array always have
the same allocation status.
An associating local array always has the dynamic type
and type parameter values of the corresponding 
associated global array.

%The shape of a local alias is the same as that of the local section of
%the global array that is owned by each node.
%Note that the local part includes the shadow area.
%An associating local array is defined when the corresponding 
%associated global array is defined. 


An associating local array may be a coarray.
An associating local array that is a coarray is
an on-node coarray of the node array onto which the corresponding
associated global array is mapped.
Every specification and restriction on coarrays is also applied to an associating local
array that is a coarray except that
an associating local array is always declared with
{\it deferred-shape-spec-list} of the same rank as the associated global array.
In particular, a processor shall ensure that an associating local array 
that is a coarray has
the same bounds on all the images corresponding to the node array
onto which the corresponding associated global array is mapped.
The mapping attributes allowed for an associated global array are
processor-dependent.

Note that the base language {\Fort} is extended so that a deferred-shape
array that is not either an allocatable array or an array pointer is
declared if it is specified as a 
{\it local-array-name} in the {\tt local\_alias} directive.

In {\XMPC}, the {\tt address-of} operator applied to global data
substitutes for the {\tt local\_alias} directive (see \ref{sec:pointer
to global data}).


\subsubsection*{Restrictions}

\begin{itemize}
 \item A {\it global-array-name} shall be a name of an explicitly mapped
       array declared in the same scoping unit. 

 \item A {\it local-array-name} shall be a name of a non-mapped array
       declared in the same scoping unit. 

 \item A {\it local-array-name} shall not be a dummy argument.

 \item An associating local array shall have the declared type and type parameters of
       the corresponding associated global array.

 \item An associating local array shall be declared with
       {\it deferred-shape-spec-list} of the
       same rank as the corresponding associated global array.

 \item A {\it local-array-name} shall appear in a COARRAY directive in the
       same scoping unit and the {\it node-name} in the COARRAY directive
       shall be the name of the node array onto which the
       associated global array is mapped.

 \item 
If an associated global array is a dummy argument and corresponds to
an associating local array that is a coarray, 
the corresponding effective argument shall be
an explicitly mapped array or a subobject of 
an explicitly mapped array whose name appears
in a LOCAL\_ALIAS directive %as a {\it global-array-name} 
and the corresponding associating local array shall be a coarray.

 \item If a dummy argument is a coarray 
       and the corresponding ultimate argument is a coarray appearing in
       a LOCAL\_ALIAS directive, % as a {\it local-array-name},
       the dummy argument shall appear in a COARRAY directive
       with a node array corresponding to
       a subset of the set of images that corresponds to the node array
       onto which the ultimate argument is mapped.
%
% \item The array specified by {\it local-array-name} must not be aligned
%       by an {\tt align} directive.
% \item The array specified by {\it global-array-name} must be aligned
%       by an {\tt align} directive.
% \item The data type and rank of the array specified by {\it
%       local-array-name} must be the same as those of the array
%       specified by {\it global-array-name}.
% \item The array specified by {\it local-array-name} must be a
%       deferred-shape array, which means that it must be declared with 
%       a {\it deferred-shape-spec-list} in a type declaration statement
%       or a {\tt DIMENSION} statement.
% \item \verb![C]! The array specified by {\it local-array-name} must be
%       a pointer.
\end{itemize}

\subsubsection*{Examples}
\Example{local\_alias}

\begin{description}

\item[Example 1]
\hspace{\hsize}

\begin{XFexample}
!$xmp nodes n(4)
!$xmp template :: t(100)
!$xmp distribute (block) onto n :: t

      real :: a(100)
!$xmp align (i) with t(i) :: a
!$xmp shadow (1) :: a

      real :: b(:)
!$xmp local_alias b => a
\end{XFexample}

The array {\tt a} is distributed by block onto four nodes.
The node {\tt n(2)} has its local section of twenty-five elements ({\tt
a(25:50)}) with shadow areas of size one on both of the upper and lower 
bounds. The local alias {\tt b} is an array of 27 elements
({\tt b(1:27)}) on {\tt n(2)}. The table below shows the correspondence
of each element of {\tt a} to that of {\tt b} on {\tt n(2)}.

\begin{center}
\begin{tabular}{|c|c|}\hline
{\tt a}      & {\tt b} \\ \hline\hline
lower shadow & 1       \\ \hline
26           & 2       \\ \hline
27           & 3       \\ \hline
28           & 4       \\ \hline
\dots        & \dots   \\ \hline
50           & 26      \\ \hline
upper shadow & 27      \\ \hline
\end{tabular}
\end{center}

\item[Example 2]
\hspace{\hsize}
\begin{XFexample}
!$xmp nodes n(4)
!$xmp template :: t(100)
!$xmp distribute (cyclic) onto n :: t

      real :: a(100)
!$xmp align (i) with t(i) :: a

      real :: b(0:)
!$xmp local_alias b => a
\end{XFexample}

An array {\tt a} is distributed cyclically onto four nodes.
Node {\tt n(2)} has its local section of twenty-five elements ({\tt
a(2:100:4)}).
%with shadow areas of size one on the upper and lower 
%bounds.
The lower bound of local alias {\tt b} is declared to
be zero. As a result, {\tt b} is an array of size 25 whose lower
bound is zero ({\tt b(0:24)}) on {\tt n(2)}. The table below shows the
correspondence of each element of a to that of {\tt b} on {\tt n(2)}.

\begin{center}
\begin{tabular}{|c|c|}\hline
{\tt a}      & {\tt b} \\ \hline\hline
2            & 0       \\ \hline
6            & 1       \\ \hline
10           & 2       \\ \hline
\dots        & \dots   \\ \hline
98           & 24      \\ \hline
\end{tabular}
\end{center}

\item[Example 3]
\hspace{\hsize}
\Example{template\_fix}
\begin{XFexample}
!$xmp nodes n(4)
!$xmp template :: t(:)
!$xmp distribute (block) onto n :: t

      real, allocatable :: a(:)
!$xmp align (i) with t(i) :: a

      real :: b(:)[*]
!$xmp local_alias b => a

      Åc

!$xmp template_fix :: t(128)

      allocate (a(128))

      if (me < 4) b(4) = b(4)[me +1]
\end{XFexample}

Since the global array {\tt a} is an allocatable array, its local alias
{\tt b} is not defined when the subroutine starts execution. {\tt b} is
defined when {\tt a} is allocated at the {\tt allocate}
statement. Note that {\tt b} is declared as a coarray and therefore can be
accessed in the same manner as a normal coarray.

\end{description}


%\subsection{{\tt async} Construct}
%
%\subsubsection*{Synopsis}
%
%The {\tt \Directive{async}} construct allows coarrays to be referenced
%asynchronously.
%
%\subsubsection*{Syntax}
%\Syntax{async}
%
%\begin{tabular}{ll}
%\verb![F]! & \verb|!$xmp| {\tt async ( {\it async-id} )} \\
%\verb![C]! & \verb|#pragma xmp| {\tt async ( {\it async-id} )} \\
%\end{tabular}
%
%\subsubsection*{Description}
%
%An {\tt async} directive and the following statement
%including coarray references constitute an {\tt async} construct.
%
%Coarrays appeared in an {\tt async} construct are referenced
%asynchronously and therefore statements following it may be executed
%before the operation is complete.
%
%\subsubsection*{Restriction}
%
%\begin{itemize}
% \item {\it async-id} must be an integer expression.
%\end{itemize}


\subsection{{\tt post} Construct}

\subsubsection*{Synopsis}

The {\tt \Directive{post}} construct, in combination with the {\tt
\Directive{wait}} construct, specifies a point-to-point
synchronization.

\subsubsection*{Syntax}
\Syntax{post}

\begin{tabular}{ll}
\verb![F]! & \verb|!$xmp| {\tt post ( {\it nodes-ref}, {\it tag} )}\\
\verb![C]! & \verb|#pragma xmp| {\tt post ( {\it nodes-ref}, {\it tag} )}\\
\end{tabular}

\subsubsection*{Description}

%This construct prohibits statements that follow the construct from being
%executed until the execution of all statements preceding a matching
%\Directive{post} construct is completed on the node specified by {\it
%node-ref}.

This construct ensures that the execution of statements that precede
it is completed before statements that follow the matching
\Directive{wait} construct start to be executed.

A {\tt \Directive{post}} construct issued with the arguments of {\it
nodes-ref} and {\it tag} on a node (called a {\it \Term{posting node}})
dynamically matches at most one {\tt \Directive{wait}} construct issued
with the arguments of the posting node (unless omitted) 
and the same value as {\it tag} (unless omitted) by the node specified
by {\it nodes-ref}.

\subsubsection*{Restriction}

\begin{itemize}
 \item {\it nodes-ref} must represent one node.
 \item {\it tag} must be an expression of type default integer, in
       {\XMPF}, or type {\tt int}, in {\XMPC}.
\end{itemize}

\subsubsection*{Example}
\Example{post}
\Example{wait}

\begin{description}

\item[Example 1]
\hspace{\hsize}

\begin{minipage}{0.45\hsize}
\begin{center}
\begin{XFexample}
      S1
!$xmp post (p(2), 1)
\end{XFexample}
\end{center}
\end{minipage}
%
\begin{minipage}{0.45\hsize}
\begin{center}
\begin{XFexample}
!$xmp wait (p(1), 1)
      S2
\end{XFexample}
\end{center}
\end{minipage}

It is assumed that the code of the left is executed by the node {\tt
p(1)} while that on  the right is executed by node {\tt p(2)}.

The {\tt post} construct on the left matches the {\tt wait} construct on
the right because their {\it nodes-ref}'s represent each other and both
{\it tags}'s have the same value of 1.
%
These constructs ensure that no statement in {\tt S2} is executed by
{\tt p(2)} until the execution of all statements in {\tt S1} is
completed by {\tt p(1)}.

\item[Example 2]
\hspace{\hsize}

\begin{XFexample}
!$xmp wait
      S3
\end{XFexample}

It is assumed that this code is executed by node {\tt p(2)}.

The {\tt post} construct in the left code in Example 1 may matches
this {\tt wait} construct because both {\it nodes-ref} and
{\it tag} are omitted in this {\tt wait} construct.

\end{description}


\subsection{{\tt wait} Construct}

\subsubsection*{Synopsis}

The {\tt \Directive{wait}} construct, in combination with the {\tt
\Directive{post}} construct, specifies a point-to-point
synchronization.

\subsubsection*{Syntax}
\Syntax{wait}

\begin{tabular}{ll}
\verb![F]! & \verb|!$xmp| {\tt wait} {\openb}{\tt (} {\it nodes-ref}
 {\openb}, {\it tag}{\closeb} {\tt )}{\closeb}\\
\verb![C]! & \verb|#pragma xmp| {\tt wait} {\openb}{\tt (} {\it nodes-ref} 
 {\openb}, {\it tag}{\closeb} {\tt )}{\closeb}\\
\end{tabular}

\subsubsection*{Description}

This construct prohibits statements that follow this construct from
being executed until the execution of all statements preceding a
matching \Directive{post} construct is completed on the node specified
by {\it node-ref}.

A {\tt \Directive{wait}} construct issued with the arguments of {\it nodes-ref} and {\it tag} 
on a node (called a {\it \Term{waiting node}})
dynamically matches a {\tt \Directive{post}} construct issued with the
arguments of the waiting node and the same value as {\it tag} by the
node specified by {\it nodes-ref}.

If {\it tag} is omitted, then the {\tt \Directive{wait}} construct can
match a {\tt \Directive{post}} construct issued with the arguments of
the waiting node and any tag by the node specified by {\it nodes-ref}.
%
If both {\it tag} and {\it nodes-ref} are omitted, then the {\tt
\Directive{wait}} construct can match a {\tt \Directive{post}}
construct issued with the arguments of the waiting node and any tag on
any node.

\subsubsection*{Restriction}

\begin{itemize}
 \item {\it nodes-ref} must represent one node.
 \item {\it tag} must be an expression of type default integer, in
       {\XMPF}, or type {\tt int}, in {\XMPC}.
\end{itemize}

\subsection{{\tt [C]} {\tt lock}/{\tt unlock} Construct}
\subsubsection*{Synopsis}
The {\tt \Directive{lock}}/{\tt \Directive{unlock}} constructs are equivalent to the 
{\tt lock}/{\tt unlock} statements in Fortran 2008.

\subsubsection*{Syntax}
\Syntax{lock}
\begin{tabular}{ll}
\verb![C]! & \verb!#!include \verb!<!xmp.h\verb!>! \\
\verb![C]! & {\tt xmp\_lock\_t} {\it lock-object}
{\openb}{\tt ,} {\it lock-object} {\closeb}{\tt ...} \\
\verb![C]! & \verb|#pragma xmp| {\tt lock} {\tt (}{\it lock-object}{\tt )}
{\openb} {\tt acquired\_lock} {\tt (}{\it success}{\tt )} {\closeb}
{\openb} {\tt stat} {\tt (}{\it status}{\tt )} {\closeb}\\
\verb![C]! & \verb|#pragma xmp| {\tt unlock} {\tt (}{\it lock-object}{\tt )}
{\openb} {\tt stat} {\tt (}{\it status}{\tt )} {\closeb}
\end{tabular}

\vspace{5mm}
Please note the following points:
\begin{itemize} \vspace{-2mm}
 \item The type {\tt xmp\_lock\_t} is defined in ``xmp.h''. \vspace{-3mm}
 \item The variable {\it lock-object} is a coarray. \vspace{-3mm}
 \item The variable {\it success} is an expression of type {\tt int}. \vspace{-3mm}
 \item The variable {\it status} is an expression of type {\tt int}. 
\end{itemize}

\subsubsection*{Description}
%The {\tt \Directive{lock}} construct, in combination with the {\tt \Directive{unlock}} construct,
%is used to create a critical section on a target node.
%The critical section is a range of a code which can be executed by only a node creates the critical section.
%The critical section is started by the {\tt \Directive{lock}} construct,
%and the critical section is ended by the {\tt \Directive{unlock}} construct.
The {\tt \Directive{lock}} construct, in combination with the {\tt \Directive{unlock}} construct,
is used to control a {\it lock-object}.
The {\it lock-object} must be defined as a coarray to control it on a target node.
The {\it lock-object} must be an expression of type {\tt xmp\_lock\_t} 
which is an opaque object defined in ``xmp.h''.

If the {\tt acquired\_lock} clause is not used in the {\tt \Directive{lock}} construct and 
the {\it lock-object} is locked,
a node stops at the {\tt \Directive{lock}} construct until the {\it lock-object} is unlocked by a different node.
If the {\tt acquired\_lock} clause is used in the {\tt \Directive{lock}} construct and 
the {\it lock-object} is locked by a different node,
a node does not stop at the {\tt \Directive{lock}} construct and the variable {\it success} is defined with the value false
and {\tt \Directive{lock}} construct leaves the {\it lock-object} unchanged.
If the {\tt acquired\_lock} clause is used in the {\tt \Directive{lock}} construct and the {\it lock-object} is unlocked,
the variable {\it success} is defined with the value true.

The {\it status} is defined with one of the follow symbolic constants 
when executing {\tt \Directive{lock}}/{\tt \Directive{unlock}} construct.

\begin{itemize}
\item {\tt XMP\_STAT\_SUCCESS} \vspace{-2mm}
\item {\tt XMP\_STAT\_LOCKED} \vspace{-2mm}
\item {\tt XMP\_STAT\_UNLOCKED} \vspace{-2mm}
\item {\tt XMP\_STAT\_LOCKED\_OTHER\_IMAGE}
\end{itemize}

If an execution of {\tt \Directive{lock}}/{\tt \Directive{unlock}} construct is success,
the {\it status} is defined with {\tt XMP\_STAT\_SUCCESS}.
A condition where the {\it status} is defined with 
{\tt XMP\_STAT\_LOCKED}, {\tt XMP\_STAT\_UNLOCKED}, or {\tt XMP\_STAT\_}
{\tt LOCKED\_OTHER\_IMAGE} 
is the same as that where the {\it status} is defined with
{\tt STAT\_LOCKED}, {\tt STAT\_UNLOCKED}, or {\tt STAT\_LOCKED\_OTHER\_IMAGE} in Fortran 2008.
These symbolic constants are defined in ``xmp.h''.
If any other error condition occurs during execution of these constructs,
the {\it status} is defined with a value which is different from the
value of {\tt XMP\_STAT\_SUCCESS}, {\tt XMP\_STAT\_LOCKED}, 
{\tt XMP\_STAT\_UNLOCKED}, and {\tt XMP\_STAT\_LOCKED\_OTHER\_IMAGE}.


\subsubsection*{Example}
\begin{XCexample}
#include "xmp.h"

xmp_lock_t lock_obj:[*];
int A:[*], B;
#pragma xmp nodes p(2)
...
#pragma xmp lock(lock_obj:[2])
  if(xmp_node_num() == 1){
    A:[2] = B;
  }
#pragma xmp unlock(lock_obj:[2])
\end{XCexample}

%\subsection{{\tt critical} Construct}
%
%\subsubsection*{Synopsis}
%
%The {\tt \Directive{critical}} construct restricts execution of the
%associated structured block to a single node at any given time.
%
%\subsubsection*{Syntax}
%\Syntax{critical}
%
%\begin{tabular}{ll}
%\verb![F]! & \verb|!$xmp| {\tt critical} \\
%& {\it block} \\
%& \verb|!$xmp| {\tt end critical} \\
%& \\
%\verb![C]! & \verb|#pragma xmp| {\tt critical} \\
%& {\it block} \\
%\end{tabular}
%
%%\subsubsection*{Restriction}
%
%\subsubsection*{Description}
%
%This construct specifies a {\it critical region}, at the beginning of
%which a node waits until no other node is executing it. 
%
%%\subsubsection*{Examples}
%%\Example{critical}
%%
%%\begin{XFexample}
%%!$xmp critical
%%      ...
%%!$xmp end critical
%%\end{XFexample}

\cleardoublepage

\chapter{Base Language Extensions in {\XMPC}}

%This chapter describes base language extensions in {\XMPC} that is other
%than coarrays described in Chapter \ref{chap:Support for the Local-view
%Programming}.

This chapter describes base language extensions in {\XMPC} that is not
described in any other chapters.

\section{Array Section Notation}

\subsubsection*{Synopsis}

The array section notation is a notation to describe a part of an array, 
which is adapted in Fortran.

\subsubsection*{Syntax}
\index{array section in XMP/C}
\index{Syntax!array section in XMP/C}

\begin{tabular}{llll}
\verb![C]! & {\it array-section} & {\bf is} & {\it array-name}{\tt [} \{
 {\it triplet} $\vert$ {\it int-expr} \} {\tt ]}...
\end{tabular}

\vspace{0.5cm}

where {\it triplet} must be one of:

\vspace{0.3cm}

\begin{tabular}{ll}
 \hspace{0.5cm} & {\it base} {\tt :} {\it length} {\tt :} {\it step} \\
 \hspace{0.5cm} & {\it base} {\tt :} {\it length}\\
 \hspace{0.5cm} & {\tt :} \\
\end{tabular}

\subsubsection*{Description}

In {\XMPC}, the base language C is extended so that a part of an array,
that is, an array section can be put in an {\it array assignment
statement}, which is described in \ref{sec:Array assignment statements
in C}, and some {\XMP} constructs. An array section is built from a
subset of the elements of an array, which is specified by this notation
including at least one {\it triplet}.

When {\it step} is positive, the {\it triplet} specifies a set of
subscripts that is a regularly spaced integer sequence of length {\it
length} beginning with {\it base} and proceeding in increments of {\it
step} up to the largest.
%
When {\it step} is negative, the {\it triplet} specifies a set of
subscripts that is a regularly spaced integer sequence of length {\it
length} beginning with {\it base} and proceeding in increments of {\it
step} down to the smallest.

%{\it lower-bound} and {\it upper-bound} specify an index range of array
%elements. {\it lower-bound} and/or {\it upper-bound} can be omitted, in
%which case they default to the lower and/or the upper bound of the
%array. Therefore, {\tt A[:]} is a section containing the whole of {\tt
%A}.
%%
%If {\it step} is specified, then the elements of an array section are
%every ``step''-th element in the range specified by {\it lower-bound}
%and/or {\it upper-bound}. For example, {\tt B[1:10:3]} is an array 
%section of size 4 containing every third element of {\tt B} with indices
%between 1 and 10 (i.e., indices 1, 4, 7, 10).

When {\it step} is omitted, it is assumed to be ``1''.
%
When all of {\it base}, {\it length} and {\it step} is omitted, it is
assumed that {\it base} is ``0'', {\it length} is the size of the
dimension of the array, and {\it step} is ``1''.

An array section can be considered as a virtual array containing the set
of elements from the original array determined by all possible subscript
lists specified by the sequence of {\it triplet}'s or {\it int-expr}'s
in square brackets.

\subsubsection*{Restrictions}

\begin{itemize}
 \item \verb![C]! Each of {\it base}, {\it length} and {\it step} must
       be an integer expression.
% \item \verb![C]! When {\it step} is positive, {\it lower-bound} must be
%       greater than or equal to the lower bound and {\it upper-bound}
%       must be smaller than or equal to the upper bound of the dimension
%       of the array specified by {\it array-name}.
% \item \verb![C]! When {\it step} is negative, {\it lower-bound} must be
%       smaller than or equal to the upper bound and {\it upper-bound}
%       must be greater than or equal to the lower bound of the dimension
%       of the array specified by {\it array-name}.
 \item \verb![C]! {\it length} must be greater than zero.
 \item \verb![C]! {\it step} must not be zero.
\end{itemize}

\subsubsection*{Example}
\index{Example!array section in XMP/C}

Assuming that an array {\tt A} is declared by the following statement,

\vspace{0.3cm}

\begin{tabular}{ll}
\hspace{0.5cm} & {\tt int A[100];} \\
\end{tabular}

\vspace{0.3cm}

\hspace{-0.55cm}some array sections can be specified as follows:

\vspace{0.3cm}

\begin{tabular}{lll}
\hspace{0.5cm} & {\tt A[10:10]} & array section of 10 elements from {\tt
 A[10]} to {\tt A[19]} \\
 & {\tt A[10:]} & array section of 90 elements from {\tt A[10]} to {\tt
	 A[99]} \\
 & {\tt A[:10]} & array section of 10 elements from {\tt A[0]} to {\tt
	 A[9]} \\
 & {\tt A[10:5:2]} & array section of 5 elements from {\tt A[10]} to
	 {\tt A[18]} by step 2 \\
 & {\tt A[:]} & the whole of {\tt A} \\
\end{tabular}

\section{Array Assignment Statement}
\label{sec:Array assignment statements in C}

\subsubsection*{Synopsis}

An array assignment statement copies a value into each element of
an array section.

%Array-valued expressions can be used by array section in assignments.

\subsubsection*{Syntax}
\index{array assignment in XMP/C}
\index{Syntax!array assignment in XMP/C}

\begin{tabular}{ll}
\verb![C]! & {\it array-section} {\openb}{\tt :}{\tt [}{\it int-expr}{\tt
 ]}...{\closeb} {\tt =} \{ {\it variable} {\openb}{\tt :}{\tt [}{\it
 int-expr}{\tt ]}...{\closeb} $\vert$ {\it int-expr \}}{\tt ;} \\
\end{tabular}

\subsubsection*{Description}

When the rhs is an array section, the value of each element of it is
assigned to the corresponding element of the lhs array 
section. When the rhs is an integer expression, its value is assigned to
each element of the lhs array section.

The rhs and/or the lhs data can have cosubscripts.

Note that an array assignment is a statement and therefore cannot
appear as an expression in any other statements.

\subsubsection*{Restrictions}

\begin{itemize}
 \item \verb![C]! When the rhs is an array section, the lhs and the rhs
       must have the same shape, i.e., the same number of dimensions and
       size of each dimension.
 \item \verb![C]! If {\it array-section} on the lhs is followed by
       ``{\tt :}{\tt [}{\it int-expr}{\tt ]}...'', it must be a coarray.
 \item \verb![C]! If {\it variable} on the rhs is followed by
       ``{\tt :}{\tt [}{\it int-expr}{\tt ]}...'', it must be a coarray.
\end{itemize}

\subsubsection*{Examples}
\index{Example!array assignment in XMP/C}

An array assignment statement in the fourth line copies the elements
{\tt B[0]} through {\tt B[4]} into the elements {\tt A[5]} through {\tt
A[9]}.

\hspace{\hsize}
\begin{XCexample}
int A[10];
int B[5];
    ...
A[5:5] = B[0:5]; 
\end{XCexample}


\section{Pointer to Global Data}
\label{sec:pointer to global data}

\subsection{Name of Global Array}

The name of a global array is considered to represent an abstract entity
in the {\XMP} language. It is not interpreted as the pointer to the array,
while the name of a local array is.

However, the name of a global array appeared in an expression is
evaluated to the pointer to the base address of its local section on
each node. The pointer, as a normal (local) pointer, can be operated on
each node.

\subsection{The Address-of Operator}
\index{address-of operator}

The result of the address-of operator (``{\tt \&}'') applied to an
element of a global array is the pointer to the corresponding element of
its local section. Note that the value of the result pointer is defined
only on the node that owns the element. The pointer, as a normal (local)
pointer, can be operated on the node.

As a result, for a global array {\tt a}, {\tt a} and {\tt \&a[0]} are
not always evaluated to the same value.

\section{Dynamic Allocation of Global Data}
\label{sec:Dynamic Allocation of Global Data in C}

In {\XMPC}, it is possible to allocate global arrays at runtime only
when they are one-dimensional.
%
Such allocation is done through the following steps.
%
\begin{enumerate}
 \item Declare a pointer to an object of the type of the global array to
       be allocated.
 \item Align the pointer with a template as if it were a one-dimensional
       array.
 \item Allocate a storage of the global size with the {\tt xmp\_malloc}
       library procedure and assign the result value to the
       pointer on each node.
\end{enumerate}
%
The specification of {\tt xmp\_malloc} is described in section
\ref{subsec: xmp_malloc}.

\subsection*{Example}

A pointer {\tt pa} to a float is declared in line 5 and aligned with a
template {\tt t} in line 6. {\tt t} is initially undefined and fixed by
the {\tt template\_fix} directive in line 10. The storage for a global
data, that is, each of its local section is allocated with {\tt
xmp\_malloc} and {\tt pa} is set to point it on each node in line 12. For
details of the operator {\tt xmp\_desc\_of}, refer to the next section.

\index{Example!dynamic allocation in XMP/C}
\Intrinsic{xmp\_malloc}
\Example{template\_fix}
\Example{xmp\_malloc}
\Example{xmp\_desc\_of}
\begin{XCexample}
#pragma nodes p(NP)
#pragma xmp template t(:)
#pragma xmp distribute t(block) onto p

float *pa;
#pragma xmp align pa[i] with t(i)

...

#pragma xmp template_fix t(N)

pa = (float *)xmp_malloc(xmp_desc_of(pa), N);
\end{XCexample}

\section{The Descriptor-of Operator}
\label{sec:Descriptor of Global Data in C}
\index{xmp\_desc\_of@{\tt xmp\_desc\_of}}

%When distribution of Global data is defined, query function which have 
%operator {\tt xmp\_desc\_of} as argument can return some descriptor
%information. 

The \Term{descriptor-of operator} (``{\tt xmp\_desc\_of}'') is
introduced as a built-in operator in {\XMPC}.

The result of the descriptor-of operator applied to {\XMP} entities such
as node arrays, templates and global arrays is their {\it
\Term{descriptor}}, which can be used, for example, as an argument of
some inquiry procedures. The type of the result, {\tt xmp\_desc\_t}, is
implementation-dependent, and defined in the {\tt xmp.h} header file in
{\XMPC}.

For the {\tt xmp\_desc\_of} intrinsic function in {\XMPF}, refer to
section \ref{subsec: xmp_desc_of}.

%For details of the {\tt xmp\_desc\_of} library procedure, refer to
%Chapter \ref{chap:Intrinsic and library procedures}.
