\section{Work mapping construct}

\subsection{{\tt task} construct}

\subsubsection*{Synopsis}

The {\tt \Directive{task}} construct defines a task that is executed by
a specified node set.

\subsubsection*{Syntax}
\Syntax{task}

\begin{tabular}{ll}
\verb![F]! & \verb|!$xmp| {\tt task on} \{{\it nodes-ref} $\vert$ {\it
 template-ref}\} \\
& {\it block} \\
& \verb|!$xmp| {\tt end task} \\
& \\
\verb![C]! & \verb|#pragma xmp| {\tt task on} \{{\it nodes-ref} $\vert$
     {\it template-ref}\} \\
& {\it block} \\
\end{tabular}

\subsubsection*{Description}

When a node encounters a {\tt task} construct at runtime, it executes
the associated block (called a {\it task}) if it is included by the node
set specified by the {\tt on} clause; otherwise it skips executing the
block.

%This line was inserted by Sakagami for svn test. 

Unless a task is surrounded by a {\tt \Directive{tasks}} construct,
{\it nodes-ref} or {\it template-ref} in the {\tt on} clause is
evaluated at the entry of the task; otherwise {\it nodes-ref} and {\it
template-ref} of the {\tt task} construct are evaluated at the entry of
the surrounding {\tt tasks} construct, where the evaluation results must
be the same in every node in the executing node set.

When {\it nodes-ref} or {\it template-ref} is evaluated, the
corresponding new executing node set is created conceptually. The former
executing node set that includes the node encountering the {\tt task}
construct is referred to as the ``\Term{parent executing node set}'' of
the new executing node set.

\subsubsection*{Restrictions}

\begin{itemize}
\item The node set specified by {\it nodes-ref} or {\it template-ref}
      in the {\tt on} clause of a {\tt task} construct must be a subset
      of the parent executing node set.
\end{itemize}


\subsection{{\tt tasks} construct}

\subsubsection*{Synopsis}

The {\tt \Directive{tasks}} construct is used to instruct nodes in
the executing node set to execute the multiple tasks it surrounds in
arbitray order.

\subsubsection*{Syntax}
\Syntax{tasks}

\begin{tabular}{ll}
\verb![F]! & \verb|!$xmp| {\tt tasks} {\openb} {\tt nowait} {\closeb} \\
& {\it task-construct} \\
& ... \\
& \verb|!$xmp| {\tt end tasks} \\
& \\
\verb![C]! & \verb|#pragma xmp| {\tt tasks} {\openb} {\tt nowait} {\closeb} \\
& {\tt \{} \\
& \hspace{0.5cm} {\it task-construct} \\
& \hspace{0.5cm} ... \\
& {\tt \}} \\
\end{tabular}

\subsubsection*{Description}

{\tt \Directive{task}} constructs (called {\it child tasks}) surrounded
by a {\tt tasks} construct are executed in arbitrary order without
implicit synchronization at the entry of each child task.
%
As a result, if there is no overlap between the executing node sets of
the adjacent child tasks, they can be executed in parallel.

Conceptually, {\it nodes-ref} or {\it template-ref} in the {\tt task}
constructs of child tasks are evaluated at the entry of their
surrounding {\tt tasks} construct.

No implicit synchronization is performed at the entry of the {\tt tasks}
construct;
%
implicit synchronization is performed at the exit of the {\tt tasks}
construct, which guarantees that all communications issued inside child
tasks are completed, unless a {\tt nowait} clause is specified.

%When a {\tt nowait} clause is specified, implicit
%synchronization is not performed at the end of the {\tt tasks}
%construct. Without a {\tt nowait} clause, implicit synchronization is
%performed in order to gurantee that all communications issued inside
%child tasks are completed.

\subsubsection*{Example}
\Example{tasks}
\Example{task}
\Example{end tasks}
\Example{end task}

\begin{minipage}{0.45\hsize}
\begin{center}
\begin{Fexample}
      subroutine caller
!$xmp nodes p(1000)
      real a(100,100)
      ...
!$xmp tasks
!$xmp  task on p(1:500)
        call task1(a)
!$xmp  end task
!$xmp  task on p(501:800)
        call task1(a)
!$xmp  end task
!$xmp  task on p(801:1000)
        call task1(a)
!$xmp  end task
!$xmp end tasks
      ...
      end do
\end{Fexample}
\end{center}
\end{minipage}
%
\begin{minipage}{0.45\hsize}
\begin{center}
\begin{FexampleR}
      subroutine task1(a)
      ...
!$xmp nodes q(*)
      real a(100,100)
      ...
      end subroutine
\end{FexampleR}
\end{center}
\end{minipage}
\vspace{1cm}

Explanation to be added.


\subsection{{\tt loop} construct}
\label{sub:loop_construct}

\subsubsection*{Synopsis}

The {\tt \Directive{loop}} construct specifies that each iteration of
the following loop is executed by a node set specified by the {\tt on}
clause, so that the iterations are distributed among nodes and executed
in parallel.
% where the specified data is accessed locally.
% inserted by Sakagami,H. 09/11/13
%If the loop body includes reduction operations, then they must be
%specified in the {\tt loop} directive to obtain the correct results.

\subsubsection*{Syntax}
\Syntax{loop}

\begin{tabular}{ll}
\verb![F]! & \verb|!$xmp| {\tt loop} {\openb} \verb|(| {\it loop-index}
 {\openb}, {\it loop-index}{\closeb}... \verb|)| {\closeb} \\
 & \hspace{6cm}{\tt on} \{{\it nodes-ref} $\vert$ {\it template-ref}\}
     {\openb} {\it reduction-clause} {\closeb} \\
\verb![C]! & \verb|#pragma xmp| {\tt loop} {\openb} \verb|(| {\it
     loop-index} {\openb}, {\it loop-index}{\closeb}... \verb|)|
     {\closeb} \\
 & \hspace{6cm}{\tt on} \{{\it nodes-ref} $\vert$ {\it template-ref}\}
     {\openb} {\it reduction-clause} {\closeb} \\
\end{tabular}

%\vspace{0.3cm}
%
%where {\it on-ref} is one of:
%
%\vspace{0.3cm}
%
%\begin{tabular}{ll}
% \hspace{0.5cm} & {\it template-ref} \\
% & {\it nodes-ref} \\
%\end{tabular}
%
\vspace{0.3cm}

{\it reduction-clause} is:

\vspace{0.3cm}

\begin{tabular}{ll}
 \hspace{0.5cm} & reduction\verb|(| {\it reduction-kind} : {\it reduction-spec}
 {\openb}, {\it reduction-spec} {\closeb}... \verb|)| \\
\end{tabular}

\vspace{0.3cm}

{\it reduction-kind} is one of:

%例えば，.AND.は，論理型の変数に対して，la = la .AND. lgcl(i)を，IANDは，
%整数型変数に対してia = IAND( ia, ib(i) ) とIAND関数を使うときです．
%HPFに入っています．元々，私は書かなかったのですが，岩下さんが削除する必
%要もないだろうとのことで入れました．
% Reduction指示文には入っていますので，追加しました．

\vspace{0.3cm}

\begin{tabular}{ll}
 \verb![F]! & {\tt +} \\
 & {\tt *} \\
 & {\tt -} \\
 & {\tt .AND.} \\
 & {\tt .OR.} \\
 & {\tt .EQV.} \\
 & {\tt .NEQV.} \\
 & {\tt MAX} \\
 & {\tt MIN} \\
 & {\tt IAND} \\
 & {\tt IOR} \\
 & {\tt IEOR} \\
 & {\tt FIRSTMAX} \\
 & {\tt FIRSTMIN} \\
 & {\tt LASTMAX} \\
 & {\tt LASTMIN} \\
 & \\
 \verb![C]! & {\tt +} \\
 & {\tt *} \\
 & {\tt -} \\
 & {\tt \verb|&|} \\
 & {\tt |} \\
 & {\tt \verb|^|} \\
 & {\tt \verb|&&|} \\
 & {\tt ||} \\
 & {\tt max} \\
 & {\tt min} \\
 & {\tt firstmax} \\
 & {\tt firstmin} \\
 & {\tt lastmax} \\
 & {\tt lastmin} \\
\end{tabular}

\vspace{0.3cm}
{
and \it reduction-spec} is:

\vspace{0.3cm}

\begin{tabular}{ll}
 \hspace{0.5cm} & {\it reduction-variable} {\openb} {\tt /} {\it
 location-variable} {\openb}, {\it location-variable}
 {\closeb}... {\tt /} {\closeb} \\
\end{tabular}

\subsubsection*{Description}

The {\tt \Directive{loop}} directive is associated with a loop nest
consisting of one or more tightly-nested loops that follow the directive
and distribute the execution of their iterations onto nodes determined
by the {\tt on} clause.
% inserted by Sakagami,H. 09/11/13
%Since the iteration range of the loop for each node is determined before
%the loop is executed, efficient loop execution can be expected.

The sequence of {\it loop-index}'s in parenthesis denotes the index of
an iteration. If the control variable of a loop does not appear in the
sequence, it is assumed that each possible value of the control variable
is specified in the sequence, which denotes a set of the index.
%
When the sequence of the {\it loop-index}'s is omitted, it is assumed
that the control variables of all the loops in the associated loop nest
are specified.

When a {\it template-ref} is specified in the {\tt on} clause, the
associated loop is distributed so that the iteration (set) indexed by
the the sequence of {\it loop-index}'s  is executed by the node onto
which the template element specified by the {\it template-ref} is
distributed.

%Therefore, before the {\tt
%\Directive{loop}} construct is executed, the referenced template must be
%fixed.
%When {\it template-spec} is ``*'', the corresponding dimension is
%collapsed so that it is ignored for the distribution of the loop. When
%{\it template-spec} is ``:'', the nodes for all of the template elements
%in the corresponding dimension are assigned to iterations for execution. 

% modified by Sakagami,H. 09/11/13
When a {\it nodes-ref} is specified in the {\tt on} clause, the
associated loop is distributed so that the iteration (set) indexed by
the the sequence of {\it loop-index}'s  is executed by the node
specified by the {\it nodes-ref}.

In addition, the executing node set is updated to the node set specified
by the {\tt on} clause at the beginning of every iteration and restored
to the executing node set before the construct at the end of it.

% inserted and modified by Sakagami,H. 09/11/13
%When the loop includes reduction operations, proper {\it reduction-clause}
%must be specified in order to obtain semantically correct results,
%and
%the reduction operation is executed on the specified local reduction
%variable just after the execution of the loop.

When a {\it reduction-clause} is specified, a reduction operation of the
kind specified by {\it reduction-kind} for the variable specified by
{\it reduction-variable} is executed just after the execution of the loop
nest.

% inserted by Sakagami,H. 09/11/13
%The {\tt loop} construct that has {\it template-ref} as {\it
%on-ref} and the {\tt reduction} clause, except in cases with {\it
%reduction-kind} of {\tt FIRSTMAX}, {\tt FIRSTMIN}, {\tt LASTMAX}, or
%{\tt LASTMIN}, is equivalent to the {\tt \Directive{reduction}}
%construct with the following {\it template-spec} replacements:

The reduction operation executed, except in cases with {\it
reduction-kind} of {\tt FIRSTMAX}, {\tt FIRSTMIN}, {\tt LASTMAX}, or
{\tt LASTMIN}, is equivalent to the {\tt reduction} construct
with the same {\it reduction-kind} and {\it reduction-variable},
and an {\tt on} clause obtained from the original one by replacing:
%
\begin{itemize}
 \item ``{\tt :}'' in the {\it nodes-ref} or the {\it template-ref} with
       ``{\tt *}'', and
 \item {\it loop-index} in the {\it nodes-ref} or the {\it template-ref}
       with a triplet representing the range of its value.
\end{itemize}
%
Therefore, for example, the two codes below are equivalent.

\vspace{1zw}

\begin{minipage}{0.45\hsize}
\begin{center}
\begin{Fexample}
!$xmp loop (j) on t(:,j)
!$xmp+             reduction(op:s)
      do j = js, je
        ...
        do i = 1, N
          s = s op a(i,j)
        end do
        ...
      end do
\end{Fexample}
\end{center}
\end{minipage}
%
\begin{minipage}{0.46\hsize}
\begin{center}
\begin{FexampleR}
// Initialize s_tmp to the identity
// element of the op operator
      s_tmp = ...

!$xmp loop (j) on t(:,j) 
      do j = js, je
        ...
        do i = 1, N
          s_tmp = s_tmp op a(i,j)
        end do
        ...
      end do

!$xmp reduction(op:s_tmp)
!$xmp+               on t(*,js:je)

      s = s op s_tmp
\end{FexampleR}
\end{center}
\end{minipage}

\vspace{1zw}

Particularly tor the reduction kinds of {\tt FIRSTMAX}, {\tt FIRSTMIN},
{\tt LASTMAX} and {\tt LASTMIN}, in addition to a corresponding {\tt
MAX} or {\tt MIN} reduction operation, the {\it location-variable}'s are
set after executing the {\tt loop} construct as follows:
%
\begin{itemize}
 \item For {\tt FIRSTMAX} and {\tt FIRSTMIN}, they are set to their
       values at the end of the {\it first} iteration in which
       the {\it reduction-variable} takes the value of the reduction
       result, where {\it first} means first in the sequential order in
       which iterations of the associated loop nest were executed
       without parallelization.
 \item For {\tt LASTMAX} and {\tt LASTMIN}, they are set to their
       values at the end of the {\it last} iteration in which
       the {\it reduction-variable} takes the value of the reduction
       result, where {\it last} means last in the sequential order in
       which iterations of the associated loop nest were executed
       without parallelization.
\end{itemize}

% inserted by Sakagami,H. 09/11/13 ----- start ---
%Note that, unlike a {\tt \Directive{loop}} construct with the {\tt
%reduction} clause, a {\tt \Directive{reduction}} construct does not
%consider initialization for the reduction variable.  The following
%programs return different values of the {\tt sum} variable after the
%reduction operation. When {\tt sum} is initialized to zero, these
%programs return the same results.
%
%\vspace{1zw}
%
%\begin{minipage}{0.45\hsize}
%\begin{center}
%\begin{Fexample}
%      sum = 123.45
%!$xmp loop (i) on t(i)
%!$xmp+            reduction(+:sum)
%      do i = 1, N
%         sum = sum + a(i)
%      end do
%\end{Fexample}
%\end{center}
%\end{minipage}
%%
%\begin{minipage}{0.45\hsize}
%\begin{center}
%\begin{FexampleR}
%      sum = 123.45
%!$xmp loop (i) on t(i)
%      do i = 1, N
%         sum = sum + a(i)
%       end do
%!$xmp reduction(+:sum) on t(1:N)
%\end{FexampleR}
%\end{center}
%\end{minipage}
% inserted by Sakagami,H. 09/11/13 ----- end ---

\subsubsection*{Restrictions}

\begin{itemize}
 \item {\it loop-index} must be a control variable of a loop in the
       associated loop nest.
 \item A control variable of a loop can appear as {\it loop-index} at
       most once.
% \item {\it template-spec} appearing in {\it template-ref} must be
%       either ``*'', ``:'', or {\it loop-index}.
%       In the case of {\it
%       loop-index}, the loop index must be the loop index of the outer
%       loop of the loop.
% \item {\it nodes-ref} must reference different node sets for each {\it
%       loop-index}. These node sets consist of different nodes. That is,
%       a node must not be included in more than one node set. 

 \item The node set specified by {\it nodes-ref} or {\it template-ref}
       in the {\tt on} clause of a {\tt loop} construct must be a subset
       of the parent executing node set.

 \item The template specified by {\it template-ref} must be fixed 
       before the {\tt loop} construct is executed.

 \item The {\tt loop} construct is global, which means that it must be
       executed by all of the executing nodes, and each local variable
       referenced in the directive must have the same value among all of
       them, and the lower bound, upper bound and step of the loops must
       must have the same value among all of them.

% modified by Sakagami,H. 09/11/13
 \item {\it reduction-spec} must have one or more {\it
       location-variable}'s if and only if {\it reduction-kind} is
       either {\tt FIRSTMAX}, {\tt FIRSTMIN}, {\tt LASTMAX}, or {\tt
       LASTMIN}.

% inserted by Sakagami,H. 09/11/13
%\item {\it reduction-clause} must reference the reduction operations
%      associated with the loop after the directive or the loops nested
%      by the loop.

% \item {\it location-variable} must be fixed in the loop after the
%       directive or the loops nested by the loop.

%\item {\it reduction-variable} must not be referred at a certain
%      iteration in the loop, except for updating itself.

% \item {\it reduction-variable} and {\it location-variable} must not
%       exist in {\it reduction-clause} of nested loops.

\end{itemize}

\subsubsection*{Examples}
\Example{distribute}
\Example{align}
\Example{loop}

\begin{description}
\item[Example 1]
\hspace{\hsize}
\begin{Fexample}
!$xmp distribute t(block) onto p
!$xmp align (i) with t(i) :: a, b
      ...
!$xmp loop (i) on t(i)
      do i = 1, N
          a(i) = 1.0
          b(i) = a(i)
      end do
\end{Fexample}

The {\tt \Directive{loop}} construct decides the node that executes each
of the iterations, according to the distribution of template {\tt t}, and
distributes 
the execution. This example is syntactically equivalent to the one
shown below, but will be faster because iterations to be executed by
	   each node can be decided before executing the loop.

\begin{Fexample}
!$xmp distribute t(block) onto p
!$xmp align (i) with t(i) :: a, b
      ...
      do i = 1, N
!$xmp task on t(i)
          a(i) = 1.0
          b(i) = a(i)
!$xmp end task
      end do
\end{Fexample}

\item[Example 2]
\hspace{\hsize}
\begin{Fexample}
!$xmp distribute t(*,block) onto p
!$xmp align (i,j) with t(i,j) :: a, b
      ...
!$xmp loop (i,j) on t(i,j)
      do j = 1, M
          do i = 1, N
              a(i,j) = 1.0
              b(i,j) = a(i,j)
          end do
      end do
\end{Fexample}

	   Since the first dimension of template {\tt t} is not
	   distributed, only the {\tt j} loop, which is aligned with the
	   second dimension of {\tt t}, is distributed. This example is
	   syntactically equivalent to the {\tt task} construct shown
	   below.

\begin{Fexample}
!$xmp distribute t(*,block) onto p
!$xmp align (*,j) with t(*,j) :: a, b
      ...
      do j = 1, M
!$xmp task on t(*,j)
          do i = 1, N
              a(i,j) = 1.0
              b(i,j) = a(i,j)
          end do
!$xmp end task 
      end do
\end{Fexample}

\item[Example 3]
\hspace{\hsize}
\begin{Fexample}
!$xmp distribute t(block,block) onto p
!$xmp align (i,j) with t(i,j) :: a, b
      ...
!$xmp loop (i,j) on t(i,j)
      do j = 1, M
          do i = 1, N
              a(i,j) = 1.0
              b(i,j) = a(i,j)
          end do
      end do
\end{Fexample}

% modified by Sakagami,H. 09/11/13
The distribution of loops in the nested loop can be specified
using the sequence of {\it loop-index} in one {\tt loop}
construct. This example is equivalent to the loop shown
below, but will run faster because the iterations 
to be executed by each node can be decided outside of the nested
	   loop. Note that the node set specified by the inner {\tt on}
	   clause is a subset of that specified by the outer one.

\begin{Fexample}
!$xmp distribute t(block,block) onto p
!$xmp align (i,j) with t(i,j) :: a, b
      ...
!$xmp loop (j) on t(:,j)
      do j = 1, M
!$xmp loop (i) on t(i,j)
          do i = 1, N
              a(i,j) = 1.0
              b(i,j) = a(i,j)
          end do
      end do
\end{Fexample}

\item[Example 4]
\hspace{\hsize}
\begin{Fexample}
!$xmp nodes p(10,3)
      ...
!$xmp loop on p(:,i)
      do i = 1, 3
          call subtask ( i )
      end do
\end{Fexample}

	   Three node sets {\tt p(:,1)}, {\tt p(:,2)} and {\tt p(:,3)}
	   are created as the executing node sets, and each of them
	   executes iteration {\tt 1}, {\tt 2} and {\tt 3} of the
	   associated loop, respectively.
%
This example is equivalent to the loop
% modified by Sakagami,H. 09/11/13
containing {\tt task} constructs (below left) or static {\tt tasks/task}
constructs (below right).

\vspace{0.5cm}

\begin{minipage}{0.45\hsize}
\begin{center}
\begin{Fexample}
!$xmp nodes p(10,3)
      ...
      do i = 1, 3
!$xmp task on p(:,i)
          call subtask ( i )
!$xmp end task
      end do
\end{Fexample}
\end{center}
\end{minipage}
\begin{minipage}{0.45\hsize}
\begin{center}
\begin{FexampleR}
!$xmp nodes p(10,3)
      ...
!$xmp tasks
!$xmp task on p(:,1)
      call subtask ( 1 )
!$xmp end task
!$xmp task on p(:,2)
      call subtask ( 2 )
!$xmp end task
!$xmp task on p(:,3)
      call subtask ( 3 )
!$xmp end task
!$xmp task on p(:,3)
      call subtask ( 3 )
!$xmp end task
!$xmp task on p(:,3)
      call subtask ( 3 )
!$xmp end task
!$xmp task on p(:,3)
      call subtask ( 3 )
!$xmp end task
!$xmp end tasks
\end{FexampleR}
\end{center}
\end{minipage}
\vspace{1cm}

\item[Example 5]
\hspace{\hsize}
\begin{Fexample}
      ...
      lb(1)  = 1
      iub(1) = 10
      lb(2)  = 11
      iub(2) = 25
      lb(3)  = 26
      iub(3) = 50
!$xmp loop (i) on p(lb(i):iub(i))
      do i = 1, 3
          call subtask ( i )
      end do
\end{Fexample}

The executing node sets of different sizes are created by
{\tt p(lb(i):iub(i))} with different values of i for unbalanced workloads. This example is equivalent to the loop containing 
% modified by Sakagami,H. 09/11/13
{\tt \Directive{task}} constructs (below left) or static {\tt
	   tasks/task} constructs (below right).

\vspace{1cm}

\begin{minipage}{0.45\hsize}
\begin{center}
\begin{Fexample}
      do i = 1, 3
!$xmp task on p(lb(i):iub(i))
          call subtask ( i )
!$xmp end task
      end do
      ...
\end{Fexample}
\end{center}
\end{minipage}
\begin{minipage}{0.45\hsize}
\begin{center}
\begin{FexampleR}
!$xmp tasks
!$xmp task on p(1:10)
      call subtask ( 1 )
!$xmp end task
!$xmp task on p(11:25)
      call subtask ( 2 )
!$xmp end task
!$xmp task on p(25:50)
      call subtask ( 3 )
!$xmp end task
!$xmp end tasks
\end{FexampleR}
\end{center}
\end{minipage}
\vspace{1cm}

\item[Example 6]
\hspace{\hsize}
\begin{Fexample}
      ...
      s = 0.0
!$xmp loop (i) on t(i) reduction(+:s)
      do i = 1, N
          s = s + a(i)
      end do
\end{Fexample}

This loop computes the sum of {\tt a(i)} in the variable {\tt s} on each
node. Note that 
only the partial sum is computed on {\tt s} without the reduction clause. This
example is equivalent to the code given below. 

\begin{Fexample}
      ...
      s = 0.0
!$xmp loop (i) on t(i) 
      do i = 1, N
          s = s + a(i)
      end do
!$xmp reduction(+:s) on t(1:N)
\end{Fexample}

\item[Example 7]
\hspace{\hsize}
\begin{Fexample}
      ...
      amax = -1.0e30
      ip = -1
      jp = -1
!$xmp loop (i,j) on t(i,j) reduction(firstmax:amax/ip,jp/)
      do j = 1, M
          do i = 1, N
              if( 1(i,j) .gt. amx ) then
                  amx = a(i,j)
                  ip = i
                  jp = j
              end if
          end do
      end do
\end{Fexample}

	   This loop computes the maximum value of {\tt a(i,j)} and
	   stores it into the variable {\tt amax} in each node. In
	   addition, the first indices for the maximum element of {\tt
	   a} are obtained in {\tt ip} and {\tt jp} after executing the
	   loops.
% inserted by Sakagami,H. 09/11/13
	   Note that this example cannot be written with the {\tt
	   reduction} construct.
% modified by Sakagami,H. 09/11/13

%\comment{This example is equivalent to the code below. 
%\begin{Fexample}
%???????????????? no example ?????????????????
%\end{Fexample}}

\end{description}


\subsection{{\tt array} construct}

\subsubsection*{Synopsis}

The {\tt \Directive{array}} construct divides the work of an array
assignment among nodes onto which the array is mapped.

\subsubsection*{Syntax}
\Syntax{array}

\begin{tabular}{ll}
\verb![F]! & \verb|!$xmp| {\tt array on} {\it template-ref} \\
\verb![C]! & \verb|#pragma xmp| {\tt array on} {\it template-ref} \\
\end{tabular}

\subsubsection*{Description}

The array assignment is an alternative to a loop that performs
an assignment to each element of an array.
%
This directive specifies parallel execution of an array assignment,
where each sub-assignment and sub-operation of an element is executed by
the node determined by the {\tt on} clasue.

%The array assignment can be used instead of the loop of the assignment
%for each element. This directive executes the array assignment in each
%node.

Note that array assignments can be used also in {\C}, which is an
extended feature of {\XMP}.

% inserted by Sakagami,H. 09/11/13 --- start ---
\subsubsection*{Restrictions}

\begin{itemize}
\item The template subset specified by {\it template-ref} must have the
      same shape with the associated array assignment.
%\item If the range in {\it template-ref} is omitted, all of the ranges
%      are assumed to be specified.
\item The {\tt \Directive{array}} construct is global and must be
       executed by all of the executing nodes, and each variable
      appearing in the construct must have the same value among all of
      them.
\end{itemize}
% inserted by Sakagami,H. 09/11/13 --- end ---

\subsubsection*{Examples}
\Example{array}

\begin{description}

\item[Example 1]
\hspace{\hsize}
\begin{Fexample}
!$xmp distribute t(block) onto p
!$xmp align (i) with t(i) :: a
      ...
!$xmp array on t(1:N)
      a(1:N) = 1.0
\end{Fexample}

This example is equivalent to the code shown below.

\begin{Fexample}
!$xmp distribute t(block) onto p
!$xmp align (i) with t(i) :: a
      ...
!$xmp loop on t(1:N)
      do i = 1, N
          a(i) = 1.0
      end do
\end{Fexample}

% inserted by Sakagami,H. 09/11/13 --- start ---
\item[Example 2]
\hspace{\hsize}
\begin{Fexample}
!$xmp template t(100,20)
!$xmp distribute t(block,block) onto p
      dimension a(100,20), b(100,20)
!$xmp align (i,j) with t(i,j) :: a, b
      ...
!$xmp array on t
      a = b + 2.0
\end{Fexample}

This example is equivalent to the code shown below.

\begin{Fexample}
!$xmp template t(100,20)
!$xmp distribute t(block,block) onto p
      dimension a(100,20), b(100,20)
!$xmp align (i,j) with t(i,j) :: a, b
      ...
!$xmp loop (i,j) on t(i,j)
      do j = 1, 20
         do i = 1, 100
            a(i,j) = b(i,j) + 2.0
         end do
      end do
\end{Fexample}
\end{description}
% inserted by Sakagami,H. 09/11/13 --- end ---
