\section{Global-view Communication and Synchronization Constructs}

\subsection{{\tt reflect} Construct}

\subsubsection*{Synopsis}

The {\tt \Directive{reflect}} directive assigns the value of a
reflection source to the corresponding shadow object for variables
having the shadow attribute. 

\subsubsection*{Syntax}
\Syntax{reflect}

\begin{tabular}{ll}
\verb![F]! & \verb|!$xmp| {\tt reflect} \verb|(| {\it array-name} [,
 {\it array-name} ... ] \verb|)| \\
\verb![C]! & \verb|#pragma xmp| {\tt reflect} \verb|(| {\it array-name}
     [, {\it array-name} ... ] \verb|)| \\
\end{tabular}

\subsubsection*{Description}

The {\tt reflect} directive copies the value of
the reflection source of the reflect-object specified by {\it array-name} to all
shadow objects. This directive may execute the communications.

\subsection{{\tt gmove} Construct}
\subsubsection*{Synopsis}

The {\tt \Directive{gmove}} construct copies the data of a
distributed array in global view. 

\subsubsection*{Syntax}
\Syntax{gmove}

\begin{tabular}{ll}
\verb![F]! & \verb|!$xmp| {\tt gmove} [{\tt in}$\vert${\tt out}] {\it dest}
= {\it source} \\
\verb![C]! & \verb|#pragma xmp| {\tt gmove} [{\tt in}$\vert${\tt out}] {\it
  dest} = {\it source} \\
\end{tabular}

\subsubsection*{Description}

This directive executes a copy operation of the global data array object
distributed into nodes. This directive is followed by the assignment
statement of the scalar value and array sections. The assignment operation
of the array sections of a distributed array may require communication
between nodes.

The assignment statement must be a simple assignment without
any arithmetic operations.   

In \XMP, the \C language is extended to support array section notation in order to
support an assignment of array objects.

The assignment statement must have one of the following patterns:

\begin{itemize}
\item  Scalar assignment. For example:

\begin{tabular}{lll}
\hspace{0.5cm} & {\tt s1 = s2} & ! {\tt s1}, {\tt s2} is a scalar
variable \\ 
& {\tt a(3) = b(i, j)} & ! {\tt a}, {\tt b} are arrays. \\
\end{tabular}

\item Array assignment. The left-hand value must be an array name,
array section, or scalar object. For example:

\begin{tabular}{lll}
\hspace{0.5cm} & {\tt a = b} & ! {\tt a}, {\tt b} are arrays \\
 & {\tt a(1:10) = b(n:n+9, k)} & ! left and right are array section \\
 & {\tt a(1:10) = s2} & ! The left is an array section, left is a
 scalar variable \\
 & {\tt a(1:10) = b(i, j)} & ! The left is an array section, left is a
 scalar object \\
\end{tabular}
\end{itemize}

The {\tt gmove} construct must be executed by nodes in the executing
node set. The value of scalar objects, the index value, and the range
value of the array section in the assignment statement must be the same in
every node executing this directive.

When no option is specified, the copy operation is performed
collectively by all nodes in the executing node set. In this case, all
elements in both the source array and the target array must be distributed on
to the executing node set. If the object on the right-hand side is a local
object, then the value of the local object must be the same. In this case, the
assignment is performed locally, where the object on the left-hand side is 
distributed. If the object on the left-hand side is a local object
and the object on the right-hand side is global, then this operation
performs broadcast operation.

If an {\tt in} option is specified, then the node that owns the element of
the object on the left-hand side obtains the data on the right-hand side by the 
remote copy (get) operation. Therefore, the object on the left-hand side
must be distributed onto the executing node set. 

If an {\tt out} operation is specified, then the node that owns the element
of the object on the right-hand side places the data on the left-hand side by the
remote copy (put) operation. Therefore, the object on the right-hand side
must be distributed onto the executing node set.

If no option is specified, then the copy can be performed by two-side
communication. In this case, the receiver side waits for the sender side,
resulting in implicit synchronization. 

If an {\tt in} or {\tt out} clause is specified, then the
copy operation should be performed by one-side communication for remote
memory access. Thus, no synchronization is implied. If
synchronization between reader and writer is required, then the programmer
must perform synchronization explicitly by a {\tt barrier} construct. If the reader
and the writer do not belong to the same executing node set, then
point-to-point synchronization by {\tt post-wait} directive can be used.

\subsubsection*{Restrictions}

\begin{itemize}
\item The {\tt gmove} construct must be executed by all nodes in the
  executing node set.
\end{itemize}

\subsubsection*{Examples}
\begin{description}
\item[Example 1: Array assignment]
\Example{gmove}

If both the left-hand side and the right-hand side are distributed
arrays, then the copy operation can be performed by all-to-all
communication. If the left-hand side is a duplicate array, this copy
is performed by multi-cast communication. If the right-hand side is a
duplicate array, then no communication is required.

\vspace{0.5cm}

\begin{minipage}{0.45\hsize}
\begin{center}
\begin{Fexample}
!$xmp gmove
      a(:,1:N) = b(:,3,0:N-1)
\end{Fexample}
\end{center}
\end{minipage}
\begin{minipage}{0.45\hsize}
\begin{center}
\begin{CexampleR}
#pragma xmp gmove
      a[1:N][:] = b[0:N-1][3][:];
\end{CexampleR}
\end{center}
\end{minipage}
\vspace{1cm}

\item[Example 2: Scalar assignment to an array] 

When the right-hand side is a distributed array, the copy is performed by
broadcast communication from the owner of the element of the array. If
the right-hand side is a duplicate array, then no communication is required.

\vspace{0.5cm}

\begin{minipage}{0.45\hsize}
\begin{center}
\begin{Fexample}
!$xmp gmove
      a(:,1:N) = c(k)
\end{Fexample}
\end{center}
\end{minipage}
\begin{minipage}{0.45\hsize}
\begin{center}
\begin{CexampleR}
#pragma xmp gmove
      a[1:N][:] = c[k]
\end{CexampleR}
\end{center}
\end{minipage}
\vspace{1cm}

\item[Example 3]
\hspace{\hsize}
\begin{Fexample}
!$xmp nodes p(4)
      real a(4), b(4)
!$xmp distribute (block) onto p :: a,b
      ...
!$xmp task on p(1:2)	! Only p(1), p(2) execute this section
      ...
!$xmp gmove
      a(1:2) - b(2:3)	! Communication to outside
      ...		! of executing node occurs
!$xmp end task
\end{Fexample}

\end{description}

\subsection{{\tt barrier} Construct}

\subsubsection*{Synopsis}

The {\tt \Directive{barrier}} construct specifies an explicit barrier
at the point at which the construct appears. 

\subsubsection*{Syntax}
\Syntax{barrier}

\begin{tabular}{ll}
\verb![F]! & \verb|!$xmp| {\tt barrier} [{\tt on} {\it nodes-ref}$\vert${\it template-ref}] \\
\verb![C]! & \verb|#pragma xmp| {\tt barrier} [{\tt on} {\it nodes-ref}$\vert${\it template-ref}] \\
\end{tabular}

\subsubsection*{Description}

The barrier operation is performed among the node set specified by
an {\tt on} clause. If an {\tt on} clause is not specified, then it is
assumed that the current executing node set is specified in an {\tt
on} clause.

Note that an {\tt on} clause may represent multiple node sets. In such a
case, a barrier operation is performed in each node set.

%The barrier construct also has the function of ensuring that all of the
%remote copy operations that are invoked by gmove in/out constructs
%executed by the node set specified by the {\tt on} clause are finished.

\subsubsection*{Restriction}

\begin{itemize}
\item The node set specified by the {\tt on} clause must be a subset of the
      executing node set.  
\end{itemize}


\subsection{{\tt reduction} Construct}

\subsubsection*{Synopsis}

The {\tt \Directive{reduction}} construct performs a reduction
operation among nodes. 

\subsubsection*{Syntax}
\Syntax{reduction}

\begin{tabular}{ll}
\verb![F]! & \verb|!$xmp| {\tt reduction( } {\it reduction-kind} {\it
  :} {\it variable} [, {\it variable} ] ... {\tt )} [{\tt on} {\it
      node-ref}$\vert${\it template-ref}] \\
\end{tabular}

where {\it reduction-kind} is one of:

\begin{tabular}{ll}
 \hspace{0.5cm} & {\tt +} \\
 & {\tt *} \\
 & {\tt .AND.} \\
 & {\tt .OR.} \\
 & {\tt .EQV.} \\
 & {\tt .NEQV.} \\
 & {\tt MAX} \\
 & {\tt MIN} \\
 & {\tt IAND} \\
 & {\tt IOR} \\
 & {\tt IEOR} \\
\end{tabular}

\begin{tabular}{ll}
\verb![C]! & \verb|#pragma xmp| {\tt reduction(} {\it reduction-kind} {\it
  :} {\it variable} [, {\it variable} ] ... {\tt )} [{\tt on} {\it
      node-ref}$\vert${\it template-ref}] \\
\end{tabular}

where {\it reduction-kind} is one of:

\begin{tabular}{ll}
 \hspace{0.5cm} & {\tt +} \\
 & {\tt *} \\
 & {\tt -} \\
 & {\verb|&|} \\
 & {\tt |} \\
 & {\verb|^|} \\
 & {\verb|&&|} \\
 & {\tt ||} \\
 & {\tt max} \\
 & {\tt min} \\
\end{tabular}

\subsubsection*{Description}

The {\tt reduction} construct performs a type of
% modified by Sakagami,H. 09/11/13                                            
reduction operation specified by {\it reduction-kind} for the specified
local variable in each node of the node set specified by the {\tt on}
clause and sets the reduction results to variables in each node. The
variable for the reduction operation is referred to as the ``\Term{reduction
variable}''. Thus, after the reduction operation, the value of the
reduction variable becomes the same in every node that performs the
operatoin.

% inserted by Sakagami,H. 09/11/13 ----- start ----                            
When {\it template-ref} is specified in the {\tt on} clause, the operation
is performed in a node set that consists of nodes onto which the
specified subset of the template is distributed.
Therefore, before the {\tt reduction} construct is executed, the
referenced template must be fixed.
%
%When {\it template-subscript} in the {\it template-ref} is ``*'', nodes
%in the corresponding dimension are ignored for the reduction operation.
%
%When {\it template-subscript} in the {\it template-ref} is {\it
%triplet}, nodes for all template elements in the corresponding dimension
%perform the reduction operation.

When {\it node-ref} is specified in the {\tt on} clause, the operation
is performed in the specified node set.
%Therefore, before the {\tt \Directive{reduction}} construct is executed,
%the referenced node set must be fixed.

When the {\tt on} clause is omitted, the operation is performed in the
current executing node set.

Note that an {\tt on} clause may represent multiple node sets. In such a
case, a barrier operation is performed in each node set.

\subsubsection*{Restrictions}

\begin{itemize}
%\item {\it template-spec} appearing in {\it template-ref} must be either ``*'', ``\
%:'' or the range.
%\item If {\tt on} clause is omitted, the operation is done in the current execu\
%ting node.
 \item The variables specified by the sequence of {\it variable} must
       either not be aligned or be replicated among nodes of the node
       set specified by the {\tt on} clause.
 \item The {\tt reduction} construct is collective and must be
       executed by all of the executing nodes, and each variable
       appearing in the construct must have the same value among all of
       the executing nodes.
 \item The node set specified by the {\tt on} clause must be a subset of the
       current executing node set.
\end{itemize}
% inserted by Sakagami,H. 09/11/13 ----- end ---- 

\subsubsection*{Examples}
\Example{reduction}

\begin{description}
\item[Example 1]
\hspace{\hsize}
\begin{Fexample}
!$xmp reduction(+:s)

!$xmp reduction(max:aa) on t(*,:)

!$xmp reduction(min:bb) on p(10:30)
\end{Fexample}

% modified by Sakagami,H. 09/11/13                                             
%In the first example, the scalar variable {\tt s} is assumed to contain the 
%partial sum of the variable, and the reduction operation calculates the
%total sum of the variable. The total sum is stored in the variable in
%each node.
In the first example, the reduction operation calculates the sum of the
scalar variable {\tt s} and the result is stored in the variable in each
node.

% modified by Sakagami,H. 09/11/13                                             
The second example computes the maximum value of the variable {\tt aa}
in each node set onto which each of the subsets of the template
specified by {\tt t(*,:)} is distributed.
%that consists of nodes associated with the
%range of the second dimension of template {\tt t}.

% modified by Sakagami,H. 09/11/13                
In the third example, the minimum value of the variable {\tt bb} in the node 
set specified by {\tt p(10:30)}. This example is equivalent to the
following code using the {\tt \Directive{task}} construct.

\begin{Fexample}
!$xmp task on p(10:30)
!$xmp reduction(min:bb)
!$xmp end task
\end{Fexample}

\item[Example 2]
\hspace{\hsize}
\begin{Fexample}
      dimension a(n,n), p(n), w(n)
!$xmp align a(i,j) with t(i,j)
!$xmp align p(i) with t(i,*)
!$xmp align a(j) with t(*,j)
      ...
!$xmp loop (j) on t(:,j)
      do j = 1, n
          sum = 0
!$xmp loop (i) on t(i,j) reduction(+:sum)
          do i = 1, n
              sum = sum + a(i,j) * p(i)
          end do
          w(j) = sum
      end do
\end{Fexample}

This code computes the matrix vector product.
% modified by Sakagami,H. 09/11/13
The {\tt reduction} clause is specified for the {\tt \Directive{loop}}
construct of the inner loop. This example is equivalent to the following
program.

\begin{Fexample}
      dimension a(n,n), p(n), w(n)
!$xmp align a(i,j) with t(i,j)
!$xmp align p(i) with t(i,*)
!$xmp align a(j) with t(*,j)
      ...
!$xmp loop (j) on t(:,j)
      do j = 1, n
          sum = 0
!$xmp loop (i) on t(i,j) 
          do i = 1, n
              sum - sum + a(i,j) * p(i)
          end do
!$xmp reduction(+:sum) on t(1:n,j)
          w(j) = sum
      end do
\end{Fexample}

In these cases, the reduction operation on the scalar variable {\tt sum}
is performed for every iteration in the outer loop, which may cause a
large overhead.
% modified by Sakagami,H. 09/11/13
The {\tt reduction} clause cannot be specified for the {\tt
\Directive{loop}} construct of the outer loop to reduce this overhead,
%
%because the loop index of the outer loop ({\tt j}) is different from that 
%for the reduction operation ({\tt i}).
because the node set where the reduction operation specified by a {\tt
reduction} clause of a {\tt loop} construct is performed is determined
from its {\tt on} clause (see \ref{sub:loop_construct}) and
the {\tt on} clause of the outer {\tt loop} construct is different from
that of the inner one. 
%
However, this code can be modified with the {\tt \Directive{reduction}}
construct as follows: 

\begin{Fexample}
      dimension a(n,n), p(n), w(n)
!$xmp align a(i,j) with t(i,j)
!$xmp align p(i) with t(i,*)
!$xmp align a(j) with t(*,j)
      ...
!$xmp loop (j) on t(:,j)
      do j = 1, n
          sum = 0
!$xmp loop (i) on t(i,j) 
          do i = 1, n
              sum - sum + a(i,j) * p(i)
          end do
          w(j) = sum
      end do
!$xmp reduction(+:w) on t(1:n,*)
\end{Fexample}

This code executes a reduction operation on the array {\tt w} only once,
which may result in faster operation.  

\end{description}


\subsection{{\tt bcast} Construct}

\subsubsection*{Synopsis}

The {\tt \Directive{bcast}} construct executes broadcast communication
from one node.

\subsubsection*{Syntax}
\Syntax{bcast}

\begin{tabular}{ll}
\verb![F]! & \verb|!$xmp| {\tt bcast} {\it variable} 
[, {\it variable}...] [{\tt from} {\it nodes-ref} [{\tt on} {\it
  nodes-ref}$\vert${\it template-ref}] \\
\verb![C]! & \verb|#pragma xmp| {\tt bcast} {\it variable} 
[, {\it variable}...] [{\tt from} {\it nodes-ref} [{\tt on} {\it
  nodes-ref}$\vert${\it template-ref}] \\
\end{tabular}

\subsubsection*{Description}

The value of the variables specified by {\it variable} is broadcasted
from the node specified by the {\tt from} clause (called the source node) to
the nodes in the node set specified by the {\tt on} clause. The specified
variable to be broadcasted is referred to as the ``\Term{broadcast
variable}". After executing this construct, the value of the broadcasted
variable becomes the same as the value of the source node. If the {\tt
from} clause is omitted, then the first node of the specified node set
is a source node. If the {\tt on} clause is omitted, then the operation
is performed in the current executing node set.

\subsubsection*{Restrictions}

\begin{itemize}
\item The variables specified by the {\it variable} sequence must
      either not be aligned or be replicated among nodes of the node set
      specified by the {\tt on} clause.
\item The {\tt bcast} construct is collective, which means that a {\tt
      bcast} construct must be executed by all of the executing nodes,
      and each variable appearing in the construct must have the same
      value among all of the executing nodes.
\item The node set specified by the {\tt on} clause must be a subset of the
      current executing node set.
\item The source node specified by the {\tt from} clause must belong to
      the node set specified by the {\tt on} clause. 
\end{itemize}

