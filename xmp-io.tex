
 \chapter{XcalableMP I/O(Proposal)}

 \section{Categorization of I/O}
 XcalableMP has three kinds of I/O.

  \subsection{Local I/O}

  Local I/O is the way to use I/O statements and I/O service functions in
  base languages, in which I/O statements and functions are used without
  any directives.

  I/O statements (in {\XMP} {\Fort}) and I/O functions (in {\XMP} {\C})
  are executed in local similar to the other execution statements.
  It depends on the system which nodes can handle the I/O statements and
  functions.

  Local I/O can read a file written by the base language and, vice
  versa.

  [F] A name of a global array in the I/O list describes the
  entire area of the array located in each node.

  An array element of a global array can be referred as an I/O item only
  in the node where it is located.

  [F] Any array section of a global array cannot be referred as an
  I/O item.

  \subsection{Master I/O[F]}

  Master I/O is input and output for the file that corresponds to an
  execution node set.
  Master I/O is global execution.

  In master I/O, a global data is input and output as if it is executed
  only by master node, which represents the execution node set, through
  its local copy of the data.

  Master node is chosen among the execution node set arbitrarily by the
  system, and is unique to the execution node set during execution of
  the program.

  Master I/O is provided in the form of directives of {\XMP} {\Fort}.

  A global array as an I/O item is accessed in the sequential order of
  array elements.
  When a local variable is read from a file, the value is copied to all
  nodes of the execution node set.
  When a local variable or an expression is written to a file, only the
  value of the data on master node is written.
  
  Master I/O can read a file written by the base language, and vice
  versa.
  

  \subsection{Global I/O}

  Also global I/O is input and output for the file that corresponds to
  an execution node set.
  Some executions of global I/O are global and the others are local.
  In a large system with many nodes, global I/O can be expected higher
  speed and less memory consumption execution than master I/O.

  [F] It is provided in the form of directives for a part of I/O
  statements, such as OPEN, CLOSE, READ
  and WRITE statements.

  [C] It is provided in the form of service functions and include files.

  Global I/O can handle only unformatted (binary) files. In XcalableMP Fortran,
  implied DO-Loops and some specifiers cannot be used.
  In XcalableMP C, a formatted I/O library, including fprintf() and fscanf(), is not provided.

  Global I/O can read a file written in MPI-IO, and vice versa. 

  [F] File formats are not compatible between XcalableMP Fortran
  and the base language because global I/O does not generate or access
  the file header and footer particular to the base language.

  There are three kinds of Global I/O, as shown in Table
  \ref{tb:global}.
  {\bf Collective} global I/O is global (collective) execution and
  sequential file access.
  It handles global data in the sequential order, similar to master
  I/O.
  {\bf Atomic} global I/O is local execution and sequential file access.
  Execution nodes share file positioning of the global I/O file and
  execute each I/O statement and library call mutually.
  {\bf Direct} global I/O is local execution and direct file access.
  Each execution node has its own file positioning and accesses a shared
  file concurrently.

  \begin{table}[tb]
   \begin{center}
    \caption{Global I/O}
    \label{tb:global}
    \begin{tabular}{|c||l|l|}
     \hline 
     & independent/collective & access method  \\ \hline \hline
     Collectibe I/O & collective & sequential access \\ \hline
     Atomic I/O & independent & sequential access \\ \hline
     Direct I/O & independent & direct access \\ \hline
    \end{tabular}
   \end{center}
  \end{table}
  
  Restriction

  \begin{itemize}
   \item  The name of a global array may not be declared in a namelist
	  group.
	  That is, NAMELIST I/O is not allowed for global arrays.
  \end{itemize}

  Advice for programmers

  Local I/O is useful for debugging focusing on a node since local I/O
  is executed on each node individually.

  Master I/O is a directive extension, in which the execution result
  matches the one of the base language ignoring directive lines.

  Global I/O aims for highly-parallel I/O using thousands of nodes.
  It is limited to binary file.
  It avoids extreme concentration of computational load and memory
  consumption to specific nodes using MPI-IO or other parallel I/O
  techniques.

  \section{File Connection}

  A file is connected to a unit in XcalableMP Fortran and to a file
  handler in XcalableMP C.
  This operation is called {\bf file connection}.
  Local I/O connects a file in each node independently.
  Master I/O and global I/O connect a file to an execution node set
  collectively.
  
  There are two ways of file connections, dynamic connection and
  preconnection.
  Dynamic connection connects a file during execution of the program.
  Preconnection connects a file at the begininng of execution of the
  program and therefore it can execute I/O statements and functions
  without the prior execution of an OPEN statement or a function call to
  open the file.

  \subsection{File connection in local I/O}

  The language processor of the base language connects the file in each
  node.
  File system visible to each node is implementation dependent.

  It is implementation dependent which nodes can access the standard
  input, output and error files.
  It is also implementation dependent how behave the nodes accessing the
  same file at the same time; e.g., data in the standard input file may
  be read only one node and may be replicated all nodes.
  It is implementation dependent how data from the multiple nodes are
  merged into the standard output/error file.
  
  \subsection{File connection in master I/O [F]}

  An OPEN statement specified with a master I/O directive connects the
  master I/O file to the execution node set.
  When a master I/O file is connected by a READ statement or a WRITE
  statement without encountering any OPEN statement, the name and
  attribute of the file depend on the language system of the base
  language.
  Disconnection from a master I/O file is executed by a CLOSE statement
  or termination of the program.

  Dynamic connection must be executed concurrently by all nodes sharing
  the file with the same unit number.
  Two execution node sets may employ the same unit number only if they
  have no common node.

  The standard input, output and error files are preconnected to the
  entire node set.
  Therefore, master I/O executed on the entire node set is always
  allowed without OPEN and CLOSE statements.


  \subsection{File connection in global I/O}

  Dynamic connecton of global I/O is global (collective) execution and
  is valid for the execution node set.
  Global I/O file cannot be preconnected.

  \subsubsection*{[F]}

  An OPEN statement specified with a global I/O directive connects the
  global I/O file to the execution node set.
  Disconnection from a global I/O file is executed by a CLOSE statement
  or termination of the program.

  Dynamic connection must be executed concurrently by all nodes sharing
  the file with the same unit number.
  Two execution node sets may employ the same unit number only if they
  have no common node.

  \subsubsection*{[C]}

  A library function to open a global I/O file connect the file to the
  execution node set.
  Disconnection from a global I/O file is executed by a library function
  to close the file or termination of the program.

  \section{Master I/O}

  \subsection*{Summary}
  A master I/O construct executes data transfer between a file and an
  execution node set via master node of the execution node set.
  For a global array, the virtual sequential order of the array elements
  is visible.

  \subsection*{Syntax}
%  \Syntax{tasks}

  \begin{tabular}{ll}
   \verb![F]! & \verb|!$xmp| {\tt \verb|master_io|} \\
   & \hspace{5mm} {\it io-statement} \\
   & \\
   \verb![F]! & \verb|!$xmp| {\tt \verb|master_io|} begin \\
   & \hspace{5mm}{\it io-statement} \\
   & \hspace{5mm}... \\
   & \verb|!$xmp| {\tt \verb|master_io|} end \\
  \end{tabular}

   where {\it io-statement} is one of:

   \begin{itemize}
    \item OPEN statement
    \item CLOSE statement
    \item READ statement
    \item WRITE statement
    \item PRINT statement
    \item BACKSPACE statement
    \item ENDFILE statement
    \item REWIND statement
    \item INQUIRE statement
   \end{itemize}

   \subsection*{Restriction}
   \begin{itemize}
    \item The following items cannot be specified in the input item list.

	  \begin{itemize}
	   \item Array section of global array
	   \item Substring of global array
	   \item Array element whose subscript contains reference of a
		 global array
	   \item Array section whose subscript contains reference of a
		 global array
	   \item Substring whose subscript contains reference of a
		 global array
	   \item Expressions including the global array reference
	   \item I/O implied DO
	  \end{itemize}

    \item An I/O statement specified with a master I/O directive must be
	  executed on the node set that is connected to the file.
    \item Internal file I/O is not allowed as a master I/O.
   \end{itemize}
	  
  \subsection*{Description}

   An I/O statement specified with a master I/O directive accesses to a
   file whose format is the same as the one of the base language.
   The access, including connection, disconnection, input and output,
   file positioning, and inquiry, is global (collective) and must be
   executed on the same node set as the one where the file was
   connected. 

   Master node, a unique node to a execution node set, is chosen by the
   language system.
   Master I/O works as if all file access is executed only on the master
   node.

   The operations for I/O items are summarized in the following table.

   \begin{table}[h]
    \begin{center}
     \begin{tabular}{|l|p{40mm}|p{80mm}|}
      \hline
      \multicolumn{1}{|c}{ }  & {\bf I/O item} & {\bf operation} \\
      \hline
      input item & name of global array & The data that is read 
	      from the file in the sequential order of array elements is distributed onto 
	      the global array on the node set. The file positioning increases by
	      the size of data. \\
      \cline{2-3}
      & array element of global array &  The data that is read from the file
	      is copied to the element of the global array on the specific node.
	      The file positioning increases by the size of data. \\
      \cline{2-3}
      & local variable & The data that is read from the file is replicated to the
	      local variables on all nodes of the execution node
	      set. The file positioning increases by the size of data. \\
      \cline{2-3}
      & inplied DO-loop & For each input item, repeats the above operation. \\
      \hline
      output item & name of global array & The value of the
	      global array is collected and is written to the
	      file in the sequential order of array elements. The file
	      positioning increases by the size of data. \\
      \cline{2-3}
      & array element of global array &  The value of the element of the
	      global array is written to the
	      file. A file position increases by data length. \\
      \cline{2-3}
      & local variable and expression & The value evaluated on the master node
	      is written to the file. The file positioning increases by
	      the size of data. \\
      \cline{2-3}
      & inplied DO-loop & For each output item, repeat the above operation. \\
      \hline
      \end{tabular}
     \end{center}
%    \caption{aaa}
    \label{tb:aaa}
   \end{table}

   Namelist input and output statements cannot treat global arrays.
   A namelist output statement writes the value on the master node to
   the file.
   In the namelist input, each item of the namelist is read from the
   file to the master node if it is recorded in the file.
   And then all items of the namelist are replicated onto all nodes of
   the execution node set even if any item is not read from the file.

   IOSTAT and SIZE specifiers and specifiers of the INQUIRE statement
   that can return values always return the same value among the
   execution node set.

   When a condition specified with ERR, END or EOR specifier is
   satisfied, all nodes of execution node set are branched together to
   the same statement.

   Advice to the implementer

   It is recommended to provide such a compiler option that local I/O
   statements (specified without directives) is regarded as master I/O
   statements (specified with master\_io directives).

   \clearpage
   
   \section{Global I/O}

   Global I/O executes data transfer between a file and global arrays
   distributed on the execution node set.
   Global I/O is restricted within unformatted (binary) files, but
   higher performance and lower memory consumption can be expected than
   master I/O.
   The file format is compatible with the one in MPI-IO.

   Global I/O consists of three kinds, collective I/O, atomic I/O, and
   direct I/O. 

   \subsection{Global I/O construct [F]}
   \subsubsection*{Syntax}

   \begin{tabular}{ll}
   \verb![F]! & \verb|!$xmp| {\tt \verb|global_io|} [atomic / direct] \\
   & \hspace{5mm} {\it io-statement} \\
   & \\
   \verb![F]! & \verb|!$xmp| {\tt \verb|global_io|} [atomic / direct] begin \\
   & \hspace{5mm}{\it io-statement} \\
   & \hspace{5mm}... \\
   & \verb|!$xmp| {\tt \verb|global_io|} end \\
   \end{tabular}

   The first syntax is just a shorthand of the second syntax.

   \subsubsection*{Restriction}

   I/O statements and specifiers available for {\it io-statement} is
   shown in the following table.
   Definition of each specifier is described in the specification of the base language. 

   Case of global\_io construct without direct clause:
   \begin{table}[h]
   \begin{center}
    \label{tb:globalstatement}
    \begin{tabular}{c|l}
     I/O statement & available specifiers \\ \hline
     OPEN & UNIT, IOSTAT, FILE, STATUS, POSITION, ACTION \\
     CLOSE & UNIT, IOSTAT, STATUS \\
     READ & UNIT, IOSTAT \\
     WRITE & UNIT, IOSTAT \\
    \end{tabular}
   \end{center}
   \end{table}

   Case of global\_io construct with direct clause:
   \begin{table}[h]
   \begin{center}
    \label{tb:globalstatement}
    \begin{tabular}{c|l}
     I/O statement & available specifiers \\ \hline
     OPEN & UNIT, IOSTAT, FILE, STATUS, RECL, ACTION \\
     CLOSE & UNIT, IOSTAT, STATUS \\
     READ & UNIT, REC, IOSTAT \\
     WRITE & UNIT, REC, IOSTAT \\
    \end{tabular}
   \end{center}
   \end{table}

   Only the name of a variable (including global variable) can be specified 
   as the input item of READ statement specified with global\_io directive,
   but array element, array section,
   structure component, substring, and implied-DO loop are not allowed as input items.

   Only the name of a global array and an
   expression excluding global array reference can be specified as the output item
   of WRITE statement specified with global\_io directive, 
   but an expression including global array
   reference and implied-DO loop are not allowed as input items.


   \subsubsection*{Description}

   Global I/O construct connects, disconnects, inputs and outputs the global I/O file,
   which is compatible with MPI-IO.

   The standard input, output and error files cannot be a Global I/O file.
   A Global I/O file cannot preconnect to any unit or any file handler,
   and must explicitly be connected by the OPEN statement specified with
   global\_io directive.

   The OPEN statement specified with global\_io directive is global
   (collective) execution, and the file is shared in the execution node
   set.
   A file that is already open by the other OPEN statement with
   global\_io directive cannot be reopen by an OPEN statement with or
   without global\_io directive.

   A global I/O file must be disconnected explicitly by a CLOSE
   statement specified with global\_io directive, else the result of I/O
   is not guaranteed.
   The CLOSE statement specified with global\_io directive is a global
   (collective) execution and must be executed by the same execution
   node set as the one where the OPEN statement is executed.

   Available values of the specifiers in I/O statements are shown in the
   following table.
   Definitions of the specifiers are described in the specification of
   the base language.

   \begin{itemize}
    \item OPEN statement
   
   \begin{table}[h]
    \begin{center}
     \label{tb:globalopen}
     \begin{tabular}{c|p{70mm}l}
      specifiers & value & default \\ \hline
      UNIT & external file unit (scalar constant expression)
	  & not omissible. \\
      FILE & file name (scalar CHARACTER expression)
	  & not omittable. \\
      STATUS & 'OLD', 'NEW', 'REPLACE' or 'UNKNOWN' & 'UNKNOWN' \\
      POSITION\footnote{available only if the directive has no directive
      clause} & 'ASIS', 'REWIND' or 'APPEND' & 'ASIS' \\
      ACTION & 'READ', 'WRITE' or 'READWRITE' & 'READWRITE' \\
      RECL\footnote{available only if the directive has a directive clause} & the value of the record length (scalar constant expression)
	  & not omittable. \\
     \end{tabular}
    \end{center}
   \end{table}

    \item CLOSE statement
	  
   \begin{table}[h]
    \begin{center}
     \label{tb:globalopen}
     \begin{tabular}{c|p{70mm}l}
      specifiers & value & default \\ \hline
      UNIT & external file unit (scalar constant expression)
	  & omittable. \\
      STATUS & 'KEEP' or 'DELETE'
	  & 'KEEP' \\
     \end{tabular}
    \end{center}
   \end{table}

    \item READ/WRITE statement
	  
   \begin{table}[h]
    \begin{center}
     \label{tb:globalopen}
     \begin{tabular}{c|p{70mm}l}
      specifiers & value & default \\ \hline
      UNIT & external file unit (scalar constant expression)
	  & not omittable. \\
      REC\footnote{available only if the directive has a directive clause} & the value of the record length (scalar constant expression)
	  & not omittable. \\
     \end{tabular}
    \end{center}
   \end{table}

    \item When a scalar default INTEGER variable is set to IOSTAT, an
	  error code is set to the specifiers.
	 
   \end{itemize}

   OPEN, CLOSE, READ and WRITE statements specified with global\_io directives
   without atomic and direct clauses are called respectively collective OPEN, collective
   CLOSE, collective READ, and collective WRITE statements respectively.
   These all statements are called collective I/O statements.

   OPEN, CLOSE, READ and WRITE statements specified with global\_io directives
   with atomic clauses are called atomic OPEN, atomic CLOSE, atomic READ, and
   atomic WRITE statements respectively.
   These all statements are called atomic I/O statements.

   OPEN, CLOSE, READ and WRITE statements specified with global\_io directives
   with direct clause are called direct OPEN, direct CLOSE, direct READ, and
   direct WRITE statements respectively.
   These all statements are called direct I/O statements.

   The file connected by collective, atomic or direct OPEN statement can
   be read/be written only by the same type of READ/WRITE statement.
   The file can be disconnected by the same type of CLOSE statement.
   Different types of global I/O cannot be executed together for the same file or the
   same unit.
   For example, atomic I/O statements cannot be executed for the unit
   connected by a collective OPEN statement.

   \clearpage
   
   \subsubsection{collective I/O statement}

   Collective I/O statements read/write for a file shared between nodes.
   I/O data remains the image of global array.

   Collective I/O statements are matched across all nodes.
   In collective I/O, I/O operations, such as connection, disconnection,
   read and write, for a file must be executed in the same nodes. 
   
   The operations for I/O items are summarized in the following table.

   \begin{table}[h]
    \begin{center}
     \begin{tabular}{l|r|p{80mm}}
      \hline
      \multicolumn{1}{c}{ }  & {\bf I/O item} & {\bf operation} \\ \hline
      input item & name of distributed array & The value is read along
	      the file view set in a template. The value is set to array
	      elements in each node.
	      File position seeks by data size.\\
      \cline{2-3}
      & duplicate variable &  The value set from a file is set in a
	      duplicate array in all nodes. File position seeks by
	      data length. \\ \hline
      output item & name of distributed array & The value is written
	      along the file view set in a template. The value is
	      written for a file.
	      File position seeks by data size.\\
      \cline{2-3}
      & duplicate variable, expression & The value in any one node is
	      written to the file.  File position seeks by data
	      length. \\ \hline
      \end{tabular}
     \end{center}
%    \caption{aaa}
    \label{tb:aaa}
   \end{table}

   \subsubsection{atomic I/O statement}

   Atomic I/O statements exclusively read/write for a file shared
   between nodes in no particular order.
   As nondeterministic parallel execution, if the program is the same,
   the results can differ.

   Atomic OPEN and CLOSE statements are executed collectively. Atomic
   READ and WRITE statements are executed locally.
   The file connected by atomic OPEN statements is disconnected by using
   atomic CLOSE statements in all execution nodes.
   Atomic READ and WRITE statements can be executed from any node in a
   set of execution nodes.

   Atomic READ and WRITE statements are exclusively excuted.
   A unit of atomic I/O statements is a READ statement or a WRITE
   statement.

   At first, the file position is determined by the POSITION specifier in
   atomic I/O statement.
   After that, file position seeks by the length of the input/output
   variables.


   \subsubsection{direct I/O statement}

   Direct I/O statements read/write for a file shared between nodes.
   File position is specified on each node.

   Direct OPEN and CLOSE statements are executed collectively. Direct
   READ and WRITE statements are executed locally.
   The file connected by direct OPEN statements is disconnected by using
   atomic CLOSE statements in all execution nodes.
   Direct READ and WRITE statements can be executed from any node in a
   set of execution nodes.
   
   Direct READ and WRITE statements read/write to file position
   specified by a REC specifier.
   Direct READ and WRITE statements are executed independently.
   File position is the value multiplied by the value specified in a RECL
   specifiers and the value specified in a REC specifier.


   \subsection{Global I/O library (C)}

   In C, some of data types is defined in an include file.
   A set of library functions with the arguments of the data type is
   provided.
   Built-in function gotten these type from the name of a distributed
   array is provided.
   The following types are provided.

   \begin{itemize}
    \item xmp\_file\_t : file handle
    \item xmp\_array\_t : distributed data for a distributed
	  array
    \item xmp\_rang\_t : expression of array section
   \end{itemize}

   The following library functions are provided.
   Collective function names end with \_all.

   \begin{itemize}
    \item global I/O file operation
    \begin{itemize}
     \item xmp\_fopen\_all
     \item xmp\_fclose\_all
     \item xmp\_fseek
     \item xmp\_fseek\_shared\_all
     \item xmp\_ftell
     \item xmp\_ftell\_shared
     \item xmp\_file\_sync\_all
    \end{itemize}
    \item collective I/O
    \begin{itemize}
     \item xmp\_file\_set\_view\_all
     \item xmp\_file\_clear\_view\_all
     \item xmp\_fread\_all
     \item xmp\_fwrite\_all
     \item xmp\_fread\_darray\_all
     \item xmp\_fwrite\_darray\_all
    \end{itemize}
    \item atomic I/O
    \begin{itemize}
     \item xmp\_fread\_shared
     \item xmp\_fwrite\_shared
    \end{itemize}
    \item direct I/O
    \begin{itemize}
     \item xmp\_fread
     \item xmp\_fwrite
    \end{itemize}
   \end{itemize}

   \clearpage
   
   \subsubsection{Data type}

   The following data types are defined in include file ``xmp\_io.h''.
   \begin{description}
    \item[xmp\_file\_t] The valiable of xmp\_file\_t type is a file
	       handle.
	       The file handle is generated when a file is opened.
	       There are shared file pointer and intrinsic file pointer
	       to identify file position.

	       Shared file pointer share with shared nodes.
	       The file pointer is seeked by atomic I/O.
	       Identify file pointer is seeked by collective I/O and
	       direct I/O.
	       
	       These file pointers are managed by the member of
	       xmp\_file\_t type structures.
	       These file pointers are controled and referenced through
	       the library function.
	       
    \item[xmp\_array\_t] The valiable of xmp\_array\_t is distributed data
	       for a distributed array.
	       Distribution, alignment and node array shape, etc are the
	       member of xmp\_array\_t.

	       Distributed data of Distributed array ``A'' is gotten by
	       the following built-in function.
	       
	       xmp\_array\_t xmp\_array\_of(A);
	       
    \item[xmp\_range\_t] The valiable of xmp\_range\_t is an expression
	       of array section.
	       Lower bound, upper bound and stride are included in the
	       member of an array.
   \end{description}

   \subsubsection{Global I/O file operation}

   [OPEN]
   
   The function opens a global I/O file.
   \begin{table}[h]
    \begin{center}
     \begin{tabular}{l|r|p{70mm}}
      \hline
      {\bf function name}  & \multicolumn{1}{c}{\bf xmp\_file\_t
      $*$xmp\_fopne\_all()} &  \\ \hline
      argument & const char $*$fname & file name \\ \cline{2-3}
      & const char $*$amode & equialent to fopen of POSIX. combination
	      of ``rwa+'' \\ \hline
      return value & xmp\_file\_t$*$ & file structure. NULL is returned
	      when a program abend. \\ \hline
      \end{tabular}
     \end{center}
%    \caption{aaa}
    \label{tb:aaa}
   \end{table}

   File view is initialized. The value of shared file pointer and intrinsic file
   pointer depend on the value of amode.

      \begin{table}[h]
   \begin{center}
    \label{tb:xxx}
    \begin{tabular}{c|p{100mm}}
     amode & intended purpose \\ \hline
     r &  Open for reading only. File pointer points the beginning of
	 the file.\\
     r+ & Open an existing file for update (reading and writing). File
	 pointer points the beginning of the file. \\
     w &  Create for writing. If a file by that name already exists, it
	 will be overwritten. File pointer points the begininng of th file. \\
     w+ & Create a new file for update (reading and writing). If a file
	 by that name already exists, it will be overwritten. File
	 pointer points the beginning of the file. \\
     a & Append; open for writing at end-of-file or create for writing
	 if the file does not eist. File pointer points the end of the file. \\
     a+ & Open for append; open (or create if the file does not exist)
	 for update at the end of the file. File pointer points the
	 beginning of the file. \\
    \end{tabular}
   \end{center}
   \end{table}


   \clearpage
   [CLOSE]

   The function closes a global I/O file.

   \begin{table}[h]
    \begin{center}
     \begin{tabular}{l|l|p{70mm}}
      \hline
      {\bf function name}  & \multicolumn{1}{c}{\bf xmp\_file\_t
      $*$xmp\_fclose\_all(fh)} &  \\
      \hline
      argument & xmp\_file\_t $*$fh & file structure \\
      \hline
      return value & int & 0: normal termination \\
      &  & 1: abnormal termination. fh is NULL. \\
      &  & 2: abnormal termination. error in MPI\_File\_close. \\ \hline
      \end{tabular}
     \end{center}
%    \caption{aaa}
    \label{tb:close}
   \end{table}
   
   [intrinsic file pointer setting]

   Change the setting of intrinsic file pointer.
   \begin{table}[h]
    \begin{center}
     \begin{tabular}{l|r|p{70mm}}
      \hline
      {\bf function name}  & \multicolumn{1}{c}{\bf int xmp\_fseek(fh,
      offset, whence)} &  \\ \hline
      argument & xmp\_file\_t $*$fh & file structure \\ \cline{2-3}
      & long long offset & displacement of current file view from
	      position of whence \\ \cline{2-3}
      & int whence & choose file position \\
      &  & SEEK\_SET: the beginning of the file \\ 
      &  & SEEK\_CUR: current position \\ 
      &  & SEEK\_END: the end of the file \\ \hline
      return value & int & 0: normal termination \\
      &  & an integer othe than 0: abnormal termination \\ \hline
      \end{tabular}
     \end{center}
%    \caption{aaa}
    \label{tb:aaa}
   \end{table}

   \clearpage

   [shared file pointer setting]

   Change the setting of shared file pointer.
   \begin{table}[h]
    \begin{center}
     \begin{tabular}{l|r|p{70mm}}
      \hline
      {\bf function name}  & \multicolumn{1}{c}{\bf int xmp\_fseek\_shared(fh,
      offset, whence)} &  \\ \hline
      argument & xmp\_file\_t $*$fh & file structure \\ \cline{2-3}
      & long long offset & displacement of current file view from
	      position of whence \\ \cline{2-3}
      & int whence & choose file position \\
      &  & SEEK\_SET: the beginning of the file \\ 
      &  & SEEK\_CUR: current position \\ 
      &  & SEEK\_END: the end of the file \\ \hline
      return value & int & 0: normal termination \\
      &  & an integer othe than 0: abnormal termination \\ \hline
      \end{tabular}
     \end{center}
%    \caption{aaa}
    \label{tb:aaa}
   \end{table}


   [referece to position of intrinsic file pointer]

   Refer to position of intrinsic file pointer.
   \begin{table}[h]
    \begin{center}
     \begin{tabular}{l|r|p{70mm}}
      \hline
      {\bf function name}  & \multicolumn{1}{c}{\bf long long
      xmp\_ftell(fh)} &  \\ \hline
      argument & xmp\_file\_t $*$fh & file structure \\ \hline
      return value & long long & Upon successful completion, the
	      function shall open the file and return a non-negative
	      integer representing the lowest numbered unused file
	      descriptor. Otherwise, negative number shall be
	      returned. \\ \hline
      \end{tabular}
     \end{center}
%    \caption{aaa}
    \label{tb:aaa}
   \end{table}
   

   
   [referece for position of shared file pointer]

   Refer to position of shared file pointer.
   \begin{table}[h]
    \begin{center}
     \begin{tabular}{l|r|p{70mm}}
      \hline
      {\bf function name}  & \multicolumn{1}{c}{\bf long long
      xmp\_ftell\_shared(fh)} &  \\ \hline
      argument & xmp\_file\_t $*$fh & file structure \\ \hline
      return value & long long & Upon successful completion, the
	      function shall open the file and return a non-negative
	      integer representing the lowest numbered unused file
	      descriptor. Otherwise, negative number shall be
	      returned. \\ \hline
      \end{tabular}
     \end{center}
%    \caption{aaa}
    \label{tb:aaa}
   \end{table}
   
   

   [file synchronization]

   File synchronizing.
   Completion of writing for a file from shared nodes is guaranteed.

   \begin{table}[h]
    \begin{center}
     \begin{tabular}{l|r|p{70mm}}
      \hline
      {\bf function name}  & \multicolumn{1}{c}{\bf int
      xmp\_file\_sync\_all(fh)} &  \\ \hline
      argument & xmp\_file\_t $*$fh & file structure \\ \hline
      return value & int & 0: normal termination \\
      &  & an integer othe than 0: abnormal termination \\ \hline
      \end{tabular}
     \end{center}
%    \caption{aaa}
    \label{tb:aaa}
   \end{table}

   \clearpage

   \subsubsection{collective I/O}

   Collective I/O is collectively executed.
   Collective I/O read/write from position of intrinsic file pointer.
   Assume that file view is previously set, where file view mechanism
   describes relationship between how nodes will access their data
   and how data laid out on disk.
   A detailed the definition of file view mechanism can be found in MPI
   2.0 specificaation.

   [file view setting]

   The function sets file view.

   \begin{table}[h]
    \begin{center}
     \begin{tabular}{l|r|p{70mm}}
      \hline
      {\bf function name}  & \multicolumn{1}{c}{\bf int xmp\_file\_set\_view\_all(fh,
      disp, ap, rp)} &  \\ \hline
      argument & xmp\_file\_t $*$fh & file structure \\ \cline{2-3}
      & long long disp & displacement from the beginning of the file. \\ \cline{2-3}
      & xmp\_array\_t ap & data of distributed array \\ \cline{2-3}
      & xmp\_range\_t $*$rp & data of accessible range \\ \hline
      return value & int & 0: normal termination \\
      &  & an integer othe than 0: abnormal termination \\ \hline
      \end{tabular}
     \end{center}
%    \caption{aaa}
    \label{tb:aaa}
   \end{table}

   
   [file view initialization]

   The function clears file view.
   Position of shared file pointer and intrinsic file pointer is set to
   disp.
   Element data type and file type is set to MPI\_BYTE.
   
   \begin{table}[h]
    \begin{center}
     \begin{tabular}{l|r|p{70mm}}
      \hline
      {\bf function name}  & \multicolumn{1}{c}{\bf int xmp\_file\_clear\_view\_all(fh,
      disp)} &  \\ \hline
      argument & xmp\_file\_t $*$fh & file structure \\ \cline{2-3}
      & long long disp & displacement from the beginning of the file. \\ \hline
      return value & int & 0: normal termination \\
      &  & an integer othe than 0: abnormal termination \\ \hline
      \end{tabular}
     \end{center}
%    \caption{aaa}
    \label{tb:aaa}
   \end{table}


   [collective READ for duplicate variable]

   The function collectively reads data from position of shared file
   pointer.

   \begin{table}[h]
    \begin{center}
     \begin{tabular}{l|r|p{70mm}}
      \hline
      {\bf function name}  & \multicolumn{1}{c}{\bf Size\_t
      xmp\_fread\_all(fh, buffer, size, count)} &  \\ \hline
      argument & xmp\_file\_t $*$fh & file structure \\ \cline{2-3}
      & void $*$buffer & beginning address of loading valiables \\ \cline{2-3}
      & size\_t size & the size of a loading element of data \\ \cline{2-3}
      & size\_t count & the number of loading data element \\ \hline
      return value & int & Upon successful completion, return the size
	      of loading data. Otherwise, negative number shall be
	      returned. \\ \hline
      \end{tabular}
     \end{center}
%    \caption{aaa}
    \label{tb:aaa}
   \end{table}


   [collective WRITE for duplicate variable]

   The function collectively writes data from position of shared file
   pointer.

   \begin{table}[h]
    \begin{center}
     \begin{tabular}{l|r|p{70mm}}
      \hline
      {\bf function name}  & \multicolumn{1}{c}{\bf size\_t
      xmp\_fwrite\_all(fh, buffer, size, count)} &  \\ \hline
      argument & xmp\_file\_t $*$fh & file structure \\ \cline{2-3}
      & void $*$buffer & beginning address of storing valiables \\ \cline{2-3}
      & size\_t size & the size of a storing element of data \\ \cline{2-3}
      & size\_t count & the number of storing data element \\ \hline
      return value & int & Upon successful completion, return the size
	      of storing data. Otherwise, negative number shall be
	      returned. \\ \hline
      \end{tabular}
     \end{center}
%    \caption{aaa}
    \label{tb:aaa}
   \end{table}

   \clearpage
   [collective READ for distributed array]

   The function collectively reads data to distributed array from
   position of shared file pointer.

   \begin{table}[h]
    \begin{center}
     \begin{tabular}{l|r|p{70mm}}
      \hline
      {\bf function name}  & \multicolumn{1}{c}{\bf size\_t
      xmp\_fread\_darray\_all(fh, ap, rp)} &  \\ \hline
      argument & xmp\_file\_t $*$fh & file structure \\ \cline{2-3}
      & xmp\_array\_t ap & data of distributed array \\ \cline{2-3}
      & xmp\_range\_t $*$rp & data of accessible range \\ \hline
      return value & int & Upon successful completion, return the size
	      of loading data. Otherwise, negative number shall be
	      returned. \\ \hline
      \end{tabular}
     \end{center}
%    \caption{aaa}
    \label{tb:aaa}
   \end{table}

   The function reads data in the range $rp$ for distributed array $ap$.

   [collective WRITE for distributed array]

   The function collectively writes data to distributed array from
   position of shared file pointer.

   \begin{table}[h]
    \begin{center}
     \begin{tabular}{l|r|p{70mm}}
      \hline
      {\bf function name}  & \multicolumn{1}{c}{\bf size\_t
      xmp\_fwrite\_darray\_all(fh, ap, rp)} &  \\ \hline
      argument & xmp\_file\_t $*$fh & file structure \\ \cline{2-3}
      & xmp\_array\_t ap & data of distributed array \\ \cline{2-3}
      & xmp\_range\_t $*$rp & data of accessible range \\ \hline
      return value & int & Upon successful completion, return the size
	      of loading data. Otherwise, negative number shall be
	      returned. \\ \hline
      \end{tabular}
     \end{center}
%    \caption{aaa}
    \label{tb:aaa}
   \end{table}

   The function writes data in the range $rp$ for distributed array $ap$.

   \clearpage

   \subsubsection{atomic I/O}

   Atomic I/O is locally executed. But the I/O exclusively read/write
   from position fo shared file pointer. Before atomic I/O is executed,
   file view must be cleared.
   
   [Rationale]

   In MPI, when all proceses use shared file pointer, these processes
   must specify the same file view. But xmp\_file\_set\_view\_all
   function set different file view for each node.
   Thus, before atomic I/O is executed, file view must be cleared.

   [atomic read]

   The function exclusively reads data form position of shared file
   pointer.

   \begin{table}[h]
    \begin{center}
     \begin{tabular}{l|r|p{40mm}}
      \hline
      {\bf function name}  & \multicolumn{1}{c}{\bf size\_t
      xmp\_fread\_shared(fh, buffer, size, count)} &  \\ \hline
      argument & xmp\_file\_t $*$fh & file structure \\ \cline{2-3}
      & void $*$buffer & beginning address of loading valiables \\ \cline{2-3}
      & size\_t size & the size of a loading element of data \\ \cline{2-3}
      & size\_t count & the number of loading data element \\ \hline
      return value & int & Upon successful completion, return the size
	      of loading data. Otherwise, negative number shall be
	      returned. \\ \hline
      \end{tabular}
     \end{center}
%    \caption{aaa}
    \label{tb:aaa}
   \end{table}


   [atomic read]

   The function exclusively writes data to distributed array from
   position of shared file pointer.

   \begin{table}[h]
    \begin{center}
     \begin{tabular}{l|r|p{70mm}}
      \hline
      {\bf function name}  & \multicolumn{1}{c}{\bf size\_t
      xmp\_write\_shared(fh, ap, rp)} &  \\ \hline
      argument & xmp\_file\_t $*$fh & file structure \\ \cline{2-3}
      & xmp\_array\_t ap & data of distributed array \\ \cline{2-3}
      & xmp\_range\_t $*$rp & data of accessible range \\ \hline
      return value & int & Upon successful completion, return the size
	      of storing data. Otherwise, negative number shall be
	      returned. \\ \hline
      \end{tabular}
     \end{center}
%    \caption{aaa}
    \label{tb:aaa}
   \end{table}


   \subsubsection{direct I/O}

   Direct I/O is locally exectuted. The I/O exclusively read/write data
   from position of intrinsic file pointer in each node.
   The setting file view is enable.

   [direct read]

   The function reads data from position of instrinsic file
   pointer.
   The function is locally executed.

   \begin{table}[h]
    \begin{center}
     \begin{tabular}{l|r|p{70mm}}
      \hline
      {\bf function name}  & \multicolumn{1}{c}{\bf size\_t
      xmp\_fread(fh, buffer, size, count)} &  \\ \hline
      argument & xmp\_file\_t $*$fh & file structure \\ \cline{2-3}
      & void $*$buffer & beginning address of loading valiables \\ \cline{2-3}
      & size\_t size & the size of a loading element of data \\ \cline{2-3}
      & size\_t count & the number of loading data element \\ \hline
      return value & int & Upon successful completion, return the size
	      of loading data. Otherwise, negative number shall be
	      returned. \\ \hline
      \end{tabular}
     \end{center}
%    \caption{aaa}
    \label{tb:aaa}
   \end{table}

   [direct write]

   The function write data from position of instrinsic file
   pointer.
   The function is locally executed.

   \begin{table}[h]
    \begin{center}
     \begin{tabular}{l|r|p{70mm}}
      \hline
      {\bf function name}  & \multicolumn{1}{c}{\bf size\_t
      xmp\_fwrite(fh, buffer, size, count)} &  \\ \hline
      argument & xmp\_file\_t $*$fh & file structure \\ \cline{2-3}
      & void $*$buffer & beginning address of storing valiables \\ \cline{2-3}
      & size\_t size & the size of a storing element of data \\ \cline{2-3}
      & size\_t count & the number of storing data element \\ \hline
      return value & int & Upon successful completion, return the size
	      of storing data. Otherwise, negative number shall be
	      returned. \\ \hline
      \end{tabular}
     \end{center}
%    \caption{aaa}
    \label{tb:aaa}
   \end{table}

   