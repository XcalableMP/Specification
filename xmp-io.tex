
 \chapter{XcalableMP I/O(Proposal)}

 \section{Categorization of I/O}
 XcalableMP has three kinds of I/O.

  \subsection{Local I/O}

  Local I/O is the way to use I/O statements and standard I/O functions in
  base languages, in which I/O statements and functions are used without
  any directives.

  I/O statements (in {\XMP} {\Fort}) and I/O functions (in {\XMP} {\C})
  are executed in local similar to the other execution statements.
  It depends on the system which nodes can handle the I/O statements and
  functions.

  Local I/O can read a file written by the base language and, vice
  versa.

  [F] A name of a global array in the I/O list describes the
  entire area of the array located in each node.

  An array element of a global array can be referred as an I/O item only
  in the node where it is located.

  [F] Any array section of a global array cannot be referred as an
  I/O item.

  \subsection{Master I/O[F]}

  Master I/O is input and output for the file that corresponds to an
  executing node set.
  Master I/O is global execution.

  In master I/O, a global data is input and output as if it is executed
  only by master node, which represents the executing node set, through
  its local copy of the data.

  Master node is chosen among the executing node set arbitrarily by the
  system, and is unique to the executing node set during execution of
  the program.

  Master I/O is provided in the form of directives of {\XMP} {\Fort}.

  A global array as an I/O item is accessed in the sequential order of
  array elements.
  When a local variable is read from a file, the value is copied to all
  nodes of the executing node set.
  When a local variable or an expression is written to a file, only the
  value of the data on master node is written.
  
  Master I/O can read a file written by the base language, and vice
  versa.
  

  \subsection{Global I/O}

  Also global I/O is input and output for the file that corresponds to
  an executing node set.
  Some executions of global I/O are global and the others are local.
  In a large system with many nodes, global I/O can be expected higher
  speed and less memory consumption execution than master I/O.

  [F] It is provided in the form of directives for a part of I/O
  statements, such as OPEN, CLOSE, READ
  and WRITE statements.

  [C] It is provided in the form of service functions and include files.

  Global I/O can handle only unformatted (binary) files. In XcalableMP Fortran,
  implied DO loops and some specifiers cannot be used.
  In XcalableMP C, a formatted I/O library, including fprintf() and fscanf(), is not provided.

  Global I/O can read a file written in MPI-IO, and vice versa. 

  [F] File formats are not compatible between XcalableMP Fortran
  and the base language because global I/O does not generate or access
  the file header and footer particular to the base language.

  There are three kinds of Global I/O, as shown in Table
  \ref{tb:global}.
  {\bf Collective} global I/O is global (collective) execution and
  sequential file access.
  It handles global data in the sequential order, similar to master
  I/O.
  {\bf Atomic} global I/O is local execution and sequential file access.
  Executing nodes share file positioning of the global I/O file and
  execute each I/O statement and library call mutually.
  {\bf Direct} global I/O is local execution and direct file access.
  Each executing node has its own file positioning and accesses a shared
  file collectively.

  \begin{table}[tb]
   \begin{center}
    \caption{Global I/O}
    \label{tb:global}
    \begin{tabular}{|c||l|l|}
     \hline 
     & independent/collective & access method  \\ \hline \hline
     Collectibe I/O & collective & sequential access \\ \hline
     Atomic I/O & independent & sequential access \\ \hline
     Direct I/O & independent & direct access \\ \hline
    \end{tabular}
   \end{center}
  \end{table}
  
  \subsubsection*{Restriction}

  \begin{itemize}
   \item  The name of a global array may not be declared in a namelist
	  group.
	  That is, NAMELIST I/O is not allowed for global arrays.
  \end{itemize}

  \subsubsection*{Advice to the programmer}

  Local I/O is useful for debugging focusing on a node since local I/O
  is executed on each node individually.

  Master I/O is a directive extension, in which the execution result
  matches the one of the base language ignoring directive lines.

  Global I/O aims for highly-parallel I/O using thousands of nodes.
  It is limited to binary file.
  It avoids extreme concentration of computational load and memory
  consumption to specific nodes using MPI-IO or other parallel I/O
  techniques.

  \section{File Connection}

  A file is connected to a unit in XcalableMP Fortran and to a file
  handler in XcalableMP C.
  This operation is called {\bf file connection}.
  Local I/O connects a file in each node independently.
  Master I/O and global I/O connect a file to an executing node set
  collectively.
  
  There are two ways of file connections, dynamic connection and
  preconnection.
  Dynamic connection connects a file during execution of the program.
  Preconnection connects a file at the begininng of execution of the
  program and therefore it can execute I/O statements and functions
  without the prior execution of an OPEN statement or a function call to
  open the file.

  \subsection{File connection in local I/O}

  The language processor of the base language connects the file in each
  node.
  File system visible to each node is implementation dependent.

  It is implementation dependent which nodes can access the standard
  input, output and error files.
  It is also implementation dependent how behave the nodes accessing the
  same file at the same time; e.g., data in the standard input file may
  be read only one node and may be replicated all nodes.
  It is implementation dependent how data from the multiple nodes are
  merged into the standard output/error file.
  
  \subsection{File connection in master I/O [F]}

  An OPEN statement specified with a master I/O directive connects the
  master I/O file to the executing node set.
  When a master I/O file is connected by a READ statement or a WRITE
  statement without encountering any OPEN statement, the name and
  attribute of the file depend on the language system of the base
  language.
  Disconnection from a master I/O file is executed by a CLOSE statement
  or termination of the program.

  Dynamic connection must be executed collectively by all nodes sharing
  the file with the same unit number.
  Two executing node sets may employ the same unit number only if they
  have no common node.

  The standard input, output and error files are preconnected to the
  entire node set.
  Therefore, master I/O executed on the entire node set is always
  allowed without OPEN and CLOSE statements.


  \subsection{File connection in global I/O}

  Dynamic connecton of global I/O is global (collective) execution and
  is valid for the executing node set.
  Global I/O file cannot be preconnected.

  \subsubsection*{[F]}

  An OPEN statement specified with a global I/O directive connects the
  global I/O file to the executing node set.
  Disconnection from a global I/O file is executed by a CLOSE statement
  or termination of the program.

  Dynamic connection must be executed collectively by all nodes sharing
  the file with the same unit number.
  Two executing node sets may employ the same unit number only if they
  have no common node.

  \subsubsection*{[C]}

  A library function to open a global I/O file connect the file to the
  executing node set.
  Disconnection from a global I/O file is executed by a library function
  to close the file or termination of the program.

  \section{Master I/O}

%  \subsection*{Summary}
  A master I/O construct executes data transfer between a file and an
  executing node set via master node of the executing node set.
  For a global array, the virtual sequential order of the array elements
  is visible.

  \subsection{\mio Construct}
  
  \subsection*{Syntax}
%  \Syntax{tasks}

  \begin{tabular}{ll}
   \verb![F]! & \verb|!$xmp| \mio \\
   & \hspace{5mm} {\it io-statement} \\
   & \\
   \verb![F]! & \verb|!$xmp| \mio begin \\
   & \hspace{5mm}{\it io-statement} \\
   & \hspace{5mm}... \\
   & \verb|!$xmp| \mio end \\
  \end{tabular}

   where {\it io-statement} is one of:

   \begin{itemize}
    \item OPEN statement
    \item CLOSE statement
    \item READ statement
    \item WRITE statement
    \item PRINT statement
    \item BACKSPACE statement
    \item ENDFILE statement
    \item REWIND statement
    \item INQUIRE statement
   \end{itemize}

   \subsection*{Restriction}
   \begin{itemize}
    \item The following items cannot be specified in the input item list.
	  \begin{itemize}
	   \item Substring of global array
	   \item Array element whose subscript contains reference of a
		 global array
	   \item Array section whose subscript contains reference of a
		 global array
	   \item Substring whose subscript contains reference of a
		 global array
	   \item Expressions including the global array reference
	   \item {\it io-implied-do} including a global array or subobject of a global array
	  \end{itemize}

    \item An I/O statement specified with a master I/O directive must be
	  executed on the node set that is connected to the file.
    \item Internal file I/O is not allowed as a master I/O.
   \end{itemize}
	  
  \subsection*{Description}

   An I/O statement specified with a master I/O directive accesses to a
   file whose format is the same as the one of the base language.
   The access, including connection, disconnection, input and output,
   file positioning, and inquiry, is global (collective) and must be
   executed on the same node set as the one where the file was
   connected. 

   Master node, a unique node to a executing node set, is chosen by the
   language system.
   Master I/O works as if all file access is executed only on the master
   node.

   The operations for I/O items are summarized in Table \ref{tb:opforio}.

   \begin{table}[h]
    \begin{center}
    \caption{Operations for I/O}
    \label{tb:opforio}
     \begin{tabular}{|l|p{40mm}|p{80mm}|}
      \hline
      \multicolumn{1}{|c}{ }  & {\bf I/O item} & {\bf operation} \\
      \hline
      input item & name of global array & The data that is read 
	      from the file in the sequential order of array elements is distributed onto 
	      the global array on the node set. The file positioning increases by
	      the size of data. \\
      \cline{2-3}
      & array element of global array &  The data that is read from the file
	      is copied to the element of the global array on the specific node.
	      The file positioning increases by the size of data. \\
      \cline{2-3}
      & local variable & The data that is read from the file is replicated to the
	      local variables on all nodes of the executing node
	      set. The file positioning increases by the size of data. \\
      \cline{2-3}
      & implied DO loop & For each input item, repeats the above operation. \\
      \hline
      output item & name of global array & The value of the
	      global array is collected and is written to the
	      file in the sequential order of array elements. The file
	      positioning increases by the size of data. \\
      \cline{2-3}
      & array element of global array &  The value of the element of the
	      global array is written to the
	      file. A file position increases by data length. \\
      \cline{2-3}
      & local variable and expression & The value evaluated on the master node
	      is written to the file. The file positioning increases by
	      the size of data. \\
      \cline{2-3}
      & implied DO loop & For each output item, repeat the above operation. \\
      \hline
      \end{tabular}
     \end{center}
%    \caption{aaa}
    \label{tb:aaa}
   \end{table}

   Namelist input and output statements cannot treat global arrays.
   A namelist output statement writes the value on the master node to
   the file.
   In the namelist input, each item of the namelist is read from the
   file to the master node if it is recorded in the file.
   And then all items of the namelist are replicated onto all nodes of
   the executing node set even if any item is not read from the file.

   IOSTAT and SIZE specifiers and specifiers of the INQUIRE statement
   that can return values always return the same value among the
   executing node set.

   When a condition specified with ERR, END or EOR specifier is
   satisfied, all nodes of executing node set are branched together to
   the same statement.

   \subsubsection*{Advice to the implementer}
   
   It is recommended to provide such a compiler option that local I/O
   statements (specified without directives) is regarded as master I/O
   statements (specified with \mio directives).

   
   \section{Global I/O [F]}

   Global I/O executes data transfer between a file and global arrays
   distributed on the executing node set.
   Global I/O is restricted within unformatted (binary) files, but
   higher performance and lower memory consumption can be expected than
   master I/O.
   The file format is compatible with the one in MPI-IO.

   Global I/O consists of three kinds, collective I/O, atomic I/O, and
   direct I/O. 

   \subsection{\gio construct}
   \subsubsection*{Syntax}

   \begin{tabular}{ll}
   \verb![F]! & \verb|!$xmp| \gio [atomic / direct] \\
   & \hspace{5mm} {\it io-statement} \\
   & \\
   \verb![F]! & \verb|!$xmp| \gio [atomic / direct] begin \\
   & \hspace{5mm}{\it io-statement} \\
   & \hspace{5mm}... \\
   & \verb|!$xmp| end \gio \\
   \end{tabular}

   The first syntax is just a shorthand of the second syntax.

   \subsubsection*{Restriction}

   I/O statements and specifiers available for {\it io-statement} is
   shown in the following table.
   Definition of each specifier is described in the specification of the base language. 

   Case of \gio construct without direct clause:
   \begin{table}[h]
   \begin{center}
    \label{tb:globalstatement}
    \begin{tabular}{|c||l|}
      \hline
     I/O statement & available specifiers \\ \hline \hline
     OPEN & UNIT, IOSTAT, FILE, STATUS, POSITION, ACTION \\ \hline
     CLOSE & UNIT, IOSTAT, STATUS \\ \hline
     READ & UNIT, IOSTAT \\ \hline
     WRITE & UNIT, IOSTAT \\ \hline
    \end{tabular}
   \end{center}
   \end{table}

   Case of \gio construct with direct clause:
   \begin{table}[h]
   \begin{center}
    \label{tb:globalstatement}
    \begin{tabular}{|c||l|}
      \hline
     I/O statement & available specifiers \\ \hline \hline
     OPEN & UNIT, IOSTAT, FILE, STATUS, RECL, ACTION \\ \hline
     CLOSE & UNIT, IOSTAT, STATUS \\ \hline
     READ & UNIT, REC, IOSTAT \\ \hline
     WRITE & UNIT, REC, IOSTAT \\ \hline
    \end{tabular}
   \end{center}
   \end{table}

   Only the name of a variable (including global variable) can be specified 
   as the input item of READ statement specified with \gio directive,
   but array element, array section,
   structure component, substring, and implied DO loop are not allowed as input items.

   Only the name of a global array
   %and an expression excluding global array reference can be specified
   as the output item
   of WRITE statement specified with \gio directive, 
   but an expression including global array
   reference and implied DO loop are not allowed as input items.

   \subsubsection*{Description}

   Global I/O construct connects, disconnects, inputs and outputs the global I/O file,
   which is compatible with MPI-IO.

   The standard input, output and error files cannot be a Global I/O file.
   A Global I/O file cannot preconnect to any unit or any file handler,
   and must explicitly be connected by the OPEN statement specified with
   \gio directive.

   The OPEN statement specified with \gio directive is global
   (collective) execution, and the file is shared in the executing node
   set.
   A file that is already open by the other OPEN statement with
   \gio directive cannot be reopen by an OPEN statement with or
   without \gio directive.

   A global I/O file must be disconnected explicitly by a CLOSE
   statement specified with \gio directive, otherwise the result of I/O
   is not guaranteed.
   The CLOSE statement specified with \gio directive is a global
   (collective) execution and must be executed by the same executing
   node set as the one where the OPEN statement is executed.

   Utilizable values of the specifiers in I/O statements are shown in the
   following table.
   Definitions of the specifiers are described in the specification of
   the base language.

   \begin{itemize}
   \item OPEN statement
   
   \begin{table}[h]
    \begin{center}
     \label{tb:globalopen}
     \begin{tabular}{|c||p{90mm}|l|}
       \hline
      specifiers & value & default \\ \hline \hline
      UNIT & external file unit (scalar constant expression)
	  & not omissible. \\ \hline
      FILE & file name (scalar CHARACTER expression)
	  & not omissible. \\ \hline
      STATUS & 'OLD', 'NEW', 'REPLACE' or 'UNKNOWN' & 'UNKNOWN' \\ \hline
      POSITION & 'ASIS', 'REWIND' or 'APPEND' & 'ASIS' \\ \hline
      ACTION & 'READ', 'WRITE' or 'READWRITE' & 'READWRITE' \\ \hline
      RECL & the value of the record length (scalar constant expression)
	  & not omissible. \\ \hline
     \end{tabular}
    \end{center}
   \end{table}

   POSITION is available only if the directive has no directive clause.
   RECL is available only if the directive has a directive clause.

   \item CLOSE statement
	  
   \begin{table}[h]
    \begin{center}
     \label{tb:globalopen}
     \begin{tabular}{|c||p{90mm}|l|}
        \hline
      specifiers & value & default \\ \hline \hline
      UNIT & external file unit (scalar constant expression)
	  & omissible. \\ \hline
      STATUS & 'KEEP' or 'DELETE'
	  & 'KEEP' \\ \hline
     \end{tabular}
    \end{center}
   \end{table}

    \item READ/WRITE statement

   \begin{table}[h]
    \begin{center}
     \label{tb:globalopen}
     \begin{tabular}{|c||p{90mm}|l|}
       \hline
      specifiers & value & default \\ \hline \hline
      UNIT & external file unit (scalar constant expression)
	  & not omissible. \\ \hline
      REC & the value of the record length (scalar constant expression)
	  & not omissible. \\ \hline
     \end{tabular}
    \end{center}
   \end{table}

   REC is available only if the directive has a directive clause.
   
   \item When a scalar variable of default INTEGER is set to IOSTAT, an
     error code is set to the specifiers.
	 
   \end{itemize}

   OPEN, CLOSE, READ and WRITE statements specified with \gio directives
   without atomic and direct clauses are called collective OPEN, collective
   CLOSE, collective READ, and collective WRITE statements respectively.
   These all statements are called collective I/O statements.

   OPEN, CLOSE, READ and WRITE statements specified with \gio directives
   with atomic clauses are called atomic OPEN, atomic CLOSE, atomic READ, and
   atomic WRITE statements respectively.
   These all statements are called atomic I/O statements.

   OPEN, CLOSE, READ and WRITE statements specified with \gio directives
   with direct clause are called direct OPEN, direct CLOSE, direct READ, and
   direct WRITE statements respectively.
   These all statements are called direct I/O statements.

   The file connected by collective, atomic or direct OPEN statement can
   be read/be written only by the same type of READ/WRITE statement.
   The file can be disconnected by the same type of CLOSE statement.
   Different types of global I/O cannot be executed together for the same file or the
   same unit.
   For example, atomic I/O statements cannot be executed for the unit
   connected by a collective OPEN statement.


   Two data accesses conflict if they access the same absolute byte displacements of the same file and at least one is a write access.
   When two accesses A1 and A2 to the same file conflict in atomic or direct I/O,
   the following BARRIER statement to the file must be invoked between A1 and A1, otherwise the outcome of the accesses is undefined.
   The statement is an extension of BARRIER statement and a collective execution.
   
   \begin{itemize}
     \item BARRIER statement

   \begin{table}[h]
    \begin{center}
     \label{tb:globalopen}
     \begin{tabular}{|c||p{90mm}|l|}
       \hline
       specifiers & value & default \\ \hline \hline
       UNIT & external file unit (scalar constant expression)
       & not omissible. \\ \hline
     \end{tabular}
    \end{center}
   \end{table}

   \end{itemize}

   
   \subsection{Collective I/O statement}

   Collective I/O statements read/write shared files and can handle global arrays.

   All collective I/O statements execute in global (collective).
   In collective I/O, all access for a file, such as connection, disconnection,
   input and output, must be executed on the same executing node set. 
   
   The operations for I/O items are summarized in the following table.

   \begin{table}[h]
    \begin{center}
     \begin{tabular}{|l|r|p{80mm}|}
      \hline
      \multicolumn{1}{|c}{ }  & {\bf I/O item} & {\bf operation} \\ \hline
      input item & name of global array & The value is read from the file in the sequential order of the array elements and is set to the array elements of the global array.
      The file positioning seeks by the size of the data.
      %\\ \cline{2-3}
      %& local variable &  The value read from the file is replicated into the
%	      local array on all executing nodes. The file positioning seeks by
%	      the length of the data.
      \\ \hline
      output item & name of global array & The value referred from the global data 
	      is written to the file in the sequential order of the array elements.
	      The file positioning seeks by the size of the data.
%      \\ \cline{2-3}
%      & local variable, expression & The value evaluated on a node of the executing nodes is written to the file.
%      The file positioning seeks by the size of the data.
      \\ \hline
      \end{tabular}
     \end{center}
%    \caption{aaa}
    \label{tb:aaa}
   \end{table}

\if 0
   If an axis of the global array is aligned to an axis of the template and they are not equal in length, the length of the axis of the global array is regarded as the length of the axis of the template. In the example below, array a is read/written in the collective I/O file as if it is declared as a(10,100).\\
   \begin{tabular}{ll}
     \verb|!$xmp| & \verb|template t(100)| \\
     & dimension a(10, 2:99) \\
     \verb|!$xmp| & \verb|align a(*,i) with t(i)| \\
   \end{tabular}
\fi
   
   \subsection{Atomic I/O statement}

   Atomic I/O statements read/write shared files exclusively among executing nodes
   in arbitrary order.
   Because it is a nondeterministic parallel execution,
   the results can differ every execution time even for the same program.

   Atomic OPEN and CLOSE statements are executed collectively (in global), while atomic
   READ and WRITE statements are executed in local.
   A file connected by an atomic OPEN statement can be disconnected only by an
   atomic CLOSE statement executed on the same executing node set.
   Atomic READ and WRITE statements can be executed on any single node of the
   same executing node set.

   Atomic READ and WRITE statements are exclusively executed.
   The unit of exclusive operation is a single READ statement and a single WRITE
   statement.

   The initial file positioning is determined by the POSITION specifier of
   the atomic OPEN statement.
   And then, the file positioning seeks every READ and WRITE statement 
   by the length of the input/output data.


   \subsection{Direct I/O statement}

   Direct I/O statements read/write shared files with specification of the
   file positioning for each node.

   Direct OPEN and CLOSE statements are executed collectively (in global), while direct
   READ and WRITE statements are executed in local.
   A file connected by a direct OPEN statement can be disconnected only by a
   direct CLOSE statement executed on the same executing node set.
   Direct READ and WRITE statements can be executed on any single node of the
   same executing node set.
   
   Direct READ and WRITE statements read/write local data at the file positioning
   specified by the REC specifier independently in local.
   The file positioning is shifted from the top of the file by the product 
   of the specifiers RECL (of OPEN statement) and
   REC (of READ and WRITE statement). 


   \section{Global I/O library [C]}

   XcalableMP C provides some data types defined in an include file, 
   a set of library functions with arguments of the data types, and
   built-in operators to get values of the data types from names of a variable, a template, etc..

   The following types are provided.

   \begin{itemize}
    \item xmp\_file\_t : file handle
%    \item xmp\_array\_t : mapping descriptor for a global array variable
    \item xmp\_rang\_t : descriptor of array section
   \end{itemize}

   The following library functions are provided.
   Collective function names end with \_all.

   \begin{itemize}
    \item global I/O file operation
    \begin{itemize}
     \item xmp\_fopen\_all : file open
     \item xmp\_fclose\_all : file close
     \item xmp\_fseek : setting (individual) file pointer
     \item xmp\_fseek\_shared\_all : setting shared file pointer
     \item xmp\_ftell : displacement of (individual) file pointer
     \item xmp\_ftell\_shared : displacement of shared file pointer
     \item xmp\_file\_sync\_all : file synchronization
    \end{itemize}
    \item collective I/O
    \begin{itemize}
     \item xmp\_file\_set\_view\_all : setting file view
     \item xmp\_file\_clear\_view\_all : initializing file view
     \item xmp\_fread\_all : collective read of local data
     \item xmp\_fwrite\_all : collective write of local data
     \item xmp\_fread\_darray\_all : collective read of global data
     \item xmp\_fwrite\_darray\_all : collective write of global data
    \end{itemize}
    \item atomic I/O
    \begin{itemize}
     \item xmp\_fread\_shared : atomic read
     \item xmp\_fwrite\_shared : atomic write
    \end{itemize}
    \item direct I/O
    \begin{itemize}
     \item xmp\_fread : direct read
     \item xmp\_fwrite : direct write
    \end{itemize}
   \end{itemize}

   
   \subsection*{Data type}

   The following data types are defined in include file xmp\_io.h.
   \begin{description}
    \item[xmp\_file\_t] A file handler.
	       It is connected to a file when the file is opened.
	       It has a shared file pointer and an individual file pointer
	       to point where to read/write data in the file.

	       A shared file pointer is a shared resource among all nodes of the node set
             that has opened the file. Atomic I/O uses a shared file pointer.
	       An (individual) file pointer is an individual resource on each node. 
	       Collective I/O and direct I/O use individual file pointers.
	       
	       These two file pointers are managed in the structure xmp\_file\_t, .
	       and can be controlled and referenced only through
	       the provided library functions.
\if 0
    \item[xmp\_array\_t] Mapping descriptor for a global array variable,
	       which includes distribution, alignment, and the shape of nodes array.

	       Mapping descriptor of global array A is obtained with
	       the following built-in operator:
	       
	       xmp\_array\_t xmp\_array\_of(A);
\fi
\clearpage
    \item[xmp\_range\_t] Descriptor of array section, including
      lower bound, upper bound and stride for each dimension.
      Functions for operating the descriptor are shown in following table.
      The xmp\_allocate\_range() function is used to allocate memory.
      The xmp\_set\_range() function is used to set ranges of a array section.
      The xmp\_free\_range() function releases the memory for the descriptor.
   \end{description}

   \begin{table}[h]
    \begin{center}
      \begin{tabular}{|l|r|p{90mm}|}
      \hline
      {\bf function name}  & \multicolumn{2}{c|}{\bf xmp\_range\_t $*$xmp\_allocate\_range(n\_dim)}  \\ \hline \hline
      argument & int n\_dim & the number of dimensions \\ \hline
      return value & xmp\_range\_t$*$ & descriptor of array section. NULL is returned
	      when a program abend. \\ \hline
      \end{tabular}
     \end{center}
    \label{tb:aaa}
   \end{table}

   \begin{table}[h]
    \begin{center}
      \begin{tabular}{|l|r|p{90mm}|}
      \hline
          {\bf function name}  & \multicolumn{2}{c|}{\bf void xmp\_set\_range(rp, i\_dim, lb, length, step)}  \\ \hline
          argument & xmp\_range\_t $*$rp  & descriptor \\ \cline{2-3}
          & int i\_dim & target dimension \\ \cline{2-3}
          & int lb & lower bound of array section in the dimension i\_dim \\ \cline{2-3}
          & int length & length of array section in the dimension i\_dim \\ \cline{2-3}
          & int step & stride of array section in the dimension i\_dim \\ \hline
      \end{tabular}
     \end{center}
%    \caption{aaa}
    \label{tb:aaa}
   \end{table}
   
   \begin{table}[h]
    \begin{center}
      \begin{tabular}{|l|r|p{90mm}|}
      \hline
      {\bf function name}  & \multicolumn{2}{c|}{\bf void xmp\_free\_range(rp)}  \\ \hline
      argument & xmp\_range\_t $*$rp & descriptor of array section. \\ \hline
      \end{tabular}
     \end{center}
%    \caption{aaa}
    \label{tb:aaa}
   \end{table}
   

   \clearpage
   \subsection{Global I/O file operation}

   \subsubsection{xmp\_fopen\_all}
   xmp\_fopen\_all opens a global I/O file. Collective (global) execution.
   
   \begin{table}[h]
    \begin{center}
      \begin{tabular}{|l|r|p{90mm}|}
      \hline
      {\bf function name}  & \multicolumn{2}{c|}{\bf xmp\_file\_t
      $*$xmp\_fopen\_all(fname, amode)}  \\ \hline
      argument & const char $*$fname & file name \\ \cline{2-3}
      & const char $*$amode & equialent to fopen of POSIX. combination
	      of ``rwa+'' \\ \hline
      return value & xmp\_file\_t$*$ & file structure. NULL is returned
	      when a program abend. \\ \hline
      \end{tabular}
     \end{center}
%    \caption{aaa}
    \label{tb:aaa}
   \end{table}

   File view is initialized, where file view is based on the MPI-IO vile view mechanism. The value of shared and individual file pointers 
   depend on the value of amode.

   \begin{table}
     \begin{center}
    \label{tb:xxx}
    \begin{tabular}{|c|p{120mm}|}
      \hline
     amode & intended purpose \\ \hline \hline
     r &  Open for reading only. File pointer points the beginning of
	 the file.\\ \hline
     r+ & Open an existing file for update (reading and writing). File
	 pointer points the beginning of the file. \\ \hline
     w &  Create for writing. If a file by that name already exists, it
	 will be overwritten. File pointer points the begininng of th file. \\ \hline
     w+ & Create a new file for update (reading and writing). If a file
	 by that name already exists, it will be overwritten. File
	 pointer points the beginning of the file. \\ \hline
     a & Append; open for writing at end-of-file or create for writing
	 if the file does not eist. File pointer points the end of the file. \\ \hline
     a+ & Open for append; open (or create if the file does not exist)
	 for update at the end of the file. File pointer points the
	 beginning of the file. \\ \hline
    \end{tabular}
   \end{center}
   \end{table}

   \subsubsection{xmp\_fclose\_all}
   xmp\_fclose\_all closes a global I/O file. Collective (global) execution.

   \begin{table}[h]
    \begin{center}
     \begin{tabular}{|l|l|p{80mm}|}
      \hline
      {\bf function name}  & \multicolumn{2}{c|}{\bf xmp\_file\_t
      $*$xmp\_fclose\_all(fh)} \\ \hline \hline
      argument & xmp\_file\_t $*$fh & file structure \\ \hline
      return value & int & 0: normal termination \\
      &  & 1: abnormal termination. fh is NULL. \\
      &  & 2: abnormal termination. error in MPI\_File\_close. \\ \hline
      \end{tabular}
     \end{center}
%    \caption{aaa}
    \label{tb:close}
   \end{table}

   \subsubsection{xmp\_fseek}
   xmp\_fseek sets the individual file pointer in the file structure. Local execution.

   \begin{table}[h]
    \begin{center}
     \begin{tabular}{|l|r|p{70mm}|}
      \hline
      {\bf function name}  & \multicolumn{2}{c|}{\bf int xmp\_fseek(fh,
      offset, whence)}  \\ \hline \hline
      argument & xmp\_file\_t $*$fh & file structure \\ \cline{2-3}
      & long long offset & displacement of current file view from
	      position of whence \\ \cline{2-3}
      & int whence & choose file position \\
      &  & SEEK\_SET: the beginning of the file \\ 
      &  & SEEK\_CUR: current position \\ 
      &  & SEEK\_END: the end of the file \\ \hline
      return value & int & 0: normal termination \\
      &  & an integer other than 0: abnormal termination \\ \hline
      \end{tabular}
     \end{center}
%    \caption{aaa}
    \label{tb:aaa}
   \end{table}

   \clearpage

   \subsubsection{xmp\_fseek\_shared}
   xmp\_fseek\_shared sets the shared file pointer in the file structure. Local execution.

   \begin{table}[h]
    \begin{center}
     \begin{tabular}{|l|r|p{80mm}|}
      \hline
      {\bf function name}  & \multicolumn{2}{c|}{\bf int xmp\_fseek\_shared(fh,
      offset, whence)}  \\ \hline \hline
      argument & xmp\_file\_t $*$fh & file structure \\ \cline{2-3}
      & long long offset & displacement of current file view from
	      position of whence \\ \cline{2-3}
      & int whence & choose file position \\
      &  & SEEK\_SET: the beginning of the file \\ 
      &  & SEEK\_CUR: current position \\ 
      &  & SEEK\_END: the end of the file \\ \hline
      return value & int & 0: normal termination \\
      &  & an integer other than 0: abnormal termination \\ \hline
      \end{tabular}
     \end{center}
%    \caption{aaa}
    \label{tb:aaa}
   \end{table}

   \subsubsection{xmp\_ftell}
   xmp\_ftell inquires the position of the individual file pointer in the file structure. Local execution.

   \begin{table}[h]
    \begin{center}
     \begin{tabular}{|l|r|p{80mm}|}
      \hline
      {\bf function name}  & \multicolumn{2}{c|}{\bf long long
      xmp\_ftell(fh)} \\ \hline \hline
      argument & xmp\_file\_t $*$fh & file structure \\ \hline
      return value & long long & Upon successful completion, the
	      function shall open the file and return a non-negative
	      integer representing the lowest numbered unused file
	      descriptor. Otherwise, negative number shall be
	      returned. \\ \hline
      \end{tabular}
     \end{center}
%    \caption{aaa}
    \label{tb:aaa}
   \end{table}

   \subsubsection{xmp\_ftell\_shared}
   xmp\_ftell\_shared inquires the position of shared file pointer in the file structure. Local execution.

   \begin{table}[h]
    \begin{center}
     \begin{tabular}{|l|r|p{80mm}|}
      \hline
      {\bf function name}  & \multicolumn{2}{c|}{\bf long long
      xmp\_ftell\_shared(fh)} \\ \hline \hline
      argument & xmp\_file\_t $*$fh & file structure \\ \hline
      return value & long long & Upon successful completion, the
	      function shall open the file and return a non-negative
	      integer representing the lowest numbered unused file
	      descriptor. Otherwise, negative number shall be
	      returned. \\ \hline
      \end{tabular}
     \end{center}
%    \caption{aaa}
    \label{tb:aaa}
   \end{table}

   \clearpage
   
   \subsubsection{xmp\_file\_sync\_all}
   xmp\_file\_sync\_all guarantees completion of access to the file from nodes sharing the file.
   Two data accesses conflict if they access the same absolute byte displacements of the same file and at least one is a write access.
   When two accesses A1 and A2 to the same file conflict in atomic or direct I/O, an xmp\_file\_sync\_all to the file must be invoked between A1 and A2, otherwise the outcome of the accesses is undefined.   
   Collective (global) execution.


   \begin{table}[h]
    \begin{center}
     \begin{tabular}{|l|r|p{80mm}|}
      \hline
      {\bf function name}  & \multicolumn{2}{c|}{\bf int
      xmp\_file\_sync\_all(fh)} \\ \hline \hline
      argument & xmp\_file\_t $*$fh & file structure \\ \hline
      return value & int & 0: normal termination \\
      &  & an integer other than 0: abnormal termination \\ \hline
      \end{tabular}
     \end{center}
%    \caption{aaa}
    \label{tb:aaa}
   \end{table}

   \subsection{Collective Global I/O Functions}

   Collective I/O is executed collectively (in global) but using the individual pointer.
   It reads/writes data from the position of the individual file pointer and moves the position
   by the length of the data.

   Before the file access, a file view is often specified. A file view, like a window to the file, 
   spans the positions corresponding to the array elements that each node owns. 
   For more details of file view, refer to the MPI 2.0 specification.

   \subsubsection{xmp\_file\_set\_view}
   xmp\_file\_set\_view sets a file view to the file. Collective (global) execution.

   \begin{table}[h]
    \begin{center}
     \begin{tabular}{|l|r|p{70mm}|}
      \hline
      {\bf function name}  & \multicolumn{2}{c|}{\bf int xmp\_file\_set\_view\_all(fh,
      disp, desc, rp)} \\ \hline \hline
      argument & xmp\_file\_t $*$fh & file structure \\ \cline{2-3}
      & long long disp & displacement from the beginning of the file. \\ \cline{2-3}
      & xmp\_desc\_t desc & descriptor \\ \cline{2-3}
      & xmp\_range\_t $*$rp & range descriptor \\ \hline
      return value & int & 0: normal termination \\
      &  & an integer other than 0: abnormal termination \\ \hline
      \end{tabular}
     \end{center}
%    \caption{aaa}
    \label{tb:aaa}
   \end{table}

   The file view of distributed $desc$ limited to range $rp$ is set into file structure $fh$.

   \clearpage
   \subsubsection{xmp\_file\_clear\_view}
   xmp\_file\_clear\_view clears the file view. Collective (global) execution.

   The positions of the shared and individual file pointers are set to
   disp and 
   the elemental data type and the file type are set to MPI\_BYTE.
   
   \begin{table}[h]
    \begin{center}
     \begin{tabular}{|l|r|p{80mm}|}
      \hline
      {\bf function name}  & \multicolumn{2}{c|}{\bf int xmp\_file\_clear\_view\_all(fh,
      disp)} \\ \hline \hline
      argument & xmp\_file\_t $*$fh & file structure \\ \cline{2-3}
      & long long disp & displacement from the beginning of the file. \\ \hline
      return value & int & 0: normal termination \\
      &  & an integer other than 0: abnormal termination \\ \hline
      \end{tabular}
     \end{center}
%    \caption{aaa}
    \label{tb:aaa}
   \end{table}

   \subsubsection{xmp\_fread\_all}
   xmp\_fread\_all reads the same data from the position of the shared file
   pointer onto the all executing nodes. Collective (global) execution.

   \begin{table}[h]
    \begin{center}
     \begin{tabular}{|l|r|p{80mm}|}
      \hline
      {\bf function name}  & \multicolumn{2}{c|}{\bf Size\_t
      xmp\_fread\_all(fh, buffer, size, count)}  \\ \hline \hline
      argument & xmp\_file\_t $*$fh & file structure \\ \cline{2-3}
      & void $*$buffer & beginning address of loading valiables \\ \cline{2-3}
      & size\_t size & the size of a loading element of data \\ \cline{2-3}
      & size\_t count & the number of loading data element \\ \hline
      return value & int & Upon successful completion, return the size
	      of loading data. Otherwise, negative number shall be
	      returned. \\ \hline
      \end{tabular}
     \end{center}
%    \caption{aaa}
    \label{tb:aaa}
   \end{table}

   \clearpage

   \subsubsection{xmp\_fwrite\_all}
   xmp\_fwrite\_all writes individual data on the all executing nodes to the position of the shared file
   pointer. Collective (global) execution.

   It is assumed that the file view is set previously. Each node writes its data into its own file view.

   \begin{table}[h]
    \begin{center}
     \begin{tabular}{|l|r|p{80mm}|}
      \hline
      {\bf function name}  & \multicolumn{2}{c|}{\bf size\_t
      xmp\_fwrite\_all(fh, buffer, size, count)}  \\ \hline \hline
      argument & xmp\_file\_t $*$fh & file structure \\ \cline{2-3}
      & void $*$buffer & beginning address of storing valiables \\ \cline{2-3}
      & size\_t size & the size of a storing element of data \\ \cline{2-3}
      & size\_t count & the number of storing data element \\ \hline
      return value & int & Upon successful completion, return the size
	      of storing data. Otherwise, negative number shall be
	      returned. \\ \hline
      \end{tabular}
     \end{center}
%    \caption{aaa}
    \label{tb:aaa}
   \end{table}

   \subsubsection{xmp\_fread\_darray\_all}
   xmp\_fread\_darray\_all reads data cooperatively to the global array from the position of the shared file pointer.

   \clearpage

   \begin{table}[h]
    \begin{center}
     \begin{tabular}{|l|r|p{80mm}|}
      \hline
      {\bf function name}  & \multicolumn{2}{c|}{\bf size\_t
      xmp\_fread\_darray\_all(fh, desc, rp)} \\ \hline \hline
      argument & xmp\_file\_t $*$fh & file structure \\ \cline{2-3}
      & xmp\_desc\_t desc & descriptor \\ \cline{2-3}
      & xmp\_range\_t $*$rp & range descriptor \\ \hline
      return value & int & Upon successful completion, return the size
	      of loading data. Otherwise, negative number shall be
	      returned. \\ \hline
      \end{tabular}
     \end{center}
%    \caption{aaa}
    \label{tb:aaa}
   \end{table}

   Data is read from the file to distributed $desc$ limited to range $rp$.

   \subsubsection{xmp\_fwrite\_darray\_all}
   xmp\_fwrite\_darray\_all writes data cooperatively from the global array to the
   position of the shared file pointer.

   \begin{table}[h]
    \begin{center}
     \begin{tabular}{|l|r|p{80mm}|}
      \hline
      {\bf function name}  & \multicolumn{2}{c|}{\bf size\_t
      xmp\_fwrite\_darray\_all(fh, desc, rp)} \\ \hline \hline
      argument & xmp\_file\_t $*$fh & file structure \\ \cline{2-3}
      & xmp\_desc\_t desc & descriptor \\ \cline{2-3}
      & xmp\_range\_t $*$rp & range descriptor \\ \hline
      return value & int & Upon successful completion, return the size
	      of loading data. Otherwise, negative number shall be
	      returned. \\ \hline
      \end{tabular}
     \end{center}
%    \caption{aaa}
    \label{tb:aaa}
   \end{table}

   Data is written from distributed $desc$ limited to range $rp$ to the file.


   \subsection{Atomic Global I/O Functions}

   Atomic I/O is executed in local but using the shared pointer. 
   It exclusively reads/writes local data
   from the position of the shared file pointer and moves the position by the length of the data.

   Before atomic I/O is executed, the file view must be cleared.
   
   [Rationale]

   Though the file views must be the same on all processes in order to use the shared file pointer,
   xmp\_file\_set\_view\_all
   function may set different file views for all nodes.
   Thus, before atomic I/O is used, the file view must be cleared.

   \clearpage

   \subsubsection{xmp\_fread\_shared}
   xmp\_fread\_shared exclusively reads local data form the position of the shared file
   pointer and moves the position by the langth of the data.
   Local execution.

   \begin{table}[h]
    \begin{center}
     \begin{tabular}{|l|r|p{80mm}|}
      \hline
      {\bf function name}  & \multicolumn{2}{c|}{\bf size\_t
      xmp\_fread\_shared(fh, buffer, size, count)}  \\ \hline \hline
      argument & xmp\_file\_t $*$fh & file structure \\ \cline{2-3}
      & void $*$buffer & beginning address of loading valiables \\ \cline{2-3}
      & size\_t size & the size of a loading element of data \\ \cline{2-3}
      & size\_t count & the number of loading data element \\ \hline
      return value & int & Upon successful completion, return the size
	      of loading data. Otherwise, negative number shall be
	      returned. \\ \hline
      \end{tabular}
     \end{center}
%    \caption{aaa}
    \label{tb:aaa}
   \end{table}

   \subsubsection{xmp\_fread\_shared}
   xmp\_fread\_shared exclusively writes local data to the
   position of the shared file pointer and moves the position by the langth of the data.
   Local execution.

   \begin{table}[h]
    \begin{center}
     \begin{tabular}{|l|r|p{80mm}|}
      \hline
      {\bf function name}  & \multicolumn{2}{c|}{\bf size\_t
      xmp\_write\_shared(fh, desc, rp)} \\ \hline \hline
      argument & xmp\_file\_t $*$fh & file structure \\ \cline{2-3}
      & xmp\_desc\_t desc & descriptor \\ \cline{2-3}
      & xmp\_range\_t $*$rp & range descriptor \\ \hline
      return value & int & Upon successful completion, return the size
	      of storing data. Otherwise, negative number shall be
	      returned. \\ \hline
      \end{tabular}
     \end{center}
%    \caption{aaa}
    \label{tb:aaa}
   \end{table}


   \subsection{Direct Global I/O Functions}

   Direct I/O is exectuted in local and using the individual pointer. 
   It individually reads/writes local data
   from the position of the individual file pointer and 
   moves the position by the length of the data taking account of the file view.

   \subsubsection*{Advice to the programmer}

   Function xmp\_fseek is useful to set the individual file pointer.
   It is not recommended using the file view together because of complexity.

   \clearpage
   \subsubsection{xmp\_fread}
   xmp\_fread reads data from the position of the individual file
   pointer and moves the position by the length of the data.
   Local execution.

   \begin{table}[h]
    \begin{center}
     \begin{tabular}{|l|r|p{80mm}|}
      \hline
      {\bf function name}  & \multicolumn{2}{c|}{\bf size\_t
      xmp\_fread(fh, buffer, size, count)} \\ \hline \hline
      argument & xmp\_file\_t $*$fh & file structure \\ \cline{2-3}
      & void $*$buffer & beginning address of loading valiables \\ \cline{2-3}
      & size\_t size & the size of a loading element of data \\ \cline{2-3}
      & size\_t count & the number of loading data element \\ \hline
      return value & int & Upon successful completion, return the size
	      of loading data. Otherwise, negative number shall be
	      returned. \\ \hline
      \end{tabular}
     \end{center}
%    \caption{aaa}
    \label{tb:aaa}
   \end{table}

   \subsubsection{xmp\_fread}
   xmp\_fread writes data to the position of the individual file
   pointer and moves the position by the length of tha data.
   Local execution.

   \begin{table}[h]
    \begin{center}
     \begin{tabular}{|l|r|p{80mm}|}
      \hline
      {\bf function name}  & \multicolumn{2}{c|}{\bf size\_t
      xmp\_fwrite(fh, buffer, size, count)} \\ \hline \hline
      argument & xmp\_file\_t $*$fh & file structure \\ \cline{2-3}
      & void $*$buffer & beginning address of storing valiables \\ \cline{2-3}
      & size\_t size & the size of a storing element of data \\ \cline{2-3}
      & size\_t count & the number of storing data element \\ \hline
      return value & int & Upon successful completion, return the size
	      of storing data. Otherwise, negative number shall be
	      returned. \\ \hline
      \end{tabular}
     \end{center}
%    \caption{aaa}
    \label{tb:aaa}
   \end{table}

   
