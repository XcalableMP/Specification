
 \chapter{XcalableMP I/O}

 \section{Categorization of I/O}
 XcalableMP has three kinds of I/O.

  \subsection{Local I/O}

  Local I/O is the way to use I/O statements and standard I/O functions in the
  base languages, in which I/O statements and functions are used without
  any directives.

  I/O statements (in {\XMP} {\Fort}) and I/O functions (in {\XMP} {\C})
  are executed in local similar to other execution statements.
  It depends on the system which nodes can handle the I/O statements and
  functions.

  Local I/O can read a file written by the base language and, vice
  versa.

  [F] A name of a global array in the I/O list describes the
  entire area of the array located in each node.

  An array element of a global array can be referred to as an I/O item only
  in the node where it is located.

  [F] Any array section of a global array cannot be referred to as an
  I/O item.

  \subsection{Master I/O[F]}

  Master I/O is input and output for the file that corresponds to an
  executing node set.
  Master I/O is collective execution.

  In master I/O, a global data is input and output as if it was executed
  only by a master node, which represents the executing node set, through
  its local copy of the data.

  The master node is chosen among the executing node set arbitrarily by the
  system, and is unique to the executing node set during execution of
  the program.

  Master I/O is provided in the form of directives of {\XMP} {\Fort}.

  A global array as an I/O item is accessed in the sequential order of
  array elements.
  When a local variable is read from a file, the value is copied to all
  nodes of the executing node set.
  When a local variable or an expression is written to a file, only the
  value of the data on the master node is written.
  
  Master I/O can read a file written by the base language, and vice
  versa.
  

  \subsection{Global I/O}

  Global I/O is input and output for the file that corresponds to
  an executing node set.
  Some executions of global I/O are collective and the others are independent.
  In a large system with many nodes, global I/O can be expected higher
  speed and less memory consumption execution than master I/O.

  [F] It is provided in the form of directives for a part of I/O
  statements, such as OPEN, CLOSE, READ
  and WRITE statements.

  [C] It is provided in the form of service functions and the include file.

  Global I/O can handle only unformatted (binary) files. In XcalableMP Fortran,
  implied DO loops and some specifiers cannot be used.
  In XcalableMP C, formatted I/O libraries, including fprintf() and fscanf(), are not provided.

  Global I/O can read a file written in MPI-IO, and vice versa. 

  [F] File formats are not compatible between XcalableMP Fortran
  and the base language because global I/O does not generate or access
  the file header and footer particular to the base language.

  There are three kinds of global I/O, as shown in Table
  \ref{tb:global}.
  {\bf Collective} global I/O is collective execution and
  sequential file access.
  It handles global data in the sequential order, similar to master
  I/O.
  {\bf Atomic} global I/O is independent execution and sequential file access.
  Executing nodes share file positioning of the global I/O file and
  execute each I/O statement and library call mutually.
  {\bf Direct} global I/O is independent execution and direct file access.
  Each executing node has its own file positioning and accesses a shared
  file independently.

  \begin{table}[tb]
   \begin{center}
    \caption{Global I/O}
    \label{tb:global}
    \begin{tabular}{|c||l|l|}
     \hline 
     & independent/collective & access method  \\ \hline \hline
     Collective I/O & collective & sequential access \\ \hline
     Atomic I/O & independent & sequential access \\ \hline
     Direct I/O & independent & direct access \\ \hline
    \end{tabular}
   \end{center}
  \end{table}
  
  \subsubsection*{Restriction}

  \begin{itemize}
   \item  The name of a global array may not be declared in a namelist
	  group.
	  That is, NAMELIST I/O is not allowed for global arrays.
  \end{itemize}

  \subsubsection*{Advice to programmers}

  Local I/O is useful for debugging focusing on a node since local I/O
  is executed on each node individually.

  Master I/O is a directive extension, in which the execution result
  matches the one of the base language ignoring directive lines.

  Global I/O aims for highly-parallel I/O using thousands of nodes.
  It is limited to binary files.
  It avoids extreme concentration of computational load and memory
  consumption to specific nodes using MPI-IO or other parallel I/O
  techniques.

  \section{File Connection}

  A file is connected to a unit in XcalableMP Fortran and to a file
  handler in XcalableMP C.
  This operation is called {\bf file connection}.
  Local I/O connects a file to each node independently.
  Master I/O and global I/O connect a file to an executing node set
  collectively.
  
  There are two ways of file connections, dynamic connection and
  preconnection.
  Dynamic connection connects a file during execution of the program.
  Preconnection connects a file at the beginning of execution of the
  program and therefore it can execute I/O statements and functions
  without the prior execution of an OPEN statement or a function call to
  open the file.

  \subsection{File Connection in Local I/O}

  The language processor of the base language connects the file to each
  node.
  It is implementation dependent which nodes can access the standard
  input, output and error files.
  It is also implementation dependent how the accesses to the files with the same name by multiple nodes behaves.
  The only primary node can access the standard input, output and error files.
  
  \if 0
  File system visible to each node is implementation dependent.

  It is implementation dependent which nodes can access the standard
  input, output and error files.
  It is also implementation dependent how the accesses to the same file by multiple nodes behave; e.g.
  , data in the standard input file may
  be read only by one node or may be replicated to all nodes.
  It is implementation dependent how data from the multiple nodes are
  merged into the standard output/error file.
  \fi

  \subsection{{\tt [F]} File Connection in Master I/O}

  An OPEN statement specified with a master I/O directive connects a
  file to the executing node set.
  When a master I/O file is connected by a READ statement or a WRITE
  statement without encountering any OPEN statement, the name and
  attributes of the file depend on the language system of the base
  language.
  Disconnection from a master I/O file is executed by a CLOSE statement
  or termination of the program.

  Dynamic connection must be executed collectively by all nodes sharing
  the file with the same unit number.
  Two executing node sets may employ the same unit number only if they
  have no common node.

  The standard input, output and error files are preconnected to the
  entire node set.
  Therefore, master I/O executed on the entire node set is always
  allowed without OPEN and CLOSE statements.


  \subsection{File Connection in Global I/O}

  Dynamic connection of global I/O is collective execution and
  is valid for the executing node set.
  Global I/O files cannot be preconnected.

  \subsubsection*{\tt [F]}

  An OPEN statement specified with a global I/O directive connects a
  file to the executing node set.
  Disconnection from a global I/O file is executed by a CLOSE statement
  or termination of the program.

  Dynamic connection must be executed collectively by all nodes sharing
  the file with the same unit number.
  Two executing node sets may employ the same unit number only if they
  have no common node.

  \subsubsection*{\tt [C]}

  A library function to open a global I/O file connects the file to the
  executing node set.
  Disconnection from a global I/O file is executed by a library function
  to close the file or termination of the program.

  \section{Master I/O}

%  \subsection*{Summary}
  A master I/O construct executes data transfer between a file and an
  executing node set via a master node of the executing node set.
  For a global array, the virtual sequential order of the array elements
  is visible.

  \subsection{\mio Construct}
  
  \subsection*{Syntax}
%  \Syntax{tasks}

  \begin{tabular}{ll}
   \verb![F]! & \verb|!$xmp| \mio \\
   & \hspace{5mm} {\it io-statement} \\
   & \\
   \verb![F]! & \verb|!$xmp| \mio begin \\
   & \hspace{5mm}{\it io-statement} \\
   & \hspace{5mm}... \\
   & \verb|!$xmp| \mio end \\
  \end{tabular}

   where {\it io-statement} is one of:

   \begin{itemize}
    \item OPEN statement
    \item CLOSE statement
    \item READ statement
    \item WRITE statement
    \item PRINT statement
    \item BACKSPACE statement
    \item ENDFILE statement
    \item REWIND statement
    \item INQUIRE statement
   \end{itemize}

   \subsection*{Restriction}
   \begin{itemize}
   \item The following items including a global array or a subobject of a global array must not appear in an input item or output item.
	  \begin{itemize}
 	   \item A substring-range
           \item A section-subscript
           \item An expression including operators
           \item An {\it io-implied-do-control}
	  \end{itemize}

    \item An I/O statement specified with a master I/O directive must be
	  executed collectively on the node set that is connected to the file.
    \item Internal file I/O is not allowed as master I/O.
   \end{itemize}
	  
  \subsection*{Description}

   An I/O statement specified with master I/O directive accesses a
   file whose format is the same as the one of the base language.
   The access, including connection, disconnection, input and output,
   file positioning, and inquiry, is collective and must be
   executed on the same node set as the one where the file was
   connected. 

   A master node, a unique node to an executing node set, is chosen by the
   language system.
   Master I/O works as if all file accesses were executed only on the master
   node.

   The operations for I/O items are summarized in Table \ref{tb:opforio}.

   \begin{table}[h]
    \begin{center}
    \caption{Operations for I/O}
    \label{tb:opforio}
     \begin{tabular}{|l|p{40mm}|p{80mm}|}
      \hline
      \multicolumn{1}{|c}{ }  & {\bf I/O item} & {\bf operation} \\
      \hline
      input item & name of global array & The data elements that are read 
	      from the file in the sequential order of array elements are distributed onto 
	      the global array on the node set. The file positioning increases by
	      the size of data. \\
      \cline{2-3}
      & array element of global array &  The data element that is read from the file
	      is copied to the element of the global array on the node to which it is mapped.
	      The file positioning increases by the size of data. \\
      \cline{2-3}
      & local variable & The data element that is read from the file is replicated to the
	      local variables on all nodes of the executing node
	      set. The file positioning increases by the size of data. \\
      \cline{2-3}
      & implied DO loop & For each input item, repeat the above operation. \\
      \hline
      output item & name of global array & The data elements of the
	      global array are collected and are written to the
	      file in the sequential order of array elements. The file
	      positioning increases by the size of data. \\
      \cline{2-3}
      & array element of global array &  The element of the global array is written to the file. A file position increases by the size of data. \\
      \cline{2-3}
      & local variable and expression & The value evaluated on the master node
	      is written to the file. The file positioning increases by
	      the size of data. \\
      \cline{2-3}
      & implied DO loop & For each output item, repeat the above operation. \\
      \hline
      \end{tabular}
     \end{center}
%    \caption{aaa}
    \label{tb:aaa}
   \end{table}

   Namelist input and output statements cannot treat global arrays.
   A namelist output statement writes the values on the master node to
   the file.
   In the namelist input, each item of the namelist is read from the
   file to the master node if it is recorded in the file.
   And then all items of the namelist are replicated onto all nodes of
   the executing node set from the master node even if some items are not read from the file.

   IOSTAT and SIZE specifiers and specifiers of the INQUIRE statement
   that can return values always return the same value among the
   executing node set.

   When a condition specified with ERR, END or EOR specifier is
   satisfied, all nodes of executing node set are branched together to
   the same statement.

   \subsubsection*{Advice to implementers}
   
   It is recommended to provide such a compiler option that local I/O
   statements (specified without directives) are regarded as master I/O
   statements (specified with \mio directives).

   
   \section{{\tt [F]} Global I/O}

   Global I/O performs unformatted data transfer and can be expected to be higher performance and lower memory consumption than master I/O.
%   Global I/O is restricted within unformatted (binary) files, but higher performance and lower memory consumption can be expected than master I/O.
   The file format is compatible with the one in MPI-IO.

   Global I/O consists of three kinds, collective I/O, atomic I/O, and
   direct I/O. 

   \subsection{Global I/O File Operation}

   \gio construct is defined as follows.

   \subsubsection*{Syntax}

   \begin{tabular}{ll}
   \verb![F]! & \verb|!$xmp| \gio [atomic / direct] \\
   & \hspace{5mm} {\it io-statement} \\
   & \\
   \verb![F]! & \verb|!$xmp| \gio [atomic / direct] begin \\
   & \hspace{5mm}{\it io-statement} \\
   & \hspace{5mm}... \\
   & \verb|!$xmp| end \gio \\
   \end{tabular}

   The first syntax is just a shorthand of the second syntax.

   \subsubsection*{Restriction}

   I/O statements and specifiers available for an {\it io-statement} are
   shown in the following table.
   Definition of each specifier is described in the specification of the base language. 

   Case of \gio construct without a direct clause:
   \begin{table}[h]
   \begin{center}
    \label{tb:globalstatement}
    \begin{tabular}{|c||l|}
      \hline
     I/O statement & available specifiers \\ \hline \hline
     OPEN & UNIT, IOSTAT, FILE, STATUS, POSITION, ACTION, ACCESS, FORM \\ \hline
     CLOSE & UNIT, IOSTAT, STATUS \\ \hline
     READ & UNIT, IOSTAT \\ \hline
     WRITE & UNIT, IOSTAT \\ \hline
    \end{tabular}
   \end{center}
   \end{table}

   Case of \gio construct with a direct clause:
   \begin{table}[h]
   \begin{center}
    \label{tb:globalstatement}
    \begin{tabular}{|c||l|}
      \hline
     I/O statement & available specifiers \\ \hline \hline
     OPEN & UNIT, IOSTAT, FILE, STATUS, RECL, ACTION, ACCESS, FORM \\ \hline
     CLOSE & UNIT, IOSTAT, STATUS \\ \hline
     READ & UNIT, REC, IOSTAT \\ \hline
     WRITE & UNIT, REC, IOSTAT \\ \hline
    \end{tabular}
   \end{center}
   \end{table}

   An input item and an output item of a data transfer statement with
   a \gio directive must be the name of a variable.
   
   \if 0
   Only the name of a variable (including global variable) can be specified 
   as the input item of READ statement specified with a \gio directive,
   but array element, array section,
   structure component, substring, and implied DO loop are not allowed as input items.

   Only the name of a global array
   and an expression excluding global array reference can be specified
   as the output item
   of WRITE statement specified with a \gio directive, 
   but an expression including global array
   reference and implied DO loop are not allowed as input items.
   \fi

   \subsubsection*{Description}

   Global I/O construct connects, disconnects, inputs and outputs the global I/O file,
   which is compatible with MPI-IO.

   The standard input, output and error files cannot be a Global I/O file.
   A Global I/O file cannot preconnect to any unit or any file handler,
   and must explicitly be connected by the OPEN statement specified with
   a \gio directive.

   The OPEN statement specified with a \gio directive is collective execution, and the file is shared among the executing node
   set.
   A file that has already been opened by another OPEN statement with
   a \gio directive cannot be reopen by an OPEN statement with or
   without a \gio directive before closing it.

   A global I/O file must be disconnected explicitly by a CLOSE
   statement specified with a \gio directive, otherwise the result of I/O
   is not guaranteed.
   The CLOSE statement specified with a \gio directive is a collective execution and must be executed by the same executing
   node set as the one where the OPEN statement is executed.

   Utilizable values of the specifiers in I/O statements are shown in the
   following table.
   Definitions of the specifiers are described in the specification of
   the base language.

   \begin{itemize}
   \item OPEN statement
   
   \begin{table}[h]
    \begin{center}
     \label{tb:globalopen}
     \begin{tabular}{|c||p{55mm}|p{70mm}|}
       \hline
       specifiers & value & default \\ \hline \hline
      UNIT & external file unit (scalar constant expression) & not omissible \\ \hline
      FILE & file name (scalar CHARACTER expression) & not omissible \\ \hline
      STATUS & 'OLD', 'NEW', 'REPLACE' or 'UNKNOWN' & 'UNKNOWN' \\ \hline
      POSITION & 'ASIS', 'REWIND' or 'APPEND' & 'ASIS' \\ \hline
      ACTION & 'READ', 'WRITE' or 'READWRITE' & processor dependent \\ \hline
      RECL & the value of the record length (scalar constant expression) & not omissible \\ \hline
      ACCESS & 'SEQUENTIAL' or 'DIRECT' & 'SEQUENTIAL' \\ \hline
      FORM & 'FORMATTED' or 'UNFORMATTED' & For direct access, UNFORMATTED. For sequential access, this specifier shall not be omitted. \\ \hline
     \end{tabular}
    \end{center}
   \end{table}

   POSITION is available only if the directive has no direct clause.
   RECL is available only if the directive has a direct clause.
   For direct I/O, the ACCESS specifier shall appear and the value shall be evaluated to DIRECT.
   For collective I/O and atomic I/O, the value of the ACCESS specifier shall be evaluated to SEQUENTIAL if this specifier appears.
   For collective I/O and atomic I/O, the FORM specifier shall appear and the value shall be evaluated to UNFORMATTED.
   For direct I/O, the value of the FORM specifier shall be evaluated to UNFORMATTED if this specifier appears.

   \item CLOSE statement
	  
   \begin{table}[h]
    \begin{center}
     \label{tb:globalopen}
     \begin{tabular}{|c||p{90mm}|l|}
        \hline
      specifiers & value & default \\ \hline \hline
      UNIT & external file unit (scalar constant expression)
      & not omissible. \\ \hline
      STATUS & 'KEEP' or 'DELETE'
	  & 'KEEP' \\ \hline
     \end{tabular}
    \end{center}
   \end{table}

    \item READ/WRITE statement

   \begin{table}[h]
    \begin{center}
     \label{tb:globalopen}
     \begin{tabular}{|c||p{90mm}|l|}
       \hline
      specifiers & value & default \\ \hline \hline
      UNIT & external file unit (scalar constant expression)
      & not omissible \\ \hline
      REC & the value of the number of record (scalar constant expression)
      & not omissible \\ \hline
     \end{tabular}
    \end{center}
   \end{table}

   REC is available only if the directive has a direct clause.
   
   \item When a scalar variable of default INTEGER is specified to IOSTAT, an
     error code is set to the specifiers.
	 
   \end{itemize}

   OPEN, CLOSE, READ and WRITE statements specified with \gio directives
   without atomic and direct clauses are called collective OPEN, collective
   CLOSE, collective READ, and collective WRITE statements respectively.
   These all statements are called collective I/O statements.

   OPEN, CLOSE, READ and WRITE statements specified with \gio directives
   with atomic clauses are called atomic OPEN, atomic CLOSE, atomic READ, and
   atomic WRITE statements respectively.
   These all statements are called atomic I/O statements.

   OPEN, CLOSE, READ and WRITE statements specified with \gio directives
   with direct clauses are called direct OPEN, direct CLOSE, direct READ, and
   direct WRITE statements respectively.
   These all statements are called direct I/O statements.

   The file connected by a collective, atomic or direct OPEN statement can
   be read/be written only by the same type of READ/WRITE statements.
   The file can be disconnected by the same type of a CLOSE statement.
   Different types of global I/O cannot be executed together for the same file or the
   same unit.
   For example, atomic I/O statements cannot be executed for the unit
   connected by a collective OPEN statement.

   \subsubsection{{\tt file\_sync\_all} Directive}
   Two data accesses conflict if they access the same absolute byte displacements of the same file and at least one is a write access.
   When two accesses to the same file conflict in direct or collective I/O,
   the following file\_sync\_all directive to the file must be executed.

   \subsubsection*{Syntax}

   \begin{tabular}{ll}
     \verb|!$xmp| {\tt file\_sync\_all}([UNIT=]file-unit-number) \\
      \\
   \end{tabular}

   The file\_sync\_all directive is an execution directive and
   collective to the nodes connected to the specified
   file-unit-number.
   The execution of a file\_sync\_all directive first synchronizes all
   the nodes connected to the specified file-unit-number, and then causes
   all previous writes to the file by the nodes to be transferred to
   the storage device.
   If some nodes have made updates to the file, then all such updates
   become visible to subsequent reads of the file by the nodes.

\if 0   
   \begin{itemize}
     \item BARRIER statement

   \begin{table}[h]
    \begin{center}
     \label{tb:globalopen}
     \begin{tabular}{|c||p{90mm}|l|}
       \hline
       specifiers & value & default \\ \hline \hline
       UNIT & external file unit (scalar constant expression)
       & not omissible. \\ \hline
     \end{tabular}
    \end{center}
   \end{table}

   \end{itemize}
\fi

   
   \subsection{Collective Global I/O Statement}

   Collective I/O statements read/write shared files and can handle global arrays.

   All collective I/O statements execute collectively.
   In collective I/O, all accesses to a file, such as connection, disconnection,
   input and output, must be executed on the same executing node set. 
   
   The operations for I/O items are summarized in the following table.

   \begin{table}[h]
    \begin{center}
     \begin{tabular}{|p{10mm}|l|p{100mm}|}
      \hline
      \multicolumn{1}{|c}{ }  & {\bf I/O item} & {\bf operation} \\ \hline
      input item & name of global array & The values read from a file are assigned to the elements of the global array.
      The file positioning seeks by the size of the data.
      \\ \cline{2-3}
      & local variable &  The values read from the file are replicated into the
	      local array on all executing nodes. The file positioning seeks by
	      the length of the data.
      \\ \hline
      output item & name of global array & The values of a global array are
      written to the file in the sequential order of the array elements.
      The file positioning seeks by the size of the data.
      \\ \cline{2-3}
      & local variable, expression & The values evaluated on a node arbitrarily selected by the language processor from the executing node set.
      The file positioning seeks by the size of the data.
      \\ \hline
      \end{tabular}
     \end{center}
%    \caption{aaa}
    \label{tb:aaa}
   \end{table}

\if 0
   If an axis of the global array is aligned to an axis of the template and they are not equal in length, the length of the axis of the global array is regarded as the length of the axis of the template. In the example below, array a is read/written in the collective I/O file as if it was declared as a(10,100).\\
   \begin{tabular}{ll}
     \verb|!$xmp| & \verb|template t(100)| \\
     & dimension a(10, 2:99) \\
     \verb|!$xmp| & \verb|align a(*,i) with t(i)| \\
   \end{tabular}
\fi
   
   \subsection{Atomic Global I/O Statement}

   Atomic I/O statements read/write shared files exclusively among executing nodes
   in arbitrary order.
   Because it is a nondeterministic parallel execution,
   the results can differ every execution time even for the same program.

   Atomic OPEN and CLOSE statements are executed collectively, while atomic
   READ and WRITE statements are executed independently.
   A file connected by an atomic OPEN statement can be disconnected only by an
   atomic CLOSE statement executed on the same executing node set.
   Atomic READ and WRITE statements can be executed on any single node of the
   same executing node set.

   Atomic READ and WRITE statements are exclusively executed.
   The unit of exclusive operation is a single READ statement or a single WRITE
   statement.

   The initial file positioning is determined by the POSITION specifier of
   the atomic OPEN statement.
   And then, the file positioning seeks in every READ and WRITE statement 
   by the length of the input/output data.


   \subsection{Direct Global I/O Statement}

   Direct I/O statements read/write shared files with specification of the
   file positioning for each node.

   Direct OPEN and CLOSE statements are executed collectively, while direct
   READ and WRITE statements are executed independently.
   A file connected by a direct OPEN statement can be disconnected only by a
   direct CLOSE statement executed on the same executing node set.
   Direct READ and WRITE statements can be executed on any single node of the
   same executing node set.
   
   Direct READ and WRITE statements read/write local data at the file positioning
   specified by the REC specifier independently independently.
   The file positioning is shifted from the top of the file by the product 
   of the specifiers RECL (of OPEN statement) and
   REC (of READ and WRITE statement). 

   In order to guarantee the order of direct I/O statements to the same file position, the file should be closed or the file\_sync\_all directive should be executed between these statements. Otherwise, the outcome of multiple accesses to the same file position, in which at least one is a write access, is implementation dependent.

   \if 0
   \textcolor{red}{
   Accessing to the same file position by READ/WRITE statements may not
   occur in the same order in a program. In order to guarantee the order
   of READ/WRITE specified, the file should be closed or the
   file\_sync\_all directive should be executed between these
   statements.
   }
   \fi
   
   \section{{\tt [C]} Global I/O Library}
   XcalableMP C provides some data types defined in the include file ``xmp.h'',
   a set of library functions with arguments of the data types, and
   built-in operators to get values of the data types from names of a variable, a template, etc..

   The following types are provided.

   \begin{itemize}
    \item xmp\_file\_t : file handle
%    \item xmp\_array\_t : mapping descriptor for a global array variable
    \item xmp\_rang\_t : descriptor of array section
   \end{itemize}

   The following library functions are provided.
   Collective function names end with \_all.

   \begin{itemize}
    \item global I/O file operation
    \begin{itemize}
     \item xmp\_fopen\_all : file open
     \item xmp\_fclose\_all : file close
     \item xmp\_fseek : setting (individual) file pointer
     \item xmp\_fseek\_shared\_all : setting shared file pointer
     \item xmp\_ftell : displacement of (individual) file pointer
     \item xmp\_ftell\_shared : displacement of shared file pointer
     \item xmp\_file\_sync\_all : file synchronization
    \end{itemize}
    \item collective I/O
    \begin{itemize}
     \item xmp\_file\_set\_view\_all : setting file view
     \item xmp\_file\_clear\_view\_all : initializing file view
     \item xmp\_fread\_all : collective read of local data
     \item xmp\_fwrite\_all : collective write of local data
     \item xmp\_fread\_darray\_all : collective read of global data
     \item xmp\_fwrite\_darray\_all : collective write of global data
    \end{itemize}
    \item atomic I/O
    \begin{itemize}
     \item xmp\_fread\_shared : atomic read
     \item xmp\_fwrite\_shared : atomic write
    \end{itemize}
    \item direct I/O
    \begin{itemize}
     \item xmp\_fread : direct read
     \item xmp\_fwrite : direct write
    \end{itemize}
   \end{itemize}

   
   \subsection*{Data type}

   The following data types are defined in include file xmp\_io.h.
   \begin{description}
    \item[xmp\_file\_t] A file handler.
	       It is connected to a file when the file is opened.
	       It has a shared file pointer and an individual file pointer
	       to point where to read/write data in the file.

	       A shared file pointer is a shared resource among all nodes of the node set
             that has opened the file. Atomic I/O uses a shared file pointer.
	       An (individual) file pointer is an individual resource on each node. 
	       Collective I/O and direct I/O use individual file pointers.
	       
	       These two file pointers are managed in the structure xmp\_file\_t, .
	       and can be controlled and referenced only through
	       the provided library functions.
\if 0
    \item[xmp\_array\_t] Mapping descriptor for a global array variable,
	       which includes distribution, alignment, and the shape of nodes array.

	       Mapping descriptor of global array A is obtained with
	       the following built-in operator:
	       
	       xmp\_array\_t xmp\_array\_of(A);
\fi

\item[xmp\_range\_t] Descriptor of array section, including
      lower bound, upper bound and stride for each dimension.
      Functions for operating the descriptor are shown in following table.
      The xmp\_allocate\_range() function is used to allocate memory.
      The xmp\_set\_range() function is used to set ranges of a array section.
      The xmp\_free\_range() function releases the memory for the descriptor.
   \end{description}

   \begin{table}[h]
    \begin{center}
      \begin{tabular}{|l|r|p{90mm}|}
      \hline
      {\bf function name}  & \multicolumn{2}{c|}{\bf xmp\_range\_t $*$xmp\_allocate\_range(n\_dim)}  \\ \hline \hline
      argument & int n\_dim & the number of dimensions \\ \hline
      return value & xmp\_range\_t$*$ & descriptor of array section. NULL is returned
	      when a program abend. \\ \hline
      \end{tabular}
     \end{center}
    \label{tb:aaa}
   \end{table}

   \begin{table}[h]
    \begin{center}
      \begin{tabular}{|l|r|p{90mm}|}
      \hline
          {\bf function name}  & \multicolumn{2}{c|}{\bf void xmp\_set\_range(rp, i\_dim, lb, length, step)}  \\ \hline \hline
          argument & xmp\_range\_t $*$rp  & descriptor \\ \cline{2-3}
          & int i\_dim & target dimension \\ \cline{2-3}
          & int lb & lower bound of array section in the dimension i\_dim \\ \cline{2-3}
          & int length & length of array section in the dimension i\_dim \\ \cline{2-3}
          & int step & stride of array section in the dimension i\_dim \\ \hline
      \end{tabular}
     \end{center}
%    \caption{aaa}
    \label{tb:aaa}
   \end{table}
\clearpage
   \begin{table}[h]
    \begin{center}
      \begin{tabular}{|l|r|p{90mm}|}
      \hline
      {\bf function name}  & \multicolumn{2}{c|}{\bf void xmp\_free\_range(rp)}  \\ \hline \hline
      argument & xmp\_range\_t $*$rp & descriptor of array section. \\ \hline
      \end{tabular}
     \end{center}
%    \caption{aaa}
    \label{tb:aaa}
   \end{table}
   
   \subsection{Global I/O File Operation}

   \subsubsection{xmp\_fopen\_all}
   xmp\_fopen\_all opens a global I/O file. Collective execution.
   
   \begin{table}[h]
    \begin{center}
      \begin{tabular}{|l|r|p{90mm}|}
      \hline
      {\bf function name}  & \multicolumn{2}{c|}{\bf xmp\_file\_t
      $*$xmp\_fopen\_all(fname, amode)}  \\ \hline \hline
      argument & const char $*$fname & file name \\ \cline{2-3}
      & const char $*$amode & equivalent to fopen of POSIX. combination
	      of ``rwa+'' \\ \hline
      return value & xmp\_file\_t$*$ & file structure. NULL is returned
	      when a program abend. \\ \hline
      \end{tabular}
     \end{center}
%    \caption{aaa}
    \label{tb:aaa}
   \end{table}

   File view is initialized, where file view is based on the MPI-IO vile view mechanism. The value of shared and individual file pointers depend on the value of amode.

   \begin{table}[h]
     \begin{center}
    \label{tb:xxx}
    \begin{tabular}{|c|p{120mm}|}
      \hline
     amode & intended purpose \\ \hline \hline
     r &  Open for reading only. File pointer points the beginning of
	 the file.\\ \hline
     r+ & Open an existing file for update (reading and writing). File
	 pointer points the beginning of the file. \\ \hline
     w &  Create for writing. If a file by that name already exists, it
	 will be overwritten. File pointer points the beginning of the file. \\ \hline
     w+ & Create a new file for update (reading and writing). If a file
	 by that name already exists, it will be overwritten. File
	 pointer points the beginning of the file. \\ \hline
     a & Append; open for writing at end-of-file or create for writing
	 if the file does not exist. File pointer points the end of the file. \\ \hline
     a+ & Open for append; open (or create if the file does not exist)
	 for update at the end of the file. File pointer points the
	 beginning of the file. \\ \hline
    \end{tabular}
   \end{center}
   \end{table}

   \subsubsection{xmp\_fclose\_all}
   xmp\_fclose\_all closes a global I/O file. Collective execution.

   \begin{table}[h]
    \begin{center}
     \begin{tabular}{|l|l|p{80mm}|}
      \hline
      {\bf function name}  & \multicolumn{2}{c|}{\bf int
      $*$xmp\_fclose\_all(fh)} \\ \hline \hline
      argument & xmp\_file\_t $*$fh & file structure \\ \hline
      return value & int & 0: normal termination \\
      &  & 1: abnormal termination. fh is NULL. \\
      &  & 2: abnormal termination. error in MPI\_File\_close. \\ \hline
      \end{tabular}
     \end{center}
%    \caption{aaa}
    \label{tb:close}
   \end{table}

   \subsubsection{xmp\_fseek}
   xmp\_fseek sets the individual file pointer in the file structure. Independent execution.

   \begin{table}[h]
    \begin{center}
     \begin{tabular}{|l|r|p{70mm}|}
      \hline
      {\bf function name}  & \multicolumn{2}{c|}{\bf int xmp\_fseek(fh,
      offset, whence)}  \\ \hline \hline
      argument & xmp\_file\_t $*$fh & file structure \\ \cline{2-3}
      & long long offset & displacement of current file view from
	      position of whence \\ \cline{2-3}
      & int whence & choose file position \\
      &  & SEEK\_SET: the beginning of the file \\ 
      &  & SEEK\_CUR: current position \\ 
      &  & SEEK\_END: the end of the file \\ \hline
      return value & int & 0: normal termination \\
      &  & an integer other than 0: abnormal termination \\ \hline
      \end{tabular}
     \end{center}
    \label{tb:aaa}
   \end{table}

   \subsubsection{xmp\_fseek\_shared}
   xmp\_fseek\_shared sets the shared file pointer in the file structure. Independent execution.

   \begin{table}[h]
    \begin{center}
     \begin{tabular}{|l|r|p{80mm}|}
      \hline
      {\bf function name}  & \multicolumn{2}{c|}{\bf int xmp\_fseek\_shared(fh,
      offset, whence)}  \\ \hline \hline
      argument & xmp\_file\_t $*$fh & file structure \\ \cline{2-3}
      & long long offset & displacement of current file view from
	      position of whence \\ \cline{2-3}
      & int whence & choose file position \\
      &  & SEEK\_SET: the beginning of the file \\ 
      &  & SEEK\_CUR: current position \\ 
      &  & SEEK\_END: the end of the file \\ \hline
      return value & int & 0: normal termination \\
      &  & an integer other than 0: abnormal termination \\ \hline
      \end{tabular}
     \end{center}
    \label{tb:aaa}
   \end{table}

   \subsubsection{xmp\_ftell}
   xmp\_ftell inquires the position of the individual file pointer in the file structure. Independent execution.

   \begin{table}[h]
    \begin{center}
     \begin{tabular}{|l|r|p{80mm}|}
      \hline
      {\bf function name}  & \multicolumn{2}{c|}{\bf long long
      xmp\_ftell(fh)} \\ \hline \hline
      argument & xmp\_file\_t $*$fh & file structure \\ \hline
      return value & long long & Upon successful completion, the
	      function shall open the file and return a non-negative
	      integer representing the lowest numbered unused file
	      descriptor. Otherwise, negative number shall be
	      returned. \\ \hline
      \end{tabular}
     \end{center}
%    \caption{aaa}
    \label{tb:aaa}
   \end{table}

   \subsubsection{xmp\_ftell\_shared}
   xmp\_ftell\_shared inquires the position of shared file pointer in the file structure. Independent execution.

   \clearpage
   \begin{table}[h]
    \begin{center}
     \begin{tabular}{|l|r|p{80mm}|}
      \hline
      {\bf function name}  & \multicolumn{2}{c|}{\bf long long
      xmp\_ftell\_shared(fh)} \\ \hline \hline
      argument & xmp\_file\_t $*$fh & file structure \\ \hline
      return value & long long & Upon successful completion, the
	      function shall open the file and return a non-negative
	      integer representing the lowest numbered unused file
	      descriptor. Otherwise, negative number shall be
	      returned. \\ \hline
      \end{tabular}
     \end{center}
%    \caption{aaa}
    \label{tb:aaa}
   \end{table}

   \subsubsection{xmp\_file\_sync\_all}
   xmp\_file\_sync\_all guarantees completion of access to the file from nodes sharing the file.
   Two data accesses conflict if they access the same absolute byte displacements of the same file and at least one is a write access.
   When two accesses A1 and A2 to the same file conflict in direct or collective I/O, an xmp\_file\_sync\_all to the file must be invoked between A1 and A2, otherwise the outcome of the accesses is undefined.   
   Collective execution.

   \begin{table}[h]
    \begin{center}
     \begin{tabular}{|l|r|p{80mm}|}
      \hline
      {\bf function name}  & \multicolumn{2}{c|}{\bf int
      xmp\_file\_sync\_all(fh)} \\ \hline \hline
      argument & xmp\_file\_t $*$fh & file structure \\ \hline
      return value & int & 0: normal termination \\
      &  & an integer other than 0: abnormal termination \\ \hline
      \end{tabular}
     \end{center}
%    \caption{aaa}
    \label{tb:aaa}
   \end{table}

   \subsection{Collective Global I/O Functions}

   Collective I/O is executed collectively but using the individual pointer.
   It reads/writes data from the position of the individual file pointer and moves the position
   by the length of the data.

   Before the file access, a file view is often specified. A file view, like a window to the file, 
   spans the positions corresponding to the array elements that each node owns. 
   For more details of file view, refer to the MPI 2.0 specification.

   \subsubsection{xmp\_file\_set\_view\_all}
   xmp\_file\_set\_view\_all sets a file view to the file. Collective execution.

   \begin{table}[h]
    \begin{center}
     \begin{tabular}{|l|r|p{70mm}|}
      \hline
      {\bf function name}  & \multicolumn{2}{c|}{\bf int xmp\_file\_set\_view\_all(fh,
      disp, desc, rp)} \\ \hline \hline
      argument & xmp\_file\_t $*$fh & file structure \\ \cline{2-3}
      & long long disp & displacement from the beginning of the file. \\ \cline{2-3}
      & xmp\_desc\_t desc & descriptor \\ \cline{2-3}
      & xmp\_range\_t $*$rp & range descriptor \\ \hline
      return value & int & 0: normal termination \\
      &  & an integer other than 0: abnormal termination \\ \hline
      \end{tabular}
     \end{center}
    \label{tb:aaa}
   \end{table}

   The file view of distributed $desc$ limited to range $rp$ is set into file structure $fh$.

   \subsubsection{xmp\_file\_clear\_view\_all}
   xmp\_file\_clear\_view\_all clears the file view. Collective execution.

   The positions of the shared and individual file pointers are set to
   disp and 
   the elemental data type and the file type are set to MPI\_BYTE.
   
   \begin{table}[h]
    \begin{center}
     \begin{tabular}{|l|r|p{80mm}|}
      \hline
      {\bf function name}  & \multicolumn{2}{c|}{\bf int xmp\_file\_clear\_view\_all(fh,
      disp)} \\ \hline \hline
      argument & xmp\_file\_t $*$fh & file structure \\ \cline{2-3}
      & long long disp & displacement from the beginning of the file. \\ \hline
      return value & int & 0: normal termination \\
      &  & an integer other than 0: abnormal termination \\ \hline
      \end{tabular}
     \end{center}
%    \caption{aaa}
    \label{tb:aaa}
   \end{table}

   \subsubsection{xmp\_fread\_all}
   xmp\_fread\_all reads the same data from the position of the shared file
   pointer onto the all executing nodes. Collective execution.

   \begin{table}[h]
    \begin{center}
     \begin{tabular}{|l|r|p{80mm}|}
      \hline
      {\bf function name}  & \multicolumn{2}{c|}{\bf size\_t
      xmp\_fread\_all(fh, buffer, size, count)}  \\ \hline \hline
      argument & xmp\_file\_t $*$fh & file structure \\ \cline{2-3}
      & void $*$buffer & beginning address of read variables \\ \cline{2-3}
      & size\_t size & the size of a read data element \\ \cline{2-3}
      & size\_t count & the number of read data elements \\ \hline
      return value & size\_t & Upon successful completion, return the size
	      of read data. Otherwise, negative number shall be
	      returned. \\ \hline
      \end{tabular}
     \end{center}
%    \caption{aaa}
    \label{tb:aaa}
   \end{table}

   \subsubsection{xmp\_fwrite\_all}
   xmp\_fwrite\_all writes individual data on the all executing nodes to the position of the shared file
   pointer. Collective execution.

   It is assumed that the file view is set previously. Each node writes its data into its own file view.

   \begin{table}[h]
    \begin{center}
     \begin{tabular}{|l|r|p{80mm}|}
      \hline
      {\bf function name}  & \multicolumn{2}{c|}{\bf size\_t
      xmp\_fwrite\_all(fh, buffer, size, count)}  \\ \hline \hline
      argument & xmp\_file\_t $*$fh & file structure \\ \cline{2-3}
      & void $*$buffer & beginning address of written variables \\ \cline{2-3}
      & size\_t size & the size of a written data element \\ \cline{2-3}
      & size\_t count & the number of written data elements \\ \hline
      return value & size\_t & Upon successful completion, return the size
      of written data. Otherwise, negative number shall be
      returned. \\ \hline
      \end{tabular}
     \end{center}
%    \caption{aaa}
    \label{tb:aaa}
   \end{table}

   \subsubsection{xmp\_fread\_darray\_all}
   xmp\_fread\_darray\_all reads data cooperatively to the global array from the position of the shared file pointer.

   \begin{table}[h]
    \begin{center}
     \begin{tabular}{|l|r|p{80mm}|}
      \hline
      {\bf function name}  & \multicolumn{2}{c|}{\bf size\_t
      xmp\_fread\_darray\_all(fh, desc, rp)} \\ \hline \hline
      argument & xmp\_file\_t $*$fh & file structure \\ \cline{2-3}
      & xmp\_desc\_t desc & descriptor \\ \cline{2-3}
      & xmp\_range\_t $*$rp & range descriptor \\ \hline
      return value & size\_t & Upon successful completion, return the size
	      of read data. Otherwise, negative number shall be
	      returned. \\ \hline
      \end{tabular}
     \end{center}
%    \caption{aaa}
    \label{tb:aaa}
   \end{table}

   Data is read from the file to distributed $desc$ limited to range $rp$.

   \subsubsection{xmp\_fwrite\_darray\_all}
   xmp\_fwrite\_darray\_all writes data cooperatively from the global array to the
   position of the shared file pointer.

   \begin{table}[h]
    \begin{center}
     \begin{tabular}{|l|r|p{80mm}|}
      \hline
      {\bf function name}  & \multicolumn{2}{c|}{\bf size\_t
      xmp\_fwrite\_darray\_all(fh, desc, rp)} \\ \hline \hline
      argument & xmp\_file\_t $*$fh & file structure \\ \cline{2-3}
      & xmp\_desc\_t desc & descriptor \\ \cline{2-3}
      & xmp\_range\_t $*$rp & range descriptor \\ \hline
      return value & size\_t & Upon successful completion, return the size
	      of read data. Otherwise, negative number shall be
	      returned. \\ \hline
      \end{tabular}
     \end{center}
%    \caption{aaa}
    \label{tb:aaa}
   \end{table}

   Data is written from distributed $desc$ limited to range $rp$ to the file.


   \subsection{Atomic Global I/O Functions}

   Atomic I/O is executed independently but using the shared pointer. 
   It exclusively reads/writes local data
   from the position of the shared file pointer and moves the position by the length of the data.

   Before atomic I/O is executed, the file view must be cleared.
   
   [Rationale]

   Though the file views must be the same on all processes in order to use the shared file pointer,
   xmp\_file\_set\_view\_all
   function may set different file views for all nodes.
   Thus, before atomic I/O is used, the file view must be cleared.

   \subsubsection{xmp\_fread\_shared}
   xmp\_fread\_shared exclusively reads local data form the position of the shared file
   pointer and moves the position by the length of the data.
   Independently execution.

   \begin{table}[h]
    \begin{center}
     \begin{tabular}{|l|r|p{80mm}|}
      \hline
      {\bf function name}  & \multicolumn{2}{c|}{\bf size\_t
      xmp\_fread\_shared(fh, buffer, size, count)}  \\ \hline \hline
      argument & xmp\_file\_t $*$fh & file structure \\ \cline{2-3}
      & void $*$buffer & beginning address of read variables \\ \cline{2-3}
      & size\_t size & the size of a read data element \\ \cline{2-3}
      & size\_t count & the number of read data elements \\ \hline
      return value & size\_t & Upon successful completion, return the size
	      of read data. Otherwise, negative number shall be
	      returned. \\ \hline
      \end{tabular}
     \end{center}
%    \caption{aaa}
    \label{tb:aaa}
   \end{table}

   \subsubsection{xmp\_fwrite\_shared}
   xmp\_fwrite\_shared exclusively writes local data to the
   position of the shared file pointer and moves the position by the length of the data.
   Independent execution.

   \begin{table}[h]
    \begin{center}
     \begin{tabular}{|l|r|p{80mm}|}
      \hline
      {\bf function name}  & \multicolumn{2}{c|}{\bf size\_t
        xmp\_fwrite\_shared(fh, buffer, size, count)} \\ \hline \hline
      argument & xmp\_file\_t $*$fh & file structure \\ \cline{2-3}
      & void $*$buffer & beginning address of written variables \\ \cline{2-3}
      & size\_t size & the size of a written data element \\ \cline{2-3}
      & size\_t count & the number of written data elements \\ \hline
      return value & size\_t & Upon successful completion, return the size
	      of written data. Otherwise, negative number shall be
	      returned. \\ \hline
      \end{tabular}
     \end{center}
%    \caption{aaa}
    \label{tb:aaa}
   \end{table}


   \subsection{Direct Global I/O Functions}

   Direct I/O is executed independently and using the individual pointer. 
   It individually reads/writes local data
   from the position of the individual file pointer and 
   moves the position by the length of the data taking account of the file view.

   In order to guarantee the order by xmp\_fread and xmp\_fwrite functions to the same file position, the file should be closed or the xmp\_file\_sync\_all function should be executed between these functions. Otherwise, the outcome of multiple accesses to the same file position, in which at least one is the xmp\_fwrite function, is implementation dependent.
   
   \if 0
   \textcolor{red}{
     Accessing to the same file position by READ/WRITE functions may not
     occur in the same order in a program. In order to guarantee the
     order of READ/WRITE specified, the file should be closed or the
     file\_sync\_all function should be executed between these functions.
     }
   \fi
   
   \subsubsection*{Advice to programmers}

   Function xmp\_fseek is useful to set the individual file pointer.
   It is not recommended using the file view together because of complexity.

   \subsubsection{xmp\_fread}
   xmp\_fread reads data from the position of the individual file
   pointer and moves the position by the length of the data.
   Independent execution.

   \begin{table}[h]
    \begin{center}
     \begin{tabular}{|l|r|p{80mm}|}
      \hline
      {\bf function name}  & \multicolumn{2}{c|}{\bf size\_t
      xmp\_fread(fh, buffer, size, count)} \\ \hline \hline
      argument & xmp\_file\_t $*$fh & file structure \\ \cline{2-3}
      & void $*$buffer & beginning address of read variables \\ \cline{2-3}
      & size\_t size & the size of a read data element \\ \cline{2-3}
      & size\_t count & the number of read data elements \\ \hline
      return value & size\_t & Upon successful completion, return the size
	      of read data. Otherwise, negative number shall be
	      returned. \\ \hline
      \end{tabular}
     \end{center}
%    \caption{aaa}
    \label{tb:aaa}
   \end{table}

   \subsubsection{xmp\_fwrite}
   xmp\_fwrite writes data to the position of the individual file
   pointer and moves the position by the length of the data.
   Independent execution.

   \begin{table}[h]
    \begin{center}
     \begin{tabular}{|l|r|p{80mm}|}
      \hline
      {\bf function name}  & \multicolumn{2}{c|}{\bf size\_t
      xmp\_fwrite(fh, buffer, size, count)} \\ \hline \hline
      argument & xmp\_file\_t $*$fh & file structure \\ \cline{2-3}
      & void $*$buffer & beginning address of written variables \\ \cline{2-3}
      & size\_t size & the size of a written data element \\ \cline{2-3}
      & size\_t count & the number of written data elements \\ \hline
      return value & size\_t & Upon successful completion, return the size
	      of written data. Otherwise, negative number shall be
	      returned. \\ \hline
      \end{tabular}
     \end{center}
%    \caption{aaa}
    \label{tb:aaa}
   \end{table}

   
