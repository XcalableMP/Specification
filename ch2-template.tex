\section{Template and data mapping}

\subsection{Template directive}
\subsubsection*{Synopsis}

The {\tt \Directive{template}} directive declares a template. 

\subsubsection*{Syntax}
\Syntax{template}

\begin{tabular}{ll}
\verb![F]! & \verb|!$xmp| {\it template-name} ( {\it template-spec} 
[, {\it template-spec} ] ... ) \\
& \\
\verb![C]! & \verb|#pragma xmp|  {\it template-name} ( {\it template-spec} 
[, {\it template-spec} ] ... ) \\
\end{tabular}
\vspace{0.3cm}

where {\it template-spec} must be one of:

\hspace{\hsize}

\begin{tabular}{ll}
 \hspace{0.5cm} & [{\it int-expr} {\tt :}] {\it int-expr} \\
 \hspace{0.5cm} & {\tt :} \\
\end{tabular}

\subsubsection*{Description}

The {\tt template} directive declares a template with the shape specified by
the sequence of {\it template-spec}. If all expressions in the sequence of
{\it template-spec} are ÅeÅe:", then the shape of the template is initially
undefined. This template must not be referenced until the shape is
defined by {\it template\_fix} directives at run-time. If {\it
  int-expr} is specified as {\it template-spec}, then the default lower bound
is 1. 

\subsubsection*{Restrictions}

\begin{itemize}
\item Each {\it template-spec} must be either all [{\it int-expr} {\tt :}] {\it
  int-expr}
 or all ÅeÅe:".
\end{itemize}

\subsection{Template reference}

\subsubsection*{Synopsis}

The template reference expression is
used to reference a subset of the referenced template.

\subsubsection*{Syntax}
\Syntax{template reference}

\begin{center}
\begin{tabular}{ll}
{\it template-ref} & {\it template-name} [ ( {\it template-subscript}
[,  ...] ) ] \\
{\it template-subscript} & {\it int-expr} | {\it triplet} | {\tt *} \\
\end{tabular}
\end{center}

\subsubsection*{Description}

The template reference refers to a subarray of the template array.  

The subscript
of the subarray of a template array must be either an integer, a triplet, or
ÅeÅe{\tt *}". The notation of the subarray using a triplet in the subscript is the same as
that in \Fort. 

\subsubsection*{Examples}

Assume that {\tt t} is a template name. 

\begin{itemize}
\item In the {\tt task} directive, a set of executing nodes is indirectly specified for the task.

\Example{task}
\begin{tabular}{l}
\verb|!$xmp task on t(1:m,1:n)| \\
\verb|!$xmp task on t| \\
\end{tabular}

\item In the {\tt loop} directive, an element of the template at which each loop iteration is aligned.

\Example{loop}
\begin{tabular}{l}
\verb|!$xmp loop (i) on t(i-1)| \\
\end{tabular}

\item In the {\tt array} directive, a template which the following array assignment statement is aligned with. 

\Example{array}
\begin{tabular}{l}
\verb|!$xmp array on t(1:n)| \\
\end{tabular}

\item In the {\tt barrier}, {\tt reduction}, and {\tt bcast} directives,
executing nodes are specified indirectly. 

\Example{barrier}
\Example{reduction}
\begin{tabular}{l}
\verb|!$xmp barrier on t(1:n)| \\
\verb|!$xmp reduction (+:a) on t(*,:)| \\
\verb|!$xmp bcast b from p(k) on t(1:n)| \\
\end{tabular}

\end{itemize}

\subsection{Distribute directive}

\subsubsection*{Synopsis}
The {\tt \Directive{distribute}} directive specifies a distribution of templates. 

\subsubsection*{Syntax}
\Syntax{distribute}

\begin{tabular}{ll}
\verb![F]! & \verb|!$xmp| {\tt distribute}{\it template-name} 
({\it dist-format}[,{\it dist-format}]... ) {\tt onto} {\it nodes-name} \\
& \\
\verb![C]! & \verb|#pragma xmp| {\tt distribute}{\it template-name} 
({\it dist-format}[,{\it dist-format}]... ) {\tt onto} {\it nodes-name} \\
\end{tabular}
\vspace{0.3cm}

where {\it dist-format} must be one of:

\begin{tabular}{ll}
 \hspace{0.5cm} & {\tt *} \\
 & {\tt block} \\
 & {\tt cyclic} [ ( {\it int-expr} ) ] \\
 & {\tt gblock} ( {\tt *} $\vert$ {\it int-array} ) \\
\end{tabular}

\subsubsection*{Description}

According to the specified
distribution format, a template is distributed onto a set of nodes. The
dimension of the node set appearing in an {\tt onto} clause corresponds, in
left-to-right order, with the dimension of the distributed template for
which the corresponding dist-format is not ÅeÅe*". 

The interpretation of dist-format is as follows:

\begin{description}
\item[{\tt *}]
The corresponding dimension is not distributed.

\item[{\tt block}]
The corresponding dimension of the template is
divided into contiguous blocks of the same size, which are distributed
onto the corresponding dimension of the node set. Let {\tt d} be the size of
the corresponding dimension of the template, and let {\tt p}be  the size of the
corresponding dimension of node sets. If {\tt d mod p} is not zero, then the
dimension of the template is divided into {\tt d/ceil(d/p)} blocks of size
{\tt ceil(d/p)} and one block of size {\tt d\%ceil(d/p)}, and each
block is assigned sequentially to an index along the corresponding
dimension of the node set. Note that
if {\tt k=p-d/ceil(d/p)-1 > 0}, then there is no block for the last
{\tt k} indices.

\item[{\tt cyclic}]
Equivalent to {\tt cyclic(1)}.

\item[{\tt cyclic(n)}]
The corresponding
dimension of the template is divided into contiguous blocks of 
size {\tt n}, and these blocks are distributed onto the corresponding
dimension of the node set in a round-robin manner.

\item[{\tt gblock(m)}]
{\tt m} is a mapping array. The corresponding dimension of the template is
divided into contiguous blocks so that the ith block is of size
{\tt m(i)}, and these blocks are 
distributed onto the corresponding dimension of the node set.
\end{description}

If more than one {\tt gblock(*)} is specified in {\it
  dist-format}, then the template must not be referenced until the shape of
the template is defined by {\it template\_fix} directives at run-time. 


\subsubsection*{Restrictions}

\begin{itemize}
\item The number of {\it dist-format}, which is not ÅeÅe*", must be equal to the
  rank of the node set specified by {\it nodes-name}.  
\item The array {\it int-array} in parentheses following {\tt gblock}
  must be an integer one-dimensional array, and its size must be equal
  to the size of the corresponding dimension of the node set.
\item The element of the {\it int-array} array in 
parentheses following {\tt gblock} must be a non-negative integer.
\item The sum of the elements of the {\it int-array} array in parentheses
  following {\tt gblock} must be equal to or greater than the size of the
  corresponding dimension of the template specified by {\it template-name}.
\end{itemize}

\subsubsection*{Examples}
\Example{nodes}
\Example{template}
\Example{distribute}

\begin{description}
\item[Example 1]
\hspace{\hsize}
\begin{Fexample}
      program main
!$xmp nodes p(8,5)
!$xmp template t(64,64,64)
!$xmp distribute t(*,cyclic,block) onto p
\end{Fexample}

The template {\tt t} is distributed in block format, as
shown in the following:

\begin{center}
\begin{tabular}{|c|c|}
\hline
{\tt p(1)} & {\tt t(1:16)} \\
\hline
{\tt p(2)} & {\tt t(17:32)} \\
\hline
{\tt p(3)} & {\tt t(33:48)} \\
\hline
{\tt p(4)} & {\tt t(49:64)} \\
\hline
\end{tabular}
\end{center}

\item[Example 2]
\hspace{\hsize}
\begin{Fexample}
      program main
!$xmp nodes p(4)
!$xmp template t(64)
!$xmp distribute t(cyclic(8)) onto p
\end{Fexample}

The template {\tt t} is distributed in a cyclic format of size eight, as
shown in the following:

\begin{center}
\begin{tabular}{|c|c|}
\hline
{\tt p(1)} & {\tt t(1:8) t(33:40)} \\
\hline
{\tt p(2)} & {\tt t(9,16) t(41:48)} \\
\hline
{\tt p(3)} & {\tt t(17,24) t(49:56)} \\
\hline
{\tt p(4)} & {\tt t(25,32) t(57:64)} \\
\hline
\end{tabular}
\end{center}

\item[Example 3]
\hspace{\hsize}
\begin{Fexample}
      program main
!$xmp nodes p(8,5)
!$xmp template t(64,64,64)
!$xmp distribute t(*,cyclic,block) onto p
\end{Fexample}

The first dimension of template
{\tt t} is not distributed. The second dimension is distributed onto the
first dimension of node set {\tt p} in cyclic format. The third
dimension is distributed onto the second dimension of node set {\tt p}
in block format. The results are as follows: 

\begin{center}
\begin{tabular}{|c|c|}
\hline
{\tt p(1)} & {\tt t(1:64, 1:57:8, 1:13)} \\
\hline
{\tt p(2)} & {\tt t(1:64, 2:58:8, 1:13)} \\
\hline
... & ... \\
\hline
{\tt p(4)} & {\tt t(1:64), 8:64:8, 53:64)} \\
\hline
\end{tabular}
\end{center}

where the size of the third dimension is 64 and is not divisible by the
size of the second dimension of {\tt p}. Then, the sizes of a number of blocks in the third
dimension are different. 

\end{description}

\subsection{Align directive}
\subsubsection*{Synopsis}
The {\tt \Directive{align}} directive specifies that arrays are to be mapped in
the manner given by a template.

\subsubsection*{Syntax}
\Syntax{align}

\begin{tabular}{ll}
\verb![F]! & \verb|!$xmp| {\tt align} {\it array-name}
( {\it align-source} [, {\it align-source}] ... ) \\
 & {\tt with} {\it template-name}
({\it align-subscript} [, {\it align-subscript}] ... ) \\
& \\
\verb![C]! & \verb|#pragma xmp| {\tt align} {\it array-name} 
{\tt [}{\it align-source}{\tt ]} [{\tt [}{\it align-source}{\tt ]}] ... \\
 & {\tt with} {\it template-name}
({\it align-subscript} [, {\it align-subscript}] ... ) \\
\end{tabular}
\vspace{0.3cm}

where {\it align-source} must be one of:

\begin{tabular}{ll}
 \hspace{0.5cm} & {\tt scalar-int-variable} \\
 & {\tt *} \\
 & {\tt :} \\
\end{tabular}
\vspace{0.3cm}

and {\tt align-subscript} must be one of:

\begin{tabular}{ll}
 \hspace{0.5cm} & {\tt scalar-int-variable} [ ( {\tt +} $\vert$ {\tt -} )
 {\it int-expr} ] \\
 & {\tt *} \\
 & {\tt :} \\
\end{tabular}
\vspace{0.3cm}

Note that the variable {\it scalar-int-variable} appearing in {\it
  align-source} is referred to as a ÅeÅe\Term{align dummy variable}". 

\subsubsection*{Description}
The array specified by {\it array-name} is
aligned with the template specified by {\it template-name}. Each element
indexed by the sequence of {\it align-source} is aligned with the element of
the template indexed by the sequence of {\it align-subscript}, where {\it align-source} and {\it align-subscript} are interpreted as follows:  

\begin{enumerate}
\item The first form of
{\it align-source} and {\it align-subscript} describes an align dummy variable and its (restricted) expression, respectively. The range of the align dummy
variable covers all valid index values in the corresponding
dimension of the array.
\item The second form ÅeÅe*" of {\it align-source} and {\it
    align-subscript} describes a dummy variable (not an align dummy
  variable) that does not appear anywhere in the directive.
\begin{itemize} 
\item The second form of the align-source is said to ÅeÅecollapse"
the corresponding dimension of the array. As a result, the index along the
corresponding dimension makes no difference in determining the alignment.
\item The second form of the align-subscript is said to ÅeÅereplicate"
the array. Each element of the array is replicated and aligned to
all index values in the corresponding dimension of the template.
\end{itemize}
\item Both {\it align-source} and {\it align-subscript} are ÅeÅe:",
  then each element of an array 
is aligned with each element of the template.
\end{enumerate}

\subsubsection*{Restrictions}

\begin{itemize}
\item In the sequence of {\it align-subscript}, the same align variable must not appear more than once. 
\item  In {\it align-subscript}, an align dummy variable must not appear more than once. 
\item  In {\it int-expr} of {\it align-subscript}, an align dummy variable must not appear.
\item  If either {\it align-source} or {\it align-subscript} is
  ÅeÅe:", then the corresponding {\it align-source} or 
{\it align-subscript} must be ÅeÅe:". 
\end{itemize}

\subsubsection*{Examples}
\Example{align}

\begin{description}
\item[Example 1]
\hspace{\hsize}
\begin{Fexample}
!$xmp align a(i) with t(i)
\end{Fexample}

The array element {\tt a(i)} is aligned with  the template element {\tt
  t(i)}. This is equivalent to the following:

\begin{Fexample}
!$xmp align a(:) with t(:)
\end{Fexample}

\item[Example 2]
\hspace{\hsize}
\begin{Fexample}
!$xmp align a(*,j) with t(j)
\end{Fexample}

The subarray {\tt a(:,j)} is aligned with the template
element {\tt (j)}. Note that the first dimension of {\tt a} is collapsed.

\item[Example 3]
\hspace{\hsize}
\begin{Fexample}
!$xmp align a(j) with t(*,j)
\end{Fexample}

The array element {\tt a(j)} is replicated and aligned with each
template element {\tt t(1,j) $\sim $ t(10,j)}. Assume that the upper and
lower bounds of the first dimension of the template {\tt t} are 1 and 10, respectively.

\item[Example 4]
\hspace{\hsize}
\begin{Fexample}
!$xmp template t(n1,n2)
      real a(m1,m2)
!$xmp align a(*,j) with t(*,j)
\end{Fexample}

The subarray {\tt a(:,j)} is aligned with each template
element, {\tt t(1,j) $\sim $ t(n1,j)}. 

If ÅeÅe*" in the first dimension of array {\tt a} is replaced by dummy
variable {\tt i}, and ÅeÅe*" in the first dimension of the template is
replaced by dummy variable {\tt k}, then we have:

$${a(i,j) \rightarrow t(k,j) | (i,j,k) \in (1:n1,1:n2,1:m1)}$$

\end{description}

\subsection{Shadow directive}
\subsubsection*{Synopsis}

The {\tt \Directive{shadow}} directive declares and allocates a shadow area for a
distributed array.

\subsubsection*{Syntax}
\Syntax{shadow}

\begin{tabular}{ll}
\verb![F]! & \verb|!$xmp| {\tt shadow} {\it array-name}
( {\it shadow-width} [, {\it shadow-width}] ... ) \\
& \\
\verb![C]! & \verb|#pragma xmp|  {\tt shadow} {\it array-name}
{\tt [}{\it shadow-width}{\tt ]} [{\tt [}{\it shadow-width}{\tt ]}] ... \\
\end{tabular}
\vspace{0.3cm}

where {\it shadow-width} must be one of:

\begin{tabular}{ll}
 \hspace{0.5cm} & {\it int-expr} \\
 & {\it int-expr} : {\it int-expr}\\
 & \verb|*|\\
\end{tabular}

\subsubsection*{Description}

The {\tt shadow} directive specifies the shadow width for which the area is used to communicate the neighbor element of the block of an array specified by {\it array-name}, which is distributed
onto each node. When {\it shadow-width} is of the form 
{\it int-expr} : {\it int-expr}, the shadow area is added at the upper and
lower bounds with the width specified in the specified dimension. When
{\it shadow-width} is a form of {\it int-expr}, the shadow area is added at the upper
and lower bounds with the same width specified in the specified
dimension. When shadow-width is of the form ÅeÅe\verb|*|", the entire area of the
array is allocated on each node, and all of the area that it does not own
is regarded as shadow. Note that this type of shadow is sometimes referred to as a ÅeÅefull shadow."

The data stored in the storage area declared by the {\tt shadow} directive is referred to as a
\Term{shadow object}. The shadow object can be explicitly defined and referenced
only by the method described below. Of the data allocated to a storage
area other than a shadow area, data representing the same array
element as that of a shadow object is referred to as a reflection source of
the shadow object. Conceptually, a shadow object and its reflection
source are not mapped to the same processor at the same time.
%A shadow
%object is not mapped to a processor to which its reflection source is
%mapped. 

\subsubsection*{Restrictions}

\begin{itemize}
\item The value specified by {\it shadow-width} must be a
non-negative integer. 
\end{itemize}

\subsection{\Directive{template\_fix} directive}
\subsubsection*{Synopsis}
This directive is an executable directive that fixes the shape of the template. 

\subsubsection*{Syntax}
\Syntax{template\_fix}

%\begin{tabular}{ll}
%\verb![F]! & \verb|!$xmp| {\tt template\_fix} {\it template-name} \\
% & [({\it template-spec} [, {\it template-spec}] ... )] \\
% & [, {\tt distribute} ( {\it dist-format} [, {\it dist-format}]... ) \\
%& \\
%\verb![C]! & \verb|#pragma xmp|  {\tt template\_fix} {\it template-name} \\
% & [({\it template-spec} [, {\it template-spec}] ... )] \\
% & [, {\tt distribute} ( {\it dist-format} [, {\it dist-format}] ...) \\
%\end{tabular}
\begin{tabular}{ll}
\verb![F]! & \verb|!$xmp| {\tt template\_fix} ( {\it dist-format} [,
 {\it dist-format}]... )\\
 & {\it template-name} [({\it template-spec} [, {\it template-spec}] ... )] \\
& \\
\verb![C]! & \verb|#pragma xmp|  {\tt template\_fix} ( {\it dist-format}
     [, {\it dist-format}] ...)\\
 & {\it template-name} [({\it template-spec} [, {\it template-spec}] ... )] \\
\end{tabular}
\vspace{0.3cm}

where {\it template-spec} is:

\begin{tabular}{ll}
 \hspace{0.5cm} & [{\it int-expr} :] {\it int-expr} \\
\end{tabular}
\vspace{0.3cm}

where {\it dist-format} is one of:

\begin{tabular}{ll}
 \hspace{0.5cm} & {\tt *} \\
 & {\tt block} \\
 & {\tt cyclic} [( {\it int-expr} )] \\
 & {\tt gblock} ( {\it int-array} ) \\
\end{tabular}

\subsubsection*{Description}

The {\tt template\_fix} directive is an executable directive to fix the
shape of the template, which is initially undefined, by specifying the
sizes of each dimension and the distribution format at run-time. The array
aligned to an initially undefined template must be an allocatable
array, which cannot be allocated until the template is fixed by the
{\tt template\_fix} directive. Any executable directives that have such a
template in their {\tt on} clause must not be executed before the
template is fixed by the
{\tt template\_fix} directive. Any undefined template can be fixed only
once by the {\tt template\_fix} directive. 

Note that the meaning of
{\it dist-format} in the {\tt distribute} clause is the same as that in
the {\tt distribute} directive.

\subsubsection*{Restrictions}
\begin{itemize}
\item When the {\tt template\_fix} directive is executed, the
template specified by template-name must be undefined.
\item The sequence
of {\it dist-format} in the {\tt template\_fix} directive and the sequence
of {\it dist-format} in the {\tt distribute} directive specified by
{\it template-name} must be identical, except for the brackets following {\tt
  gblock}. 
\item The sequence of either the {\it template-spec} or {\tt distribute}
  clause must be given. 
\item The {\tt template\_fix} directive must appear in executable context.
\end{itemize}

\subsubsection*{Example}
\Example{template}
\Example{distribute}
\Example{align}
\Example{template\_fix}

\begin{Fexample}
!$xmp template :: t(:)
!$xmp distribute (gblock(*)) :: t

      real , allocatable :: a(:)
!$xmp align (i) with t(i) :: a
      ...
      N = ...; M(...) = ...
      ...
!$xmp template_fix(gblock(M)) t(N)
      ...
      allocate (a(N))
\end{Fexample}

Since the shape is {\tt (:)} and the distribution format is {\tt gblock(*)},
the template {\tt t} is initially undefined. The allocatable array
{\tt a} is aligned to {\tt t}. After the size {\tt N} of {\tt t} and the mapping array {\tt M} is defined, {\tt t} is fixed by the {\tt template\_fix} directive, and {\tt a} is allocated.
