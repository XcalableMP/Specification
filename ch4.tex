%\chapter{Procedure call and data mapping for procedure argument}
\chapter{Procedure Interfaces}

This chapter describes the procedure interfaces, that is, how
procedures are invoked and arguments are passed, in {\XMP}.

In order to achieve high composability of {\XMP} programs, it is one of
the most important requirement that {\XMP} procedures can invoke
procedures written in the base language with as a few restrictions as
possible. The procedure interfaces in {\XMP} is designed so as to
satisfy the requirement.


\section{General Rule}

In {\XMP}, a procedure invocation itself is a local operation and does
not cause any communication or synchronization at runtime. Thus, a node
can invoke any procedure, whether written in {\XMP} or in the base
language, at any point of the execution.
%
There is no restriction on the characteristics of procedures invoked by
an {\XMP} procedure, except for a few ones on its argument, which is
explained below.

A local data or part of it (i.e. an array element or a Fortran's array
section) in the actual or dummy argument list (referred to as a {\it
local actual argument} and a {\it local dummy argument}, respectively)
are treated by the {\XMP} compiler in the same manner as by the compiler
of the base language.
%
This rule makes it possible that a local actual argument in a procedure
written in {\XMP} is associated with a dummy argument of a procedure
written in the base language.


\paragraph{Implementation.}

The {\XMP} compiler does not transform either local actual or dummy
arguments, so that the backend compiler of the base language can treat
them in its usual way.

\vspace{1.5zw}

\hspace{-1.2\parindent}
The rest of this chapter specifies how global data (or part of it)
appearing as an actual and a dummy argument list (referred to as a {\it
global actual argument} and a {\it global dummy argument}, respectively)
are processed by the {\XMP} compiler.


\section{Argument Passing Mechanism in {\XMP} Fortran}

Any section (except for an element) of a global data may not be put in
the actual argument list. Therefore only the name or an element of it
may be put in the actual argument list.

There are two kinds of argument association for global data in {\XMP}
Fortran: one is {\it sequence association}, which is for a global dummy
that is an explicit-shape or assumed-size array, and the other is
{\it descriptor association}, which is for all other global dummy.


\subsection{Sequence Association of Global Data}

The concept of sequence association in {\Fort} is extended for global
actual and dummy arguments in {\XMP} as follows.

If the actual argument is the name of a global data, it represents a
element sequence consisting of the elements of its local section in
Fortran's array element order on each node.
%
Also, if the actual argument is an element of a global data, it
represents an element sequence consisting of the corresponding element
in the local section and each element that follows it in array element
order on each node.

An global actual argument that represents a element sequence and
corresponds to a global dummy argument is sequence associated with
the the dummy argument if the dummy argument is an explicit-shape or
assumed-size array.
%
According to the (extended) sequence association rule, each element of
the element sequence represented by the global actual argument is
associated with the element of the local section of the global dummy
argument that has the same position in array element order.

Sequence association is the default rule of association for global
actual arguments and therefore is applied unless it is obvious from the
interface of the invoked procedure that the corresponding dummy argument
is neither an explicit-shape nor assumed-size array.


\paragraph{Implementation.}

In order to implement sequence association, the name or an element
of a global data appearing as an actual argument is treated by the
{\XMP} compiler as the base address of its local section on each node,
and the global data appearing as the corresponding dummy argument is
initialized at runtime so as to be composed of the local sections each
of which starts from the received address.
%
On a node that does not have the local section corresponding to the
actual argument, an unspecified value (e.g. null) is passed as the base
address.

Such implementation implies that in many cases, in order to associate
properly a global actual argument with the global dummy argument, their
mappings (including their shadow attributes) must be identical.


\subsubsection*{Examples}
\Example{procedure}

\begin{description}

\item[Example 1]

	   Both the actual argument {\tt a} and the dummy argument {\tt
	   x} are global explicit-shape arrays, and therefore {\tt
	   a} is sequence associated with {\tt x}.

	   It is the base address of the local section of {\tt a} that
	   passed between these subroutines on each node. Each the local
	   section of {\tt x} starts from the received address (Figure
	   \ref{fig5.1}).

\begin{Fexample}
      subroutine xmp_sub1
!$xmp nodes p(4)
!$xmp template t(100)
!$xmp distribute t(block) onto p
      real a(100)
!$xmp align a(i) with t(i)
!$xmp shadow a(1:1) 
      call xmp_sub2(a)
      end subroutine

      subroutine xmp_sub2(x)
!$xmp nodes p(4)
!$xmp template t(100)
!$xmp distribute t(block) onto p
      real x(100)
!$xmp align x(i) with t(i)
!$xmp shadow x(1:1) 
      ...
\end{Fexample}

\begin{myfigure}
 \includegraphics[scale=0.7]{figs/fig5.1.eps}
 \caption{Sequence Association with a Global Dummy Argument}
 \label{fig5.1}
\end{myfigure}

\item[Example 2]

	   The actual argument {\tt a} is a global explicit-shape array,
	   and the dummy argument {\tt x} is a local explicit-shape. 
	   Sequence association is applied also in this case.

	   The caller subroutine {\tt xmp\_sub1} passes the base address
	   of the local section of {\tt a} on each node, and the callee
	   {\tt f\_sub2} receives it and initializes each the local
	   section of {\tt x} with the storage starting from it (Figure
	   \ref{fig5.2}).

\begin{Fexample}
      subroutine xmp_sub1
!$xmp nodes p(4)
!$xmp template t(100)
!$xmp distribute t(block) onto p
      real a(100)
!$xmp align a(i) with t(i)
!$xmp shadow a(1:1) 
      call f_sub2(a)
      end subroutine
\end{Fexample}
\begin{Fexample}
      subroutine f_sub2(x)
      real x(27)
      ...
\end{Fexample}

\begin{myfigure}
 \includegraphics[scale=0.7]{figs/fig5.2.eps}
 \caption{Sequence Association with a Local Dummy Argument}
 \label{fig5.2}
\end{myfigure}

\item[Example 3]

	   The actual argument {\tt a(1)} is an element of the global
	   data, and the dummy argument {\tt x} is a local
	   explicit-shape array. Sequence association is applied 
	   in this case, but the value to be passed is unspecified on 
	   the nodes {\tt p(2)}, {\tt p(3)} and {\tt p(4)} because they
	   does not own the actual argument {\tt a(1)}.

	   As a result, the storage for {\tt x} in {\tt f\_sub2} may be
	   unavailable on the nodes {\tt p(2)}, {\tt p(3)} and {\tt
	   p(4)} (Figure \ref{fig5.3}).

\begin{Fexample}
      subroutine xmp_sub1
!$xmp nodes p(4)
!$xmp template t(100)
!$xmp distribute t(block) onto p
      real a(100)
!$xmp align a(i) with t(i)
!$xmp shadow a(1:1) 
      call f_sub2(a(1))
      end subroutine
\end{Fexample}
\begin{Fexample}
      subroutine f_sub2(x)
      real x(25)
      ...
\end{Fexample}

\begin{myfigure}
 \includegraphics[scale=0.7]{figs/fig5.3.eps}
 \caption{Sequence Association of an Element of a Global Data as an
 Actual Argument with a Local Dummy Argument}
 \label{fig5.3}
\end{myfigure}

\item[Example 4]

	   Even if either the global actual or dummy argument has a full
	   shadow, the sequence association rule is the same in
	   principle. Hence, the base address of the local section of
	   {\tt a} is passed between these subroutines on each node, and
	   each the local section of {\tt x} starts from the received
	   address (Figure \ref{fig5.4}).

\clearpage

\begin{myfigure}
 \includegraphics[scale=0.7]{figs/fig5.4.eps}
 \caption{Sequence Association with a Global Dummy Argument that Has
 Full Shadow)}
 \label{fig5.4}
\end{myfigure}

\end{description}


\subsection{Descriptor Association of Global Data}

When the actual argument is a global data and it is obvious from the
interface of the invoked procedure that the corresponding dummy argument
is neither an explicit-shape nor assumed-size array, the actual
argument is {\it descriptor associated} with the dummy
argument. According to descriptor association, the dummy argument 
inherits its shape and storage from the actual argument.

\paragraph{Implementation.}

In order to implement the descriptor association, a global actual
argument is treated by the {\XMP} compiler as:

\begin{itemize}
 \item its {\it global-data descriptor}, which is an internal data
       structure managed by the {\XMP} runtime system to hold
       information on a global data, if the dummy is a global data; or
 \item the array representing its local section, which is to be processed
       by the backend Fortran compiler in the same manner as usual data,
       if the dummy is a local data.
\end{itemize}

For the first case, a global dummy is initialized at runtime with a copy
of the global-data descriptor received.

When an actual argument is descriptor associated with the dummy argument
and their mappings are not identical, the {\XMP} runtime system may
detect and report the error.

\subsubsection*{Examples}
\Example{procedure}

\begin{description}

\item[Example 1]

	   There is the explicit interface of the subroutine
	   {\tt xmp\_sub2} specified by an interface block in the
	   subroutine {\tt xmp\_sub1}, from which it is found that the
	   dummy argument {\tt x} is a global assumed-shape
	   array. Therefore the global actual argument {\tt a} is
	   descriptor associated with the global dummy argument {\tt
	   x}.

	   It is the global-data descriptor of {\tt a} that passed
	   between these subroutines. The dummy argument {\tt x} is
	   initialized by the {\XMP} runtime system on the basis of the
	   information extracted from the descriptor received (Figure
	   \ref{fig5.5}).

\begin{Fexample}
      subroutine xmp_sub1

!$xmp nodes p(4)
!$xmp template t(100)
!$xmp distribute t(block) onto p
      real a(100)
!$xmp align a(i) with t(i)
!$xmp shadow a(1:1)

      interface
      subroutine xmp_sub2(x)
!$xmp nodes p(4)
!$xmp template t(100)
!$xmp distribute t(block) onto p
      real x(:)
!$xmp align x(i) with t(i)
!$xmp shadow a(1:1)
      end subroutine xmp_sub2
      end interface

      call xmp_sub2(a)

      end subroutine

      subroutine xmp_sub2(x)
!$xmp nodes p(4)
!$xmp template t(100)
!$xmp distribute t(block) onto p
      real x(:)
!$xmp align x(i) with t(i)
!$xmp shadow a(1:1)
      ...
\end{Fexample}

\begin{myfigure}
 \includegraphics[scale=0.7]{figs/fig5.5.eps}
 \caption{Descriptor Association with a Global Dummy Argument}
 \label{fig5.5}
\end{myfigure}

\item[Example 2]

	   There is the explicit interface of the subroutine
	   {\tt f\_sub2}, which is written in the base language Fortran,
	   specified by an interface block in the subroutine {\tt
	   xmp\_sub1} and the dummy argument {\tt x} is a local
	   (i.e. non-mapped) assumed-shape array. Therefore the global
	   actual argument {\tt a} is descriptor associated with the
	   local dummy argument {\tt x}.

	   The global dummy argument is replaced with its local section
	   by the {\XMP} compiler and the association of the local
	   section with the dummy argument is to be processed by the
	   backend Fortran compiler in the same manner as usual data 
	   (Figure \ref{fig5.6}).

\begin{Fexample}
      subroutine xmp_sub1

!$xmp nodes p(4)
!$xmp template t(100)
!$xmp distribute t(block) onto p
      real a(100)
!$xmp align a(i) with t(i)
!$xmp shadow a(1:1) 

      interface
      subroutine f_sub2(x)
      real x(:)
      end subroutine f_sub2
      end interface

      call f_sub2(a)

      end subroutine
\end{Fexample}
\begin{Fexample}
      subroutine f_sub2(x)
      real x(:)
      ...
\end{Fexample}

\begin{myfigure}
 \includegraphics[scale=0.7]{figs/fig5.6.eps}
 \caption{Descriptor Association with a Local Dummy Argument}
 \label{fig5.6}
\end{myfigure}

\end{description}


\section{Argument Passing Mechanism in {\XMP} C}

When the actual argument is a global data, it is passed by the address
of its local section.
%
When the dummy argument is a global data, an address is received and
used as the base address of each its local section.


\paragraph{Implementation.}

The name of a global data appearing as an actual argument is
treated by the {\XMP} compiler as the pointer to the first element of
its local section on each node.
%
On a node onto which no part of the global data is mapped, the pointer
is set to an unspecified value (e.g. null).
%
Note that an element of a global data in the actual argument list is
treated in the same manner as those in other usual statements because an
array element is passed by value as in C.

The name of a global data appearing as a dummy argument is
treated by the {\XMP} compiler as the pointer to the first element of
its local section on each node.
%
As a result, the global data is initialized at runtime so as to be
composed of the local sections on nodes in the executing node set.

Such implementation implies that in many cases, in order to pass
properly a global actual argument to the corresponding global dummy 
argument, their mappings (including their shadow attributes) must be
identical.

\subsubsection*{Examples}
\Example{procedure}

\begin{description}

\item[Example 1]

	   The global actual argument {\tt a} is treated by the {\XMP}
	   compiler as the pointer to the first element of its local
	   section, which is passed to the callee, on each node.

	   The global dummy argument {\tt x} is initialized so that each
	   the local section of it starts from the address held by the
	   received pointer (Figure \ref{fig5.7}).

\begin{Cexample}
void xmp_func1()
{
#pragma xmp nodes p(4)
#pragma xmp template t(0:99)
#pragma xmp distribute t(block) onto p
  float a[100];
#pragma xmp align a[i] with t(i)
#pragma xmp shadow a[1:1]

  xmp_func2(a);
}

void xmp_func2(float x[100])
{
#pragma xmp nodes p(4)
#pragma xmp template t(0:99)
#pragma xmp distribute t(block) onto p
#pragma xmp align x[i] with t(i)
#pragma xmp shadow a[1:1]
  ...
\end{Cexample}

\clearpage

\begin{myfigure}
 \includegraphics[scale=0.7]{figs/fig5.7.eps}
 \caption{Passing to a Global Dummy Argument}
 \label{fig5.7}
\end{myfigure}

\item[Example 2]

	   The global actual argument {\tt a} is treated by the {\XMP}
	   compiler as the pointer to the first element of its local
	   section, which is passed to the callee, on each node.

	   The local dummy argument {\tt x} on each node starts from the 
	   address held by the received pointer (Figure \ref{fig5.8}).

\begin{Cexample}
void xmp_func1()
{
#pragma xmp nodes p(4)
#pragma xmp template t(0:99)
#pragma xmp distribute t(block) onto p
  float a[100];
#pragma xmp align a[i] with t(i)
#pragma xmp shadow a[1:1]

  c_func2(a);
}
\end{Cexample}
\begin{Cexample}
void c_func2(float x[27])
{
  ...
\end{Cexample}

\begin{myfigure}
 \includegraphics[scale=0.7]{figs/fig5.8.eps}
 \caption{Passing to a Local Dummy Argument}
 \label{fig5.8}
\end{myfigure}

\item[Example 3]

	   The actual argument {\tt a[0]} is an element of the global
	   data and the dummy argument {\tt x} is a scalar, in which
	   case the normal argument-passing rule of {\C} for variables a
	   basic type (i.e. ``pass-by-value'') is applied. However, the
	   value to be passed is unspecified on the nodes {\tt p(2)},
	   {\tt p(3)} and {\tt p(4)} because they does not own the
	   actual argument {\tt a[0]}.

	   As a result, {\tt x} in {\tt c\_func2} has an unspecified
	   value on the nodes {\tt p(2)}, {\tt p(3)} and {\tt p(4)}
	   (Figure \ref{fig5.9}).

\begin{Cexample}
void xmp_func1()
{
#pragma xmp nodes p(4)
#pragma xmp template t(0:99)
#pragma xmp distribute t(block) onto p
  float a[100];
#pragma xmp align a[i] with t(i)
#pragma xmp shadow a[1:1]

  c_func2(a[0]);
}
\end{Cexample}
\begin{Cexample}
void c_func2(float x)
{
  ...
\end{Cexample}

\begin{myfigure}
 \includegraphics[scale=0.7]{figs/fig5.9.eps}
 \caption{Passing an Element of a Global Data as an Actual Argument to a
 Local Dummy Argument}
 \label{fig5.9}
\end{myfigure}

\end{description}

