\chapter{Support for the Local-view Programming}
\label{chap:Support for the Local-view Programming}

%{\XMP} adopts coarray features for the local-view
%programming. Particularly in {\XMPF}, the features are compatible with
%that of Fortran 2008.
%We refer to the ISO/IEC 1539-1:2010 as the Fortran 2008 standard.

The coarray features in Fortran 2008 are extended and integrated into
XcalableMP. The specifications in this chapter are designed to achieve
the following purposes:

\begin{itemize}
 \item Upward compatibility to the Fortran 2008 coarray features\\
If an {\XMPF} program does not contain any XMP directives,
any standard-conforming Fortran 2008 program
remains standard-conforming under XcalableMP.
In this sense, the interpretations and extensions defined in this
 chapter are upward compatible with the Fortran International Standard, ISO/IEC 1539-1:2010 (Fortran 2008).

 \item Support for task parallelism \\
       XcalableMP makes it possible to construct a task parallel program by
       combining multiple Fortran 2008 codes, which might be developed
       independently, with minimum modifications.

 \item Integration of global-view style programming and local-view style programming\\
       In XcalableMP, users can use global-view style programming of
       XcalableMP or local-view style programming, which is typically
       used in MPI or Fortran 2008 programs, appropriately according to
       the characteristics of code in a program.

 \item Possibility of the support for multiple topologies of a computing system\\
       An XcalableMP processor may allow users to specify the correspondence between 
       node arrays and the topologies of a computing system and
       exploit the full potential of a particular system.

\end{itemize}


\section{Rules Determining Image Index}
%An image is an instance of an XcalableMP program.
%A node array is a set of nodes, whose individual elements are arranged
%in a rectangular pattern.
%Each node or each element of an instance of a node array
%uniquely corresponds to an image.
This section defines how the image index of an image in a set of images
is determined in association with a node array and a TASK directive construct.



\subsection{Primary image index}
Every image has a default image index in all the images at the
invocation of a program. 
In XcalableMP, the default image index is the primary image index
and is an integer value in the range one to the number of images
at the invocation of a program. 

%\subsection{Primary node array}
%A primary node array is a node array declared with ``=**'' in a NODES directive.
A primary node array corresponds to all the images at the invocation of
a program, and also corresponds to all the nodes at the invocation of
a program.
The primary image index of an image is the (Fortran) subscript order value of 
the uniquely corresponding element of a primary node array.
%The primary node number of a node is also the (Fortran) subscript order value of 
%the uniquely corresponding element of a primary node array.


\subsection{Image index determined by a {\itshape task-directive}}

Execution of a {\itshape task-directive} determines that a set of nodes (and
the corresponding set of images) forms an executing node set.
If a name of a node array or a subobject of a node array 
appears in the {\itshape task-directive}, the nodes and the corresponding 
images in the executing node set are ordered in (Fortran) array element order in
the node array or the subobject of the node array.
If a name of a template array or a subobject of a template array
appears in the {\itshape task-directive}, the nodes and the corresponding images 
in the executing node set 
are ordered in (Fortran) array element order in the corresponding 
subobject of the node array.
The image index of an image in the determined set of images 
is the integer order value in the range one to the cardinality of the set of images.
%The node number of a node in the determined set of nodes
%is the integer order value in the range one to the cardinality of the set of nodes.


\subsection{Current image index}

%The current set of images is a set of images 
%determined by the most lately executed {\itshape task-directive} in the
%TASK directive constructs that are not completed
%if any TASK directive constructs are being executed.
The image index of an image in the current set of images is
the current image index.

A current executing node array corresponds to the 
current set of images and also the current executing node set 
at the evaluation of the declaration of the node array.
Each image in the current set of images corresponds 
to the element of an executing node array whose
subscript order value is the same as the current image index
of the image at the evaluation of the declaration of the executing node array.
In particular, when there are no TASK directive constructs that are not
completed, the current image index of an image is the same as the
primary image index.

%The current set of images corresponds to 
%primary node arrays and all the nodes at the invocation of a program
%if there are no TASK directive constructs that are not completed.


\subsection{Image index determined by a non-primary node array}
%\subsection{Non-primary node array}

%A non-primary node array is a node array declared without ``={\it node-ref}'', ``=**'', or ``=*''
%in a NODES directive.

A non-primary node array corresponds to all the images at the invocation of
a program, and also corresponds to all the nodes at the invocation of
a program. The correspondence between each image and 
each element of a non-primary node array is processor-dependent.
A processor may support any means to specify the correspondence.

The image index of an image in all the images at the invocation 
of a program is the subscript order value of the corresponding element of
a non-primary node array if and only if the current set of images
corresponds to the non-primary node whole array in which
the nodes in the executing node set are ordered in (Fortran) array element order in the non-primary node whole array.
The image index is a non-primary image index. 

The correspondence between the primary image index and a non-primary image
index of the same image is processor-dependent.
Between any two distinct non-primary node arrays, 
the correspondence between a non-primary image index 
and the other non-primary image index of the same image is
processor-dependent unless they have the same shape. 
If two non-primary node arrays have the same shape,
the corresponding elements of the node arrays correspond
to the same image.


%\subsection{Executing node array}
%An executing node array is a node array declared with ``=*''
%in a NODES directive.
%A current executing node array corresponds to the executing node set
%and also the current set of images
%at the evaluation of the declaration of the node array.
%
%Each image in the current set of images corresponds 
%to the element of an executing node array whose
%subscript order value is the same as the current image index
%of the image at the evaluation of the declaration of the executing node array.


\subsection{Image index determined by an equivalenced node array}

A NODES directive with ``={\it node-ref}'' that is not ``=*'' or ``=**''
specifies that
each element of the declared node array corresponds in (Fortran) array
element order
to that of the {\it node-ref},
which is a name of a node array or a subobject of a node array.
The nodes in the declared node array and the corresponding images 
are ordered in (Fortran) array element order in the {\it node-ref}.
The image index of an image in the set of images
corresponding to the declared node array
is the integer order value in the range one to the cardinality of the set of images.
%The node number of a node in the set of nodes corresponding to the declared node array
%is the integer order value in the range one to the cardinality of the set of nodes.


\subsection{On-node image index}

XcalableMP supports COARRAY directive and IMAGE directive to
specify that an image index indicates the image corresponding to
the element of a particular node array whose subscript order value is 
the same as the image index.
The image index is an on-node image index for the specified node array. 
Since evaluation of the declaration of a node array 
determines a set of images corresponding to the node array,
the directives specify that the set of images 
is the ``all images'' for the image indices the directives affect.
In particular, the on-node image index for a primary node array
is the primary image index. 


\section{Basic concepts}


In XcalableMP, ``all images'' in Fortran 2008 changes coupled with the 
execution of TASK directive constructs and
 means the current set of images.
In particular,
when an ALLOCATE statement is executed for which an {\it allocate-object} is
a coarray, there is an implicit synchronization of 
all the images in the current set of images.
On each image in the current set of images, execution of the segment 
following the statement is delayed until
all other images in the set have executed the same
statement the same number of times.
When a DEALLOCATE statement is executed for which an {\it allocate-object} is
a coarray, there is an implicit synchronization of all the images
in the current set of images.
On each image in the current set of images, execution of the segment following the
statement is delayed until all other images in the set
have executed the same statement the same number of times.



%\subsection{A restriction on allocatable coarrays}

\begin{itemize}
 \item 
When an allocatable coarray is allocated during the execution of
       TASK directive constructs,
       the coarray shall be subsequently deallocated before the completion of 
       the TASK directive construct whose
       {\itshape task-directive} is the most lately executed one 
       in the TASK directive constructs that are not completed at the allocation.

\end{itemize}


The image index determined by an image selector 
indicates the current image index by default.
Coarrays are visible within the range of the ``all images'' and
accessed with the current image index by default.
The image index that appears in an executable statement
indicates the current image index by default.


\subsection{Examples}

\begin{itemize}
 
 \item In the following code fragment, the value of a coarray {\ttfamily b} on 
the images 1, 2, 3, and 4, which constitute the executing node set
and correspond to {\ttfamily node(5)}, {\ttfamily node(6)}, {\ttfamily node(7)}, and {\ttfamily node(8)} respectively,
is defined with the value of the coarray {\ttfamily a} on {\ttfamily node(5)}.

\begin{verbatim}
      program xmpcoarray
!$xmp nodes node(8)=**   ! A primary node array.
!$xmp task on node(5:8)  ! The executing node set
        call sub         ! corresponds to node(5:8).
!$xmp end task
      end

      subroutine sub           
      real, save :: a[*], b[*] ! The images 1, 2, 3,
         :                     ! and 4 correspond to node(5:8),
      b = a[1]                 ! respectively.
\end{verbatim}

 \item In the following code fragment, an allocatable coarray {\ttfamily a}
is allocated on the images 1, 2, 3, and 4, 
which constitute the executing node set
and correspond to {\ttfamily node(5)}, {\ttfamily node(6)}, {\ttfamily node(7)}, and {\ttfamily node(8)} respectively.

\begin{verbatim}
      program xmpcoarray
!$xmp nodes node(8)=**
!$xmp task on node(5:8)  ! The executing node set
        call sub2        ! corresponds to node(5:8).
!$xmp end task
      end

      subroutine sub2           
      real, allocatable :: a(:)[:]
        :                         
      allocate(a(0:99)[*])        
\end{verbatim}
\end{itemize}



\paragraph*{Note}
\begin{itemize}
 \item 
       The result value of {\tt xmp\_num\_nodes()}
       is always the same as that of {\ttfamily NUM\_IMAGES()}.

 \item 
  The result value of {\tt xmp\_node\_num()} is always the same as that of {\tt THIS\_IMAGE()}.
 \item 
       In a READ statement, an io-unit that is an asterisk identifies an
       external unit that is preconnected for sequential formatted input
       only on the image whose primary image index is 1.

\end{itemize}



\section{COARRAY directive}
\subsection{Purpose and form of the COARRAY directive}

The COARRAY directive maps coarrays onto a node array and
the set of images that corresponds to the node array.
An image index determined by an image selector for a coarray
that appears in a COARRAY directive
always indicates the on-node image index for the node array;
that is, the specified image corresponds to the node whose subscript order value in the
node array is the same as the image index.

A coarray appearing in a COARRAY directive is an on-node coarray of the node array that is specified in the CORRAY directive.


\medskip


\begin{tabular}{llll}
 & & & \\
\verb![F]!  &  {\it coarray-directive} &  {\bf is} & \verb|!$xmp| {\tt coarray on} {\it node-name} {\tt ::} {\it object-name-list}\\
 & & & \\
\verb![C]!  &   {\it coarray-directive} &  {\bf is} & \verb|#pragma xmp| {\tt coarray on} {\it node-name} {\tt ::} {\it object-name-list}\\
 & & & 
\end{tabular}


\begin{itemize}
 \item An {\it object-name} shall be a name of a coarray declared 
       in the same scoping unit.

 \item The same {\it object-name} shall not appear more than once
       in COARRAY directives in a scoping unit.

 \item If an {\it object-name} is a name of an allocatable object,
       the current set of images
       at the allocation and the deallocation of the
       object shall correspond to the node array specified as the {\it
       node-name} and the current image index of each image shall 
       be the same as the subscript order value of the corresponding element of the node array.

 \item If an {\it object-name} is a name of an allocated allocatable
       dummy argument,
       the set of images onto which it is mapped
       shall be a subset of the set of images that has allocated most lately 
       the corresponding argument in the chain of argument associations.
       
 \item If an {\it object-name} is a name of a nonallocatable dummy argument
       whose ultimate argument has allocatable attribute,
       the set of images onto which the {\it object-name} is mapped
       shall be a subset of the set of images that has allocated most lately 
       the corresponding argument in the chain of argument associations.

 \item The image index determined by an image selector for an on-node
       coarray shall be in the range of one to the size of the node
       array onto which the on-node coarray is mapped.

 \item 
THIS\_IMAGE(COARRAY[,DIM]) shall be invoked by
the image contained in the set of images onto which
the COARRAY argument is mapped,
if the COARRAY argument appears in a COARRAY directive.


\end{itemize}

\paragraph*{Note}
\begin{itemize}
 \item 
       The result value of THIS\_IMAGE(COARRAY)
       is the sequence of cosubscript
       values for the COARRAY argument that would specify the current image index of
       the invoking image, if the COARRAY argument does not appear in a COARRAY
       directive.
       The result value of THIS\_IMAGE(COARRAY)
       is the sequence of cosubscript
       values for the COARRAY argument that would specify the on-node image index of the invoking image
for the node array onto which the COARRAY argument is mapped,
       if the COARRAY argument appears in a COARRAY directive.	      

 \item 

       The result value of THIS\_IMAGE(COARRAY,DIM) is
       the value
       of cosubscript DIM in the sequence of cosubscript values
       for the COARRAY argument that would specify the current image index of
       the invoking image, if the COARRAY argument does not appear in a COARRAY
       directive.
       The result value of THIS\_IMAGE(COARRAY,DIM) is
       the value
       of cosubscript DIM in the sequence of cosubscript values
       for the COARRAY argument that would specify the on-node image index of
       the invoking image for the node array
       onto which the COARRAY argument is mapped,
       if the COARRAY argument appears in a COARRAY
       directive.
\end{itemize}


\subsection{An example of the COARRAY directive}


\begin{verbatim}
      module global
!$xmp nodes node(8)=**    
      real s[*]             ! The coarray s is always 
!$xmp coarray on node :: s  ! visible on node(1:8).
      end global

      program coarray
      use global
!$xmp task on node(5:8)     ! The executing node set 
        call sub            ! consists of node(5:8).
!$xmp end task
      end

      subroutine sub
      use global
      real, save :: a[*]    ! The images 1, 2, 3, and 4 
         :                  ! correspond to node(5:8), respectively.
      if(this_image().eq.1)then ! The value of the coarray a on node(5) 
         s[1] = a               ! defines that of the coarray s on node(1)
      endif
\end{verbatim}


\section{IMAGE directive}
\subsection{Purpose and form of the IMAGE directive}

The IMAGE directive specifies that 
an image index in the following executable statement
indicates the on-node image index
of the node array specified in the IMAGE directive
unless the image index is determined by an image selector.


The IMAGE directive also specifies that 
execution of a SYNC ALL statement performs a synchronization of all the
images corresponding to the node array specified in the IMAGE directive.


\medskip


\begin{tabular}{llll}
 & & & \\
\verb![F]!  &   {\it image-directive} &  {\bf is} & \verb|!$xmp| {\tt image} {\tt (} {\it node-name} {\tt )}\\
 & & & \\
\verb![C]!  &   {\it image-directive} &  {\bf is} & \verb|#pragma xmp| {\tt image} {\tt (} {\it node-name} {\tt )}\\
 & & & 
\end{tabular}


\begin{itemize}
 \item An {\it image-directive} shall be followed by a sync all statement,
       an image control statement that contains {\it image-set}, or a reference to
       an intrinsic procedure that has {\tt IMAGES} argument.
\end{itemize}

\subsection{An example of the IMAGE directive}

\begin{verbatim}
      module global
!$xmp nodes node(8)=**
      real s[*]             ! The coarray s is always visible 
!$xmp coarray on node :: s  ! on node(1:8).
      end global

      program image
      use global
!$xmp tasks
!$xmp task on node(1:4) 
        call subA  ! The executing node set consists of node(1:4).
!$xmp end task
!$xmp task on node(5:8) 
        call subB  ! The executing node set consists of node(5:8).
!$xmp end task
!$xmp end tasks
      end

      subroutine subA      
      use global
      real, save :: a[*] ! The images 1, 2, 3, and 4 
         :               ! correspond to node(1:4), respectively.
!$xmp image(node)        ! Synchronization between node(1:4) and
        sync images(5)   ! node(5).
      a = s[1]           ! a on node(1:4) is defined with 
         :               ! the value of s on node(1).
      end subroutine	

      subroutine subB 
      use global
      real, save :: b[*] ! The images 1, 2, 3, and 4 
         :               ! correspond to node(5:8), respectively.
      if(this_image() .eq. 1)then ! The image 1 indicates node(5).
        s[1] = b      ! s on node(1) is defined with the value of 
                      ! b on node(5).
!$xmp   image(node)                ! Synchronization between 
          sync images((/1,2,3,4/)) ! node(5) and node(1:4).
      endif
         :
      end subroutine		
\end{verbatim}


\section{Image index translation intrinsic procedures}

XcalableMP supports intrinsic procedures to translate
image indices between different sets of images.

\subsection{Translation to the primary image index}

{\bf xmp\_get\_primary\_image\_index(NUMBER,INDEX,PRI\_INDEX,NODE\_DESC)}


\begin{description}
 \item[Description.] Translate image indices to the primary image indices.

 \item[Class.] Subroutine.
	    
 \item[Arguments.] 
	    \begin{description}
	     \item[NUMBER] shall be a scalar of type default integer. It is an INTENT(IN) argument.
	     \item[INDEX] shall be a rank-one array of type default integer.
			The size of {\bfseries INDEX} shall be
			greater than or equal to the value of {\bfseries NUMBER}.
			It is an INTENT(IN) argument.
			The value of each element of {\bfseries INDEX} shall be in
			the range one
			to the size of the node array specified 
			in {\bfseries NODE\_DESC} if {\bfseries NODE\_DESC} appears.
			The value of each element of {\bfseries INDEX} shall be in
			the range one
			to the cardinality of the current set of images
			if {\bfseries NODE\_DESC} does not appear.
	     \item[PRI\_INDEX] shall be a rank-one array of type default integer.
			The size of {\bfseries PRI\_INDEX} shall be
			greater than or equal to the value of {\bfseries NUMBER}.
			It is an INTENT(OUT) argument.
			If {\bfseries NODE\_DESC} appears,
			{\bfseries PRI\_INDEX(i)} is assigned the primary image index
			corresponding to the element of the node array
			specified in {\bfseries NODE\_DESC}
			whose subscript order value is {\bfseries INDEX(i)}; otherwise,
			{\bfseries PRI\_INDEX(i)} is assigned the primary image index
			corresponding to the image whose
			current image index is {\bfseries INDEX(i)}.
	     \item[NODE\_DESC (optional)] shall be a descriptor of a
			node array. It is an INTENT(IN) argument.
			{\bfseries NODE\_DESC} shall appear in XcalableMP C.
	    \end{description}

 \item[Example.] 
In the following code fragment, the value of {\ttfamily index(1:4)} is {\ttfamily (/5,6,7,8/)}.
\begin{verbatim}
!$xmp nodes node(1:8)=**        ! A primary node array
!$xmp nodes subnode(4)=node(5:8)
      integer index(4)
      call xmp_get_primary_image_index&
           &(4,(/1,2,3,4/),index,xmp_desc_of(subnode))
\end{verbatim}
\end{description}


\subsection{Translation to the current image index}
%{\bf XMP\_GET\_IMAGE\_INDEX(CURINDEX,INDEX,NUM,NODE\_DESC)}

{\bf xmp\_get\_image\_index(NUMBER,INDEX,CUR\_INDEX,NODE\_DESC)}

\begin{description}
 \item[Description.] Translate image indices to the current image indices.

 \item[Class.] Subroutine.
	    
 \item[Arguments.] 
	    \begin{description}
	     \item[NUMBER] shall be a scalar of type default integer. It is an INTENT(IN) argument.
	     \item[INDEX] shall be a rank-one array of type default integer.
			The size of {\bfseries INDEX} shall be
			greater than or equal to the value of {\bfseries NUMBER}.
			It is an INTENT(IN) argument.
			The value of each element of {\bfseries INDEX} shall be in
			the range one
			to the size of the node array specified 
			in {\bfseries NODE\_DESC}.
	     \item[CUR\_INDEX] shall be a rank-one array of type default integer.
			The size of {\bfseries CUR\_INDEX} shall be
			greater than or equal to the value of {\bfseries NUMBER}.
			It is an INTENT(OUT) argument.
			If the current image index 
			corresponding to the element of the node-array
			specified in {\bfseries NODE\_DESC}
			whose subscript order value is {\bfseries INDEX(i)}
			exists,
			{\bfseries CUR\_INDEX(i)} is assigned the current image index;
			otherwise, {\bfseries CUR\_INDEX(i)} is assigned zero.
	     \item[NODE\_DESC] shall be a descriptor of a
			node array. It is an INTENT(IN) argument.
	    \end{description}

 \item[Example.] 
In the following code fragment, the value of {\ttfamily index(1:4)} is {\ttfamily (/1,2,3,4/)}.
\begin{verbatim}
!$xmp nodes node(1:8)=**        
      integer index(4)
!$xmp task on node(5:8)
        call xmp_get_image_index&
             &(4,(/5,6,7,8/),index,xmp_desc_of(node))
!$xmp end task
\end{verbatim}
\end{description}


\section{Examples of communication between tasks}

\begin{itemize}
 \item In the following program fragment, two tasks communicate
with each other with synchronization.
\begin{verbatim}
      module nodes
!$xmp nodes node(8)=**            ! A primary node array
      integer, parameter :: n=2
!$xmp nodes subnodeA(n)=node(1:n)      ! subnodeA is for taskA.
!$xmp nodes subnodeB(8-n)=node(n+1:8)  ! subnodeB is for taskB.
      endmodule

      module intertask
      use nodes
      real,save :: dA[*],dB[*]     
      endmodule

      use nodes
!$xmp tasks  
!$xmp task on subnodeA  ! The taskA is invoked on subnodeA.
        call taskA
!$xmp end task
!$xmp task on subnodeB  ! The taskB is invoked on subnodeB.
        call taskB
!$xmp end task
!$xmp end tasks
      end

      subroutine taskA
      use intertask 
         :
      me = this_image()    ! The value of me is i on subnodeA(i).
      if(me.eq.1)then
        call xmp_get_primary_image_index&  ! The value of iyouabs
               &(1,(/1/),iyouabs,subnodeB) ! is n+1.
!$xmp   image(node)                    ! Synchronization between
          sync images(iyouabs)         ! node(1) and node(n+1).
        call exchange(dA,dB,iyouabs)   
!$xmp   image(node)                    ! Synchronization between
          sync images(iyouabs)         ! node(1) and node(n+1).
      endif
      sync all                ! Synchronization within subnodeA.
      if(me.ne.1)dA = dA[1]            
      sync all                ! Synchronization within subnodeA.
       :
      end

      subroutine taskB
      use intertask
         :
      me = this_image()    ! The value of me is i on subnodeB(i).
      if(me.eq.1)then
        call xmp_get_primary_image_index&  ! The value of iyouabs
             &(1,(/1/),iyouabs,subnodeA)   ! is 1.
!$xmp   image(node)                    ! Synchronization between
          sync images(iyouabs)         ! node(n+1) and node(1).
        call exchange(dB,dA,iyouabs)   
!$xmp   image(node)                    ! Synchronization between
          sync images(iyouabs)         ! node(n+1) and node(1).
      endif
      sync all                ! Synchronization within subnodeB.
      if(me.ne.1)dB = dB[1]  
      sync all                ! Synchronization within subnodeB.

      end

      subroutine exchange(mine,yours,iput)
      use nodes
      real :: mine[*],yours[*]       ! mine and yours are always 
!$xmp coarray on node :: mine,yours  ! visible on node(1:8).

      yours[iput] = mine  ! node(1) puts mine to yours[n+1] and 
                          ! node(n+1) puts mine to yours[1].
      end
\end{verbatim}


 \item In the following program fragment, two tasks communicate
with each other without one-to-one synchronization.

\begin{verbatim}
!$xmp nodes node(8)=**       ! A primary node array
        :
!$xmp tasks                        
!$xmp   task on(node(1:n))
          call taskA(n)      ! The taskA is invoked on node(1:n)
!$xmp   end task
!$xmp   task on(node(n+1:8))
          call taskB(8-n)    ! The taskB is invoked on node(n+1:8)
!$xmp   end task
!$xmp end tasks
      end

      subroutine taskA(n)
      real,save :: yours[*],mine[*]
!$xmp nodes subnode(n)=*        ! An executing node array

      me = this_image()
      if(me.eq. NUM_IMAGES())then
         call xmp_get_primary_image_index(1,me,meabs) ! meabs=n.
         call exchange(yours,mine,meabs,meabs+1,NUM_IMAGES())
      endif
      sync all                  ! Synchronization within node(1:n).
      if(me.ne.NUM_IMAGES())mine = mine[NUM_IMAGES()] 
      sync all                  ! Synchronization within node(1:n).
      end

      subroutine taskB(m)
      real,save :: yours[*],mine[*]
!$xmp nodes subnode(m)=*        ! An executing node array

      me = this_image()
      if(me.eq.1)then
         call xmp_get_abs_image_index(1,me,meabs) ! meabs=n+1.
         call exchange(yours,mine,meabs,meabs-1,NUM_IMAGES())
      endif
      sync all                  ! Synchronization within node(n+1:8).
      if(me.ne.1)mine = mine[1]       
      sync all                  ! Synchronization within node(n+1:8).
      end

      subroutine exchange(yours,mine,meabs,iyouabs,nnodes)
      USE, INTRINSIC :: ISO_FORTRAN_ENV
      real :: yours[*],mine[*]
      real, save :: s[*]                       ! only for exchage.
      TYPE(LOCK_TYPE),save :: lock[*]          ! for lock.
!$xmp nodes subnode(nnodes)=*     ! An executing node array.
!$xmp nodes node(8)=**            ! The coarrays s and lock are 
!$xmp coarray on node :: s,lock   ! always visible on node(1:8).

      LOCK(lock[meabs])   ! node(n) puts yours[n] to s[n] and 
      s[meabs] = yours    ! node(n+1) puts yours[n+1] to s[n+1].
      UNLOCK(lock[meabs])

      LOCK(lock[iyouabs])  ! node(n) gets s[n+1] into mine[n] and 
      mine = s[iyouabs]    ! node(n+1) gets s[n] into mine[n+1].
      UNLOCK(lock[iyouabs])
      end
\end{verbatim}

\end{itemize}

%\section{Coarrays in XcalableMP}
%
%The specification of the coarray features in XcalableMP conforms to that
%of Fortran 2008 unless otherwise provided.
%%
%Each node in the entire node set is considered to correspond to each
%image of a program. Therefore the number of images is always equal to
%the size of the entire node set. The image index of a node is its node
%number of the entire node set.
%
%Declaring coarrays on an arbitrary node array, which may not correspond
%to the entire node set, is an open issue of {\XMP} and under
%discussion. Note that even if the coarray features of {\XMP} would be
%extended in the future version so that they could be declared on a
%subset of the entire node set, they are compatible with those of Fortran
%2008 as long as declared on the entire node set.
%
%Terms related to coarrays in {\XMP} (e.g. \Term{coshape}, coindex,
%cobound, \Term{cosubscript}, image, image index, etc.) are derived from
%that in Fortran 2008.

\section{{\tt [C]} Coarrays in {\XMPC}.}

%Described in the rest of this section is the coarray features for
%{\XMPC}.
This section describes the coarray features for {\XMPC}.

\subsection{{\tt [C]} Declaration of Coarrays}

\subsubsection*{Synopsis}

Coarrays are declared in {\XMPC}.

\subsubsection*{Syntax}
\Syntax{coarray}

\begin{tabular}{ll}
\verb![C]! & {\it data-type} {\it variable} {\openb}{\tt
     ,} {\it variable} {\closeb}{\tt ...} {\tt :} 
{\it codimensions} \\
\end{tabular}

\vspace{0.5cm}

where {\it codimensions} is:

\vspace{0.3cm}
\hspace{0.5cm} {\openb}{\tt [}{\it int-expr}{\tt ]}...{\closeb}{\tt [*]}

\subsubsection*{Description}
For {\XMPC}, 
coarrays are declared with a colon and square bracket where {\it codimensions} specify the coshape of a variable.

Note that, the {\tt coarray} directive for defining a coarray in the XcalableMP specification 1.0 (page 49) is obsolete.

\subsubsection*{Restrictions}

\begin{itemize}
 \item A coarray {\it variable} must have a global scope.
\end{itemize}

\subsubsection*{Examples}
\Example{coarray}

\begin{XCexample}
#pragma xmp nodes p(16)
float x:[*];
\end{XCexample}

A variable {\it x} that has a global scope is declared as a coarray.

\subsection{{\tt [C]} Reference of Coarrays}

\subsubsection*{Synopsis}
A coarray can be directly referenced or defined by any node. 
The target node is specified using an extended notation in {\XMPC}.

\subsubsection*{Syntax}
\index{coarray reference}
\index{Syntax!coarray reference}

\begin{tabular}{ll}
\verb![C]! & {\it variable} {\tt :} {\tt [}{\it int-expr}{\tt ]}...\\
\end{tabular}

\subsubsection*{Description}

A sequence of {\tt [}{\it int-expr}{\tt ]}'s preceded by a colon in
{\XMPC} determines the image index for a coarray to be accessed.

An reference of coarrays can appear in the same place as an reference of
normal variables in the base languages.

\subsubsection*{Examples}
\Example{coarray}

In the following code, each executing node gets whole of {\tt B} from
the image 10 (that is, the tenth node of the entire node set) and
copies it into the local storage for {\tt A}.

\vspace{0.3cm}

\index{Example!coarray reference}
\begin{XCexample}
int A[10]:[*], B[10]:[*];

A[:] = B[:]:[10];
\end{XCexample}

%\subsection{Declaration of Coarrays}
%
%\subsubsection*{Synopsis}
%
%Coarrays are declared in the same manner as in Fortran 2008 for {\XMPF},
%or with the {\tt coarray} directive for {\XMPC}.
%
%\subsubsection*{Syntax}
%\Syntax{coarray}
%
%\begin{tabular}{ll}
%%\verb![F]! & {\it type-declaration-stmt} {\openb}{\tt on} {\it
%% nodes-ref}{\closeb}\\
%%\verb![F]! & {\it codimension-stmt} {\openb}{\tt on} {\it nodes-ref}{\closeb}\\
%\verb![F]! & \verb|!$xmp coarray| {\it variable-name} {\openb}{\tt ,}
%     {\it variable-name} {\closeb}{\tt ...} {\tt on} {\it nodes-ref} \\
%\verb![C]! & \verb|#pragma xmp coarray| {\it variable-name} {\openb}{\tt
%     ,} {\it variable-name} {\closeb}{\tt ...} {\tt :} 
%{\it codimensions} {\openb}{\tt on} {\it nodes-ref}{\closeb}\\
%\end{tabular}
%
%\vspace{0.5cm}
%
%where {\it codimensions} is:
%
%\vspace{0.3cm}
%\hspace{0.5cm} {\openb}{\tt [}{\it int-expr}{\tt ]}...{\closeb}{\tt [*]}
%
%\subsubsection*{Description}
%
%For {\XMPF}, coarrays are declared in the same manner as in Fortran
%2008, which is not described in this document.
%%
%For {\XMPC}, coarrays are declared with the {\tt coarray} directive
%where {\it codimensions} specify the \Term{coshape} of a variable.
%%
%Terms related to coarrays in {\XMP} (e.g. coshape, coindex,
%cobound, \Term{cosubscript}, image, image index, etc.) are derived from
%that in Fortran 2008.
%
%In addition, the {\tt on} clause of the {\tt coarray} directive
%specifies a node array on each element of which the coarray object is
%allocated, and associates each {\it \Term{image}} of the coarray with a
%node of the node array so that an image having an {\it \Term{image
%index}} is associated with a node that have the same index of the node
%array in the Fortran's array element order.
%%
%If the {\tt coarray} directive is not specified in {\XMPF} or the {\tt
%on} clause of the {\tt coarray} directive is not specified in {\XMPC},
%then it is assumed that an implicit node array corresponding to the
%executing node set is specified.
%
%Note that an actual coarray and its associating dummy coarray must be
%declared on the same node set (see chapter \ref{chap:procedure}).
%
%\subsubsection*{Restrictions}
%
%\begin{itemize}
% \item \verb![F]! All of the variables appeared in a {\tt coarray}
%       directive must have the codimension attributes.
% \item If the coarray specified by {\it variable-name} is local to the
%       procedure, the node set specified by the {\tt on} clause must be
%       the executing node set of the procedure or its subset.
%% \item The node array specified by the {\tt on} clause of the {\tt
%%       coarray} directive for a procedure-local variable must
%%       correspond to the executing node set of the procedure.
%% \item \verb![F]! All of the variables declared by {\it
%%       type-declaration-stmt} in the first form with the {\tt on} clause
%%       must have the codimension attribute.
%% \item \verb![F]! At most one {\tt on} clause can be specified for a
%%       variable in a scoping unit.
%% \item The cosize of each declared coarray must be less than or equal to
%%       the size of the node set specified by the {\tt on} clause.
%\end{itemize}
%
%\subsubsection*{Examples}
%\Example{coarray}
%
%\begin{description}
%\item[Example 1]
%\hspace{\hsize}
%\begin{XFexample}
%!$xmp nodes w(50)
%      real wa(100)[*]
%      ...
%!$xmp tasks
%!$xmp task on w(1:30)
%      call task1 ( wa )
%!$xmp end task
%!$xmp task on w(32:50)
%      call task2 ( wa )
%!$xmp end task
%      ...
%      subroutine task1 ( aa )
%!$xmp nodes w(50)
%!$xmp nodes p(50) = *
%      real aa(100)[*]
%!$xmp coarray aa on w
%      real b(100)[*] 
%      ...
%      subroutine task2 ( aa )
%!$xmp nodes w(50)
%!$xmp nodes p(20) = *
%      real aa(100)[*]
%!$xmp coarray aa on w
%      real c(100)[*] 
%      ...
%\end{XFexample}
%
%	   The coarray {\tt wa} declared on the entire node set {\tt w}
%	   is passed as an actual argument to subroutines {\tt task1}
%	   and {\tt task2}.
%	   In these subroutines, the coarray object is referenced as the
%	   formal argument {\tt aa} and its declaration requires the {\tt
%	   on} clause to specify the entire node set, which is
%	   different from the executing node set.
%%	   By this declaration, the subroutine can
%%	   access {\tt wa}.
%	   Note that the coarrays {\tt b} and {\tt c} are
%	   local variables in the subroutines {\tt task1} and {\tt
%	   task2}, respectively, and therefore they are declared on the
%	   executing node set specified by {\tt p}.
%%	   Since {\tt b} is
%%	   mapped to {\tt w(1:30)} and {\tt c} is mapped onto {\tt
%%	   w(31:51)}, there is no way to access coarray {\tt c} ({\tt
%%	   b}) from {\tt task1} ({\tt task2}) because a subroutine can
%%	   access the entire node set or its subset as well as the
%%	   executing node set.
%
%\item[Example 2]
%\hspace{\hsize}
%\begin{Fexample}
%!$xmp nodes w1(200)
%      real one(100)[*]
%      real two(50)[20,*]
%\end{Fexample}
%
%%$
%
%	   The entire node set contains 200 nodes, on which coarrays {\tt
%	   one} and {\tt two} are declared. In this case, it is
%	   guaranteed that {\tt one(...)[i+(j-1)*20]} and {\tt
%	   two(...)[i,j]} reside in the same node, which is also the
%	   case for the following codes. Such a rule is compatible with
%	   that of Fortran 2008. The shape of the entire node set has
%	   nothing to do with the image of coarrays.
%
%\begin{Fexample}
%!$xmp nodes w2(20,10)
%      real one(100)[*]
%      real two(50)[20,*]
%\end{Fexample}
%
%\begin{Fexample}
%!$xmp nodes w3(10,5,4)
%      real one(100)[*]
%      real two(50)[20,*]
%\end{Fexample}
%
%\item[Example 2]
%\hspace{\hsize}
%\begin{XFexample}
%!$xmp nodes w1(200)
%!$xmp nodes w2(20,10)
%      real one(100)[*]
%      real two(50)[20,*]
%!$xmp coarray one, two on w1
%      real ichi(100)[*]
%      real ni(50)[20,*]
%!$xmp coarray ichi, ni on w2
%\end{XFexample}
%
%%In many application programs, neighbor communication
%%is an important communication pattern. The optimal mapping from
%%the logical node to the physical node depends on the number of dimensions. For
%%example, the optimal mapping for the communication between
%%{\tt one(...)[i]} and {\tt one(...)[i+1]} is different from the
%%mapping for the communication between {\tt two(...)[i,j]} and {\tt
%%  two(...)[i+1,j]}. 
%
%%In {\XMP}, several mappings can be described. In this example, the
%%mapping may be compatible with Coarray Fortran, and a different mapping
%%can be selected. By switching the runtime option, node sets {\tt w1} and
%%{\tt w2} can be different node sets. 
%
%	   The coarrays {\tt one} and {\tt two} are declared on the node
%	   set {\tt w1}, and therfore {\tt
%	   one(...)[i+(j-1)*20]} and {\tt two(...)[i,j]} reside in the
%	   same node. The coarrays {\tt ichi} and {\tt ni} are declared
%	   on a node set {\tt w2}, and {\tt
%	   ichi(...)[i+(j-1)*20]} and {\tt ni(...)[i,j]} reside in the
%	   same node.
%%
%	   However, it is not guaranteed either that {\tt one(...)[i]}
%	   and {\tt ichi(...)[i]} reside in the same node or that {\tt 
%	   two(...)[i,j]} and {\tt ni(...)[i,j]} reside in the same
%	   node.
%%
%	   Note that this point is {\it not} compatible with Fortran
%	   2008.
%
%\end{description}


%\subsection{Reference of Coarrays}
%
%\subsubsection*{Synopsis}
%
%A coarray can be directly referenced or defined by any node in the node
%set on which it is declared. The target node is specified in the same
%manner as in Fortran 2008 in {\XMPF} or using an extended notation in
%{\XMPC}.
%
%\subsubsection*{Syntax}
%\index{coarray reference}
%\index{Syntax!coarray reference}
%
%\begin{tabular}{ll}
%\verb![F]! & {\it variable} {\tt [} {\it int-expr} 
%{\openb}, {\it int-expr} {\closeb}... {\tt ]}\\
%\verb![C]! & {\it variable} {\tt :} {\tt [}{\it int-expr}{\tt ]}...\\
%\end{tabular}
%
%\subsubsection*{Description}
%
%A sequence of {\it int-expr}'s in a square bracket in {\XMPF} and a
%sequence of {\tt [}{\it int-expr}{\tt ]}'s preceded by a colon in
%{\XMPC} determine the image index for a coarray to be accessed.
%
%An reference of coarrays can appear in the same place as an reference of
%normal variables in the base languages.
%
%Note that a coarray cannot be directly accessed by a node outside the
%node set on which it is declared.%, unlike in Fortran 2008.
%
%\subsubsection*{Examples}
%\Example{coarray}
%
%In each of the following two codes, two coarrays {\tt A} and {\tt B} are
%declared on the executing node set, and each executing node gets whole
%of {\tt B} from the image 10 (that is, the tenth node of the executing
%node set) and copies it into the local storage for {\tt A}.
%
%\vspace{0.5cm}
%
%\index{Example!coarray reference}
%\begin{minipage}{0.45\hsize}
%\begin{center}
%\begin{Fexample}
%      integer A(10)[*], B(10)[*]
%
%
%      A(:) = B(:)[10]
%\end{Fexample}
%\end{center}
%\end{minipage}
%%
%\begin{minipage}{0.45\hsize}
%\begin{center}
%\begin{XCexampleR}
%int A[10], B[10];
%#pragma xmp coarray A, B : [*]
%
%A[:] = B[:]:[10];
%\end{XCexampleR}
%\end{center}
%\end{minipage}

\subsection{{\tt [C]} Syncronization of Coarrays} 
\subsubsection*{Synopsis}
{\XMPC} provides syncronization functions for coarrays.

\subsubsection*{Format}
\begin{tabular}{lll}
\verb![C]!&  {\tt void}& {\tt xmp\_sync\_all(int* {\it status})} \\
\verb![C]!&  {\tt void}& {\tt xmp\_sync\_memory(int* {\it status})} \\
\verb![C]!&  {\tt void}& {\tt xmp\_sync\_image(int {\it image}, int* {\it status})} \\
\verb![C]!&  {\tt void}& {\tt xmp\_sync\_images(int {\it num}, int* {\it image\_set}, int* {\it status})} \\
\verb![C]!&  {\tt void}& {\tt xmp\_sync\_images\_all(int* {\it status})}
\end{tabular}

\subsubsection*{Description}

\begin{itemize}
 \item {\tt xmp\_sync\_all} is equivalent to the {\tt sync all} statement in Fortran 2008.
 \item {\tt xmp\_sync\_memory} is equivalent to the {\tt sync memory} statement in Fortran 2008.
 \item A combination of {\tt xmp\_sync\_image}, {\tt xmp\_sync\_images}, and {\tt xmp\_sync\_images\_all} 
   is equivalent to the {\tt sync memory} statement in Fortran 2008.
  \begin{itemize}
    \item {\tt xmp\_sync\_image} is to synchronize one image.
    \item {\tt xmp\_sync\_images} is to synchronize some images.
    \item {\tt xmp\_sync\_images\_all} is to synchronize all images.
  \end{itemize}
\end{itemize}

\subsubsection*{Arguments}
\begin{itemize}
  \item The argument {\it status} is defined with one of the follow symbolic constants.
  \begin{itemize}
    \item XMP\_STAT\_SUCCESS
    \item XMP\_STAT\_STOPPED\_IMAGE
  \end{itemize}
  If an execution of the function is success, the {\it status} is defined with XMP\_STAT\_SUCCESS.
  A condition where the {\it status} is defined with XMP\_STAT\_STOPPED\_IMAGE is the same as 
  that where the {\it status} is defined with STAT\_STOPPED\_IMAGE in Fortran 2008.
  These symbolic constants are defined in ``xmp.h''.
  If any other error condition occurs during execution of these functions,
  the {\it status} is defined with a value which is different from the value of XMP\_STAT\_SUCCESS and
  XMP\_STAT\_STOPPED\_IMAGE.
  \item In {\tt xmp\_sync\_image}, the variable {\it image} determines a target image index.
  \item In {\tt xmp\_sync\_images}, the variable {\it num} is a number of target images, and 
        the variable {\it image\_set} is an array where target images set is defined.
\end{itemize}

%\subsection{{\tt [C] sync\_memory} Directive}
%
%\subsubsection*{Synopsis}
%
%In {\XMPC}, the \Directive{sync\_memory} directive is used to complete
%all memory operations on coarrays.
%
%\subsubsection*{Syntax}
%\Syntax{sync\_memory}
%
%\begin{tabular}{ll}
%\verb![C]! & \verb|#pragma xmp sync_memory| \\
%\end{tabular}
%
%\subsubsection*{Description}
%
%%The {\tt sync\_memory} directive ensures that any change of coarrays
%%on the image (or the executing node) is visible to other images (or
%%nodes) and any coarrays on the image can be referenced or defined by
%%other images.
%
%The {\tt sync\_memory} directive ensures that any changes of coarrays
%on the image (or the executing node) done by itself are visible to any
%images (or nodes) and any coarrays on the image can be referenced or
%defined by any images.
%%
%Note that no other {\XMP} directive ensures that.
%
%The {\tt sync\_memory} directive in {\XMPC} has a function equivalent
%to that of the {\tt sync memory} statement in {\XMPF}.
%
%\subsubsection*{Examples}
%\Example{sync\_memory}
%
%\begin{XCexample}
%// a, b, c, and d are coarrays
%
%a = ...;
%... = b;
%c:[p] = ...;
%... = d:[q];
%
%#pragma xmp sync_memory
%\end{XCexample}
%
%\vspace{0.5cm}
%
%When a node finishes executing the {\tt sync\_memory} directive in this
%code snippet at runtime, the following are ensured that:
%
%\begin{itemize}
% \item the local definition of a coarray {\tt a} is complete
%       and it can be referenced and defined by any other nodes;
% \item the local reference of a coarray {\tt b} is complete
%       and it can be defined by any other nodes;
% \item the remote definition of a coarray {\tt c} from the node is
%       complete and it can be referenced and defined by any nodes;
%       and
% \item the remote reference of a coarray {\tt d} from the nodes is
%       complete and it can be defined by any nodes.
%\end{itemize}

%\subsubsection*{Restrictions}
%
%\begin{itemize}
% \item \verb![C]! The variable specified by {\it variable} must be a
%       coarray.
% \item \verb![C]! The number of {\tt [}{\it int-expr}{\tt ]} must be
%       equal to the corank of the variable specified by {\it variable}.
% \item \verb![C]! The value of a each {\it int-expr} must be within the
%       cobounds for its codimension.
% \item \verb![C]! The sequence of {\tt [}{\it int-expr}{\tt ]} must
%       specify an image index value that is not greater than the cosize
%       of the variable specified by {\it variable}.
%\end{itemize}


%\section{Coarray in the {\C} language}
%
%{\XMP} adopts coarray notation. In order to use coarray notation in {\C},
%we propose some extensions of the language.

%\subsection{Declarations and reference of coarray}
%
%A coarray is declared by the coarray directive in {\C}.
%
%\Syntax{coarray}
%\begin{tabular}{ll}
%\verb![C]! & \verb|#pragma xmp| {\tt coarray} {\it coarray-dimension}
%  {\tt ::} {\it array-variable} \\
%\verb![C]! & \verb|#pragma xmp| {\tt coarray} {\it array-variable}
%{\it coarray-dimension} \\
%\end{tabular}
%
%The coarray directive declares a coarray with the coarray dimension.
%
%\subsubsection*{Examples}
%\Example{coarray}
%
%\hspace{\hsize}
%\begin{XCexample}
%int A[10], B[10];
%#pragma xmp coarray [*]: A, B
%
%double p[100][100];
%#pragma xmp coarray p[20][*]
%\end{XCexample}
%
%The coarray object is referenced in the following expression:
%
%\begin{tabular}{ll}
%\hspace{0.5cm} & {\it scalar-variable} {\tt :} {\it image-index} \\
% & {\it array-section-expression} {\tt :} {\it image-index} \\
%\end{tabular}
%
%This expression indicates the co-array on the image indicated by {\it image-index}.
%
%\hspace{\hsize}
%\begin{XCexample}
%      A[:] = B[:]:[10];    // copy from B on image 10 to A
%\end{XCexample}

