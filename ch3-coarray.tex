\chapter{Support for the Local-view Programming}

{\XMP} adopts coarray notations for the local-view
programming. Particularly in the case of {\Fort} being the base
language, the notations are compatible with that of Fortran 2008.

\section{Coarrays in XcalableMP}

The specification of the coarray features in XcalableMP conforms to that
of Fortran 2008 unless otherwise provided.


\subsection{Declaration of Coarrays}

\subsubsection*{Synopsis}

Coarrays are declared in the same manner as in Fortran 2008 for the
Fortran base language, or with the {\tt coarray} directive for the C
base language.

\subsubsection*{Syntax}

\Syntax{coarray}
\begin{tabular}{ll}
\verb![F]! & {\it type-declaration-stmt} {\openb}{\tt on} {\it
 nodes-ref}{\closeb}\\
\verb![F]! & {\it codimension-stmt} {\openb}{\tt on} {\it nodes-ref}{\closeb}\\
\verb![C]! & \verb|#pragma xmp coarray| {\it variable-name} {\tt :} 
{\it codimensions} {\openb}{\tt on} {\it nodes-ref}{\closeb}\\
\end{tabular}

\vspace{0.5cm}

where {\it codimensions} is:

\vspace{0.3cm}
\hspace{0.5cm} {\openb}{\tt [}{\it int-expr}{\tt ]}...{\closeb}{\tt [*]}

\subsubsection*{Description}

For the Fortran base language, coarrays are declared in the same manner
as in Fortran 2008. For the C base language, coarrays are declared with
the {\tt coarray} directive where {\it codimensions} specify the coshape
of a variable.
%
Terms related to coarrays in {\XMP} (e.g. coshape, coindex,
cobound, cosubscript, image, image index, etc.) are derived from that in
Fortran 2008.

In addition, the coarray declaration statements or directives can be
followed by the {\tt on} clause ({\tt on} {\it nodes-ref}).
%
Such an {\tt on} clause specifies a node array on each element of which
the coarray object is allocated, and associates each {\it image} of the
coarray with a node so that an image having an {\it image index} is
associated with a node that have the same index of the node array in the
Fortran's array element order.
%
If the {\tt on} clause is not specified, then it is assumed that 
the executing node set is specified.

Note that an actual coarray and its associating dummy coarray must be
declared on the same node set (see chapter \ref{chap:procedure}).

\subsubsection*{Restrictions}

\begin{itemize}
 \item \verb![F]! All of the variables declared by {\it
       type-declaration-stmt} in the first form with the {\tt on} clause
       must have the codimension attribute.
 \item \verb![F]! At most one {\tt on} clause can be specified for a
       variable in a scoping unit.
% \item The cosize of each declared coarray must be less than or equal to
%       the size of the node set specified by the {\tt on} clause.
\end{itemize}

\subsubsection*{Examples}
\Example{nodes}
\Example{task}
\Example{tasks}
\Example{end task}
\Example{end tasks}

\begin{description}
\item[Example 1]
\hspace{\hsize}
\begin{Fexample}
!$xmp nodes w(50)
      real wa(100)[*]
      ...
!$xmp tasks
!$xmp task on w(1:30)
      call task1 ( wa )
!$xmp end task
!$xmp task on w(32:50)
      call task2 ( wa )
!$xmp end task
      ...
      subroutine task1 ( aa )
!$xmp nodes w(50)
!$xmp nodes p(50) = *
      real aa(100)[*] on w
      real b(100)[*] 
      ...
      subroutine task2 ( aa )
!$xmp nodes w(50)
!$xmp nodes p(20) = *
      real aa(100)[*] on w
      real c(100)[*] 
      ...
\end{Fexample}

	   The coarray {\tt wa} declared on the entire node set {\tt w}
	   is passed as an actual argument to subroutines {\tt task1}
	   and {\tt task2}.
	   In these subroutines, the coarray object is referenced as the
	   formal argument {\tt aa} and its declaration requires the {\tt
	   on} clause to specify the entire node set, which is
	   different from the executing node set.
%	   By this declaration, the subroutine can
%	   access {\tt wa}.
	   Note that the coarrays {\tt b} and {\tt c} are
	   local variables in the subroutines {\tt task1} and {\tt
	   task2}, respectively, and therefore they are declared on the
	   executing node set specified by {\tt p}.
%	   Since {\tt b} is
%	   mapped to {\tt w(1:30)} and {\tt c} is mapped onto {\tt
%	   w(31:51)}, there is no way to access coarray {\tt c} ({\tt
%	   b}) from {\tt task1} ({\tt task2}) because a subroutine can
%	   access the entire node set or its subset as well as the
%	   executing node set.

\item[Example 2]
\hspace{\hsize}
\begin{Fexample}
!$xmp nodes w1(200)
      real one(100)[*]
      real two(50)[20,*]
\end{Fexample}

%$

	   The entire node set contains 200 nodes, on which coarrays {\tt
	   one} and {\tt two} are declared. In this case, it is
	   guaranteed that {\tt one(...)[i+(j-1)*20]} and {\tt
	   two(...)[i,j]} reside in the same node, which is also the
	   case for the following codes. Such a rule is compatible with
	   that of Fortran 2008. The shape of the entire node set has
	   nothing to do with the image of coarrays.

\begin{Fexample}
!$xmp nodes w2(20,10)
      real one(100)[*]
      real two(50)[20,*]
\end{Fexample}

\begin{Fexample}
!$xmp nodes w3(10,5,4)
      real one(100)[*]
      real two(50)[20,*]
\end{Fexample}

\item[Example 2]
\hspace{\hsize}
\begin{Fexample}
!$xmp nodes w1(200)
!$xmp nodes w2(20,10)
      real one(100)[*] on w1
      real two(50)[20,*] on w1
      real ichi(100)[*] on w2
      real ni(50)[20,*] on w2
\end{Fexample}

%In many application programs, neighbor communication
%is an important communication pattern. The optimal mapping from
%the logical node to the physical node depends on the number of dimensions. For
%example, the optimal mapping for the communication between
%{\tt one(...)[i]} and {\tt one(...)[i+1]} is different from the
%mapping for the communication between {\tt two(...)[i,j]} and {\tt
%  two(...)[i+1,j]}. 

%In {\XMP}, several mappings can be described. In this example, the
%mapping may be compatible with Coarray Fortran, and a different mapping
%can be selected. By switching the runtime option, node sets {\tt w1} and
%{\tt w2} can be different node sets. 

	   The coarrays {\tt one} and {\tt two} are declared on the node
	   set {\tt w1}, and thefore {\tt
	   one(...)[i+(j-1)*20]} and {\tt two(...)[i,j]} reside in the
	   same node. The coarrays {\tt ichi} and {\tt ni} are declared
	   on a node set {\tt w2}, and {\tt
	   ichi(...)[i+(j-1)*20]} and {\tt ni(...)[i,j]} reside in the
	   same node.
%
	   However, it is not guaranteed either that {\tt one(...)[i]}
	   and {\tt ichi(...)[i]} reside in the same node or that {\tt 
	   two(...)[i,j]} and {\tt ni(...)[i,j]} reside in the same
	   node.
%
	   Note that this point is {\it not} compatible with Fortran
	   2008.

\end{description}


\subsection{Reference of Coarrays}

\subsubsection*{Synopsis}

A coarray can be directly referenced or defined by any node in the node
set on which it is declared. The target node is specified in the same
manner as in Fortran 2008 in the Fortran base language or using an
extended notation in the C base language.

\subsubsection*{Syntax}

\Syntax{coarray}
\begin{tabular}{ll}
\verb![F]! & {\it variable} {\tt [} {\it int-expr} 
{\openb}, {\it int-expr} {\closeb}... {\tt ]}\\
\verb![C]! & {\it variable} {\tt :} {\tt [}{\it int-expr}{\tt ]}...\\
\end{tabular}

\subsubsection*{Description}

A sequence of {\it int-expr}'s in a square bracket in the Fortran base
language and a sequence of {\tt [}{\it
int-expr}{\tt ]}'s preceded by a colon in the C base language determine
the image index for a coarray to be accessed.

Note that a coarray cannot be directly accessed by a node outside the
node set on which it is declared, unlike in Fortran 2008.

\subsubsection*{Examples}
\Example{coarray}

In each of the following two codes, two coarrays {\tt A} and {\tt B} are
declared on the executing node set, and each executing node gets whole
of {\tt B} from the image 10 (that is, the tenth node of the executing
node set) and copies it into the local storage for {\tt A}.

\vspace{0.5cm}

\begin{minipage}{0.45\hsize}
\begin{center}
\begin{Fexample}
      integer A(10)[*], B(10)[*]


      A(:) = B(:)[10]
\end{Fexample}
\end{center}
\end{minipage}
%
\begin{minipage}{0.45\hsize}
\begin{center}
\begin{CexampleR}
int A[10], B[10];
#pragma xmp coarray A:[*], B:[*]

A[:] = B[:]:[10];
\end{CexampleR}
\end{center}
\end{minipage}


%\subsubsection*{Restrictions}
%
%\begin{itemize}
% \item \verb![C]! The variable specified by {\it variable} must be a
%       coarray.
% \item \verb![C]! The number of {\tt [}{\it int-expr}{\tt ]} must be
%       equal to the corank of the variable specified by {\it variable}.
% \item \verb![C]! The value of a each {\it int-expr} must be within the
%       cobounds for its codimension.
% \item \verb![C]! The sequence of {\tt [}{\it int-expr}{\tt ]} must
%       specify an image index value that is not greater than the cosize
%       of the variable specified by {\it variable}.
%\end{itemize}


%\section{Coarray in the {\C} language}
%
%{\XMP} adopts coarray notation. In order to use coarray notation in {\C},
%we propose some extensions of the language.

%\subsection{Declarations and reference of coarray}
%
%A coarray is declared by the coarray directive in {\C}.
%
%\Syntax{coarray}
%\begin{tabular}{ll}
%\verb![C]! & \verb|#pragma xmp| {\tt coarray} {\it coarray-dimension}
%  {\tt ::} {\it array-variable} \\
%\verb![C]! & \verb|#pragma xmp| {\tt coarray} {\it array-variable}
%{\it coarray-dimension} \\
%\end{tabular}
%
%The coarray directive declares a coarray with the coarray dimension.
%
%\subsubsection*{Examples}
%\Example{coarray}
%
%\hspace{\hsize}
%\begin{Cexample}
%int A[10], B[10];
%#pragma xmp coarray [*]: A, B
%
%double p[100][100];
%#pragma xmp coarray p[20][*]
%\end{Cexample}
%
%The coarray object is referenced in the following expression:
%
%\begin{tabular}{ll}
%\hspace{0.5cm} & {\it scalar-variable} {\tt :} {\it image-index} \\
% & {\it array-section-expression} {\tt :} {\it image-index} \\
%\end{tabular}
%
%This expression indicates the co-array on the image indicated by {\it image-index}.
%
%\hspace{\hsize}
%\begin{Cexample}
%      A[:] = B[:]:[10];    // copy from B on image 10 to A
%\end{Cexample}
